
Graduation_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003520  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000006ce  00800060  00003520  000035b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000028  0080072e  0080072e  00003c82  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003c82  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003cb4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000498  00000000  00000000  00003cf0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007e70  00000000  00000000  00004188  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000014eb  00000000  00000000  0000bff8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003742  00000000  00000000  0000d4e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bb4  00000000  00000000  00010c28  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d1c  00000000  00000000  000117dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000037e5  00000000  00000000  000124f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003d8  00000000  00000000  00015cdd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 58 02 	jmp	0x4b0	; 0x4b0 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__vector_4>
      14:	0c 94 d1 0b 	jmp	0x17a2	; 0x17a2 <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 61 0b 	jmp	0x16c2	; 0x16c2 <__vector_10>
      2c:	0c 94 1e 0b 	jmp	0x163c	; 0x163c <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 a7 0c 	jmp	0x194e	; 0x194e <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 03 18 	jmp	0x3006	; 0x3006 <__vector_15>
      40:	0c 94 6f 00 	jmp	0xde	; 0xde <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	17 e0       	ldi	r17, 0x07	; 7
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e2       	ldi	r30, 0x20	; 32
      68:	f5 e3       	ldi	r31, 0x35	; 53
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 32       	cpi	r26, 0x2E	; 46
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	ae e2       	ldi	r26, 0x2E	; 46
      7a:	b7 e0       	ldi	r27, 0x07	; 7
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 35       	cpi	r26, 0x56	; 86
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 17 0a 	call	0x142e	; 0x142e <main>
      8a:	0c 94 8e 1a 	jmp	0x351c	; 0x351c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_Init>:
	return Value;
}

void ADC_Disable(void)
{
	Clear_Bit(ADCSRA, 7);
      92:	87 b1       	in	r24, 0x07	; 7
      94:	8f 73       	andi	r24, 0x3F	; 63
      96:	80 64       	ori	r24, 0x40	; 64
      98:	87 b9       	out	0x07, r24	; 7
      9a:	87 b1       	in	r24, 0x07	; 7
      9c:	8f 7d       	andi	r24, 0xDF	; 223
      9e:	87 b9       	out	0x07, r24	; 7
      a0:	86 b1       	in	r24, 0x06	; 6
      a2:	80 62       	ori	r24, 0x20	; 32
      a4:	86 b9       	out	0x06, r24	; 6
      a6:	80 b7       	in	r24, 0x30	; 48
      a8:	8f 71       	andi	r24, 0x1F	; 31
      aa:	80 bf       	out	0x30, r24	; 48
      ac:	86 b1       	in	r24, 0x06	; 6
      ae:	87 60       	ori	r24, 0x07	; 7
      b0:	86 b9       	out	0x06, r24	; 6
      b2:	8f b7       	in	r24, 0x3f	; 63
      b4:	80 68       	ori	r24, 0x80	; 128
      b6:	8f bf       	out	0x3f, r24	; 63
      b8:	86 b1       	in	r24, 0x06	; 6
      ba:	87 7f       	andi	r24, 0xF7	; 247
      bc:	86 b9       	out	0x06, r24	; 6
      be:	86 b1       	in	r24, 0x06	; 6
      c0:	80 68       	ori	r24, 0x80	; 128
      c2:	86 b9       	out	0x06, r24	; 6
      c4:	08 95       	ret

000000c6 <ADC_Read>:
      c6:	97 b1       	in	r25, 0x07	; 7
      c8:	90 7e       	andi	r25, 0xE0	; 224
      ca:	89 2b       	or	r24, r25
      cc:	87 b9       	out	0x07, r24	; 7
      ce:	86 b1       	in	r24, 0x06	; 6
      d0:	80 64       	ori	r24, 0x40	; 64
      d2:	86 b9       	out	0x06, r24	; 6
      d4:	34 9b       	sbis	0x06, 4	; 6
      d6:	fe cf       	rjmp	.-4      	; 0xd4 <ADC_Read+0xe>
      d8:	84 b1       	in	r24, 0x04	; 4
      da:	95 b1       	in	r25, 0x05	; 5
      dc:	08 95       	ret

000000de <__vector_16>:
}

ISR(ADC_vect)
{
      de:	1f 92       	push	r1
      e0:	0f 92       	push	r0
      e2:	0f b6       	in	r0, 0x3f	; 63
      e4:	0f 92       	push	r0
      e6:	11 24       	eor	r1, r1
	// Write the ADC handler here
		
		
		
	
}
      e8:	0f 90       	pop	r0
      ea:	0f be       	out	0x3f, r0	; 63
      ec:	0f 90       	pop	r0
      ee:	1f 90       	pop	r1
      f0:	18 95       	reti

000000f2 <Buzzer_ON>:
      f2:	40 e0       	ldi	r20, 0x00	; 0
      f4:	67 e0       	ldi	r22, 0x07	; 7
      f6:	82 e0       	ldi	r24, 0x02	; 2
      f8:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
      fc:	08 95       	ret

000000fe <Buzzer_OFF>:
      fe:	41 e0       	ldi	r20, 0x01	; 1
     100:	67 e0       	ldi	r22, 0x07	; 7
     102:	82 e0       	ldi	r24, 0x02	; 2
     104:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
     108:	08 95       	ret

0000010a <Buzzer_Toggle>:
     10a:	67 e0       	ldi	r22, 0x07	; 7
     10c:	82 e0       	ldi	r24, 0x02	; 2
     10e:	0e 94 e5 01 	call	0x3ca	; 0x3ca <DIO_TogglePin_Value>
     112:	08 95       	ret

00000114 <DC_Motor1_INIT>:

/*DC_Motor1 Functions implementation*/
void DC_Motor1_INIT(void)
{
	/*DC motor pins direction*/
	DIO_SetPin_Dir(M1_PORT, M1_DIR_PIN1, PIN_OUT);
     114:	41 e0       	ldi	r20, 0x01	; 1
     116:	60 e0       	ldi	r22, 0x00	; 0
     118:	81 e0       	ldi	r24, 0x01	; 1
     11a:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
	DIO_SetPin_Dir(M1_PORT, M1_DIR_PIN2, PIN_OUT);
     11e:	41 e0       	ldi	r20, 0x01	; 1
     120:	61 e0       	ldi	r22, 0x01	; 1
     122:	81 e0       	ldi	r24, 0x01	; 1
     124:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>

	
	/*DC motor pins value*/
	DIO_SetPin_Value(M1_PORT, M1_DIR_PIN1, PIN_OFF);
     128:	41 e0       	ldi	r20, 0x01	; 1
     12a:	60 e0       	ldi	r22, 0x00	; 0
     12c:	81 e0       	ldi	r24, 0x01	; 1
     12e:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
	DIO_SetPin_Value(M1_PORT, M1_DIR_PIN2, PIN_OFF);
     132:	41 e0       	ldi	r20, 0x01	; 1
     134:	61 e0       	ldi	r22, 0x01	; 1
     136:	81 e0       	ldi	r24, 0x01	; 1
     138:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>

	
	/*generate clock for the timer*/
	Timer0_Start();
     13c:	0e 94 19 0b 	call	0x1632	; 0x1632 <Timer0_Start>
     140:	08 95       	ret

00000142 <DC_Motor1_START>:
}

void DC_Motor1_START(f32 duty_cycle, DC_Motor_Dir dir)
{
     142:	cf 92       	push	r12
     144:	df 92       	push	r13
     146:	ef 92       	push	r14
     148:	ff 92       	push	r15
     14a:	6b 01       	movw	r12, r22
     14c:	7c 01       	movw	r14, r24
	switch(dir)
     14e:	44 23       	and	r20, r20
     150:	19 f0       	breq	.+6      	; 0x158 <DC_Motor1_START+0x16>
     152:	41 30       	cpi	r20, 0x01	; 1
     154:	61 f0       	breq	.+24     	; 0x16e <DC_Motor1_START+0x2c>
     156:	15 c0       	rjmp	.+42     	; 0x182 <DC_Motor1_START+0x40>
	{
		case  Clock_Wise:
		DIO_SetPin_Value(M1_PORT, M1_DIR_PIN1, PIN_ON);
     158:	40 e0       	ldi	r20, 0x00	; 0
     15a:	60 e0       	ldi	r22, 0x00	; 0
     15c:	81 e0       	ldi	r24, 0x01	; 1
     15e:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
		DIO_SetPin_Value(M1_PORT, M1_DIR_PIN2, PIN_OFF);
     162:	41 e0       	ldi	r20, 0x01	; 1
     164:	61 e0       	ldi	r22, 0x01	; 1
     166:	81 e0       	ldi	r24, 0x01	; 1
     168:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
		break;
     16c:	0a c0       	rjmp	.+20     	; 0x182 <DC_Motor1_START+0x40>
		case Anti_Clock_Wise:
		DIO_SetPin_Value(M1_PORT, M1_DIR_PIN1, PIN_OFF);
     16e:	41 e0       	ldi	r20, 0x01	; 1
     170:	60 e0       	ldi	r22, 0x00	; 0
     172:	81 e0       	ldi	r24, 0x01	; 1
     174:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
		DIO_SetPin_Value(M1_PORT, M1_DIR_PIN2, PIN_ON);
     178:	40 e0       	ldi	r20, 0x00	; 0
     17a:	61 e0       	ldi	r22, 0x01	; 1
     17c:	81 e0       	ldi	r24, 0x01	; 1
     17e:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
		break;
		default:
		break;
	}
	PWM0_Gen(duty_cycle);
     182:	c7 01       	movw	r24, r14
     184:	b6 01       	movw	r22, r12
     186:	0e 94 df 0a 	call	0x15be	; 0x15be <PWM0_Gen>
}
     18a:	ff 90       	pop	r15
     18c:	ef 90       	pop	r14
     18e:	df 90       	pop	r13
     190:	cf 90       	pop	r12
     192:	08 95       	ret

00000194 <DC_Motor1_STOP>:

void DC_Motor1_STOP(void)
{
	DIO_SetPin_Value(M1_PORT, M1_DIR_PIN1, PIN_OFF);
     194:	41 e0       	ldi	r20, 0x01	; 1
     196:	60 e0       	ldi	r22, 0x00	; 0
     198:	81 e0       	ldi	r24, 0x01	; 1
     19a:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
	DIO_SetPin_Value(M1_PORT, M1_DIR_PIN2, PIN_OFF);
     19e:	41 e0       	ldi	r20, 0x01	; 1
     1a0:	61 e0       	ldi	r22, 0x01	; 1
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
     1a8:	08 95       	ret

000001aa <DIO_SetPin_Dir>:
     1aa:	44 23       	and	r20, r20
     1ac:	19 f0       	breq	.+6      	; 0x1b4 <DIO_SetPin_Dir+0xa>
     1ae:	41 30       	cpi	r20, 0x01	; 1
     1b0:	c9 f1       	breq	.+114    	; 0x224 <DIO_SetPin_Dir+0x7a>
     1b2:	08 95       	ret
     1b4:	81 30       	cpi	r24, 0x01	; 1
     1b6:	91 f0       	breq	.+36     	; 0x1dc <DIO_SetPin_Dir+0x32>
     1b8:	28 f0       	brcs	.+10     	; 0x1c4 <DIO_SetPin_Dir+0x1a>
     1ba:	82 30       	cpi	r24, 0x02	; 2
     1bc:	d9 f0       	breq	.+54     	; 0x1f4 <DIO_SetPin_Dir+0x4a>
     1be:	83 30       	cpi	r24, 0x03	; 3
     1c0:	29 f1       	breq	.+74     	; 0x20c <DIO_SetPin_Dir+0x62>
     1c2:	08 95       	ret
     1c4:	2a b3       	in	r18, 0x1a	; 26
     1c6:	81 e0       	ldi	r24, 0x01	; 1
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	02 c0       	rjmp	.+4      	; 0x1d0 <DIO_SetPin_Dir+0x26>
     1cc:	88 0f       	add	r24, r24
     1ce:	99 1f       	adc	r25, r25
     1d0:	6a 95       	dec	r22
     1d2:	e2 f7       	brpl	.-8      	; 0x1cc <DIO_SetPin_Dir+0x22>
     1d4:	80 95       	com	r24
     1d6:	82 23       	and	r24, r18
     1d8:	8a bb       	out	0x1a, r24	; 26
     1da:	08 95       	ret
     1dc:	27 b3       	in	r18, 0x17	; 23
     1de:	81 e0       	ldi	r24, 0x01	; 1
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_SetPin_Dir+0x3e>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	6a 95       	dec	r22
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_SetPin_Dir+0x3a>
     1ec:	80 95       	com	r24
     1ee:	82 23       	and	r24, r18
     1f0:	87 bb       	out	0x17, r24	; 23
     1f2:	08 95       	ret
     1f4:	24 b3       	in	r18, 0x14	; 20
     1f6:	81 e0       	ldi	r24, 0x01	; 1
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	02 c0       	rjmp	.+4      	; 0x200 <DIO_SetPin_Dir+0x56>
     1fc:	88 0f       	add	r24, r24
     1fe:	99 1f       	adc	r25, r25
     200:	6a 95       	dec	r22
     202:	e2 f7       	brpl	.-8      	; 0x1fc <DIO_SetPin_Dir+0x52>
     204:	80 95       	com	r24
     206:	82 23       	and	r24, r18
     208:	84 bb       	out	0x14, r24	; 20
     20a:	08 95       	ret
     20c:	21 b3       	in	r18, 0x11	; 17
     20e:	81 e0       	ldi	r24, 0x01	; 1
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	02 c0       	rjmp	.+4      	; 0x218 <DIO_SetPin_Dir+0x6e>
     214:	88 0f       	add	r24, r24
     216:	99 1f       	adc	r25, r25
     218:	6a 95       	dec	r22
     21a:	e2 f7       	brpl	.-8      	; 0x214 <DIO_SetPin_Dir+0x6a>
     21c:	80 95       	com	r24
     21e:	82 23       	and	r24, r18
     220:	81 bb       	out	0x11, r24	; 17
     222:	08 95       	ret
     224:	81 30       	cpi	r24, 0x01	; 1
     226:	89 f0       	breq	.+34     	; 0x24a <DIO_SetPin_Dir+0xa0>
     228:	28 f0       	brcs	.+10     	; 0x234 <DIO_SetPin_Dir+0x8a>
     22a:	82 30       	cpi	r24, 0x02	; 2
     22c:	c9 f0       	breq	.+50     	; 0x260 <DIO_SetPin_Dir+0xb6>
     22e:	83 30       	cpi	r24, 0x03	; 3
     230:	11 f1       	breq	.+68     	; 0x276 <DIO_SetPin_Dir+0xcc>
     232:	08 95       	ret
     234:	2a b3       	in	r18, 0x1a	; 26
     236:	81 e0       	ldi	r24, 0x01	; 1
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	02 c0       	rjmp	.+4      	; 0x240 <DIO_SetPin_Dir+0x96>
     23c:	88 0f       	add	r24, r24
     23e:	99 1f       	adc	r25, r25
     240:	6a 95       	dec	r22
     242:	e2 f7       	brpl	.-8      	; 0x23c <DIO_SetPin_Dir+0x92>
     244:	82 2b       	or	r24, r18
     246:	8a bb       	out	0x1a, r24	; 26
     248:	08 95       	ret
     24a:	27 b3       	in	r18, 0x17	; 23
     24c:	81 e0       	ldi	r24, 0x01	; 1
     24e:	90 e0       	ldi	r25, 0x00	; 0
     250:	02 c0       	rjmp	.+4      	; 0x256 <DIO_SetPin_Dir+0xac>
     252:	88 0f       	add	r24, r24
     254:	99 1f       	adc	r25, r25
     256:	6a 95       	dec	r22
     258:	e2 f7       	brpl	.-8      	; 0x252 <DIO_SetPin_Dir+0xa8>
     25a:	82 2b       	or	r24, r18
     25c:	87 bb       	out	0x17, r24	; 23
     25e:	08 95       	ret
     260:	24 b3       	in	r18, 0x14	; 20
     262:	81 e0       	ldi	r24, 0x01	; 1
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	02 c0       	rjmp	.+4      	; 0x26c <DIO_SetPin_Dir+0xc2>
     268:	88 0f       	add	r24, r24
     26a:	99 1f       	adc	r25, r25
     26c:	6a 95       	dec	r22
     26e:	e2 f7       	brpl	.-8      	; 0x268 <DIO_SetPin_Dir+0xbe>
     270:	82 2b       	or	r24, r18
     272:	84 bb       	out	0x14, r24	; 20
     274:	08 95       	ret
     276:	21 b3       	in	r18, 0x11	; 17
     278:	81 e0       	ldi	r24, 0x01	; 1
     27a:	90 e0       	ldi	r25, 0x00	; 0
     27c:	02 c0       	rjmp	.+4      	; 0x282 <DIO_SetPin_Dir+0xd8>
     27e:	88 0f       	add	r24, r24
     280:	99 1f       	adc	r25, r25
     282:	6a 95       	dec	r22
     284:	e2 f7       	brpl	.-8      	; 0x27e <DIO_SetPin_Dir+0xd4>
     286:	82 2b       	or	r24, r18
     288:	81 bb       	out	0x11, r24	; 17
     28a:	08 95       	ret

0000028c <DIO_SetPin_Value>:
     28c:	44 23       	and	r20, r20
     28e:	d9 f1       	breq	.+118    	; 0x306 <DIO_SetPin_Value+0x7a>
     290:	41 30       	cpi	r20, 0x01	; 1
     292:	09 f0       	breq	.+2      	; 0x296 <DIO_SetPin_Value+0xa>
     294:	6b c0       	rjmp	.+214    	; 0x36c <DIO_SetPin_Value+0xe0>
     296:	81 30       	cpi	r24, 0x01	; 1
     298:	91 f0       	breq	.+36     	; 0x2be <DIO_SetPin_Value+0x32>
     29a:	28 f0       	brcs	.+10     	; 0x2a6 <DIO_SetPin_Value+0x1a>
     29c:	82 30       	cpi	r24, 0x02	; 2
     29e:	d9 f0       	breq	.+54     	; 0x2d6 <DIO_SetPin_Value+0x4a>
     2a0:	83 30       	cpi	r24, 0x03	; 3
     2a2:	29 f1       	breq	.+74     	; 0x2ee <DIO_SetPin_Value+0x62>
     2a4:	08 95       	ret
     2a6:	2b b3       	in	r18, 0x1b	; 27
     2a8:	81 e0       	ldi	r24, 0x01	; 1
     2aa:	90 e0       	ldi	r25, 0x00	; 0
     2ac:	02 c0       	rjmp	.+4      	; 0x2b2 <DIO_SetPin_Value+0x26>
     2ae:	88 0f       	add	r24, r24
     2b0:	99 1f       	adc	r25, r25
     2b2:	6a 95       	dec	r22
     2b4:	e2 f7       	brpl	.-8      	; 0x2ae <DIO_SetPin_Value+0x22>
     2b6:	80 95       	com	r24
     2b8:	82 23       	and	r24, r18
     2ba:	8b bb       	out	0x1b, r24	; 27
     2bc:	08 95       	ret
     2be:	28 b3       	in	r18, 0x18	; 24
     2c0:	81 e0       	ldi	r24, 0x01	; 1
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	02 c0       	rjmp	.+4      	; 0x2ca <DIO_SetPin_Value+0x3e>
     2c6:	88 0f       	add	r24, r24
     2c8:	99 1f       	adc	r25, r25
     2ca:	6a 95       	dec	r22
     2cc:	e2 f7       	brpl	.-8      	; 0x2c6 <DIO_SetPin_Value+0x3a>
     2ce:	80 95       	com	r24
     2d0:	82 23       	and	r24, r18
     2d2:	88 bb       	out	0x18, r24	; 24
     2d4:	08 95       	ret
     2d6:	25 b3       	in	r18, 0x15	; 21
     2d8:	81 e0       	ldi	r24, 0x01	; 1
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	02 c0       	rjmp	.+4      	; 0x2e2 <DIO_SetPin_Value+0x56>
     2de:	88 0f       	add	r24, r24
     2e0:	99 1f       	adc	r25, r25
     2e2:	6a 95       	dec	r22
     2e4:	e2 f7       	brpl	.-8      	; 0x2de <DIO_SetPin_Value+0x52>
     2e6:	80 95       	com	r24
     2e8:	82 23       	and	r24, r18
     2ea:	85 bb       	out	0x15, r24	; 21
     2ec:	08 95       	ret
     2ee:	22 b3       	in	r18, 0x12	; 18
     2f0:	81 e0       	ldi	r24, 0x01	; 1
     2f2:	90 e0       	ldi	r25, 0x00	; 0
     2f4:	02 c0       	rjmp	.+4      	; 0x2fa <DIO_SetPin_Value+0x6e>
     2f6:	88 0f       	add	r24, r24
     2f8:	99 1f       	adc	r25, r25
     2fa:	6a 95       	dec	r22
     2fc:	e2 f7       	brpl	.-8      	; 0x2f6 <DIO_SetPin_Value+0x6a>
     2fe:	80 95       	com	r24
     300:	82 23       	and	r24, r18
     302:	82 bb       	out	0x12, r24	; 18
     304:	08 95       	ret
     306:	81 30       	cpi	r24, 0x01	; 1
     308:	89 f0       	breq	.+34     	; 0x32c <DIO_SetPin_Value+0xa0>
     30a:	28 f0       	brcs	.+10     	; 0x316 <DIO_SetPin_Value+0x8a>
     30c:	82 30       	cpi	r24, 0x02	; 2
     30e:	c9 f0       	breq	.+50     	; 0x342 <DIO_SetPin_Value+0xb6>
     310:	83 30       	cpi	r24, 0x03	; 3
     312:	11 f1       	breq	.+68     	; 0x358 <DIO_SetPin_Value+0xcc>
     314:	08 95       	ret
     316:	2b b3       	in	r18, 0x1b	; 27
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	02 c0       	rjmp	.+4      	; 0x322 <DIO_SetPin_Value+0x96>
     31e:	88 0f       	add	r24, r24
     320:	99 1f       	adc	r25, r25
     322:	6a 95       	dec	r22
     324:	e2 f7       	brpl	.-8      	; 0x31e <DIO_SetPin_Value+0x92>
     326:	82 2b       	or	r24, r18
     328:	8b bb       	out	0x1b, r24	; 27
     32a:	08 95       	ret
     32c:	28 b3       	in	r18, 0x18	; 24
     32e:	81 e0       	ldi	r24, 0x01	; 1
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	02 c0       	rjmp	.+4      	; 0x338 <DIO_SetPin_Value+0xac>
     334:	88 0f       	add	r24, r24
     336:	99 1f       	adc	r25, r25
     338:	6a 95       	dec	r22
     33a:	e2 f7       	brpl	.-8      	; 0x334 <DIO_SetPin_Value+0xa8>
     33c:	82 2b       	or	r24, r18
     33e:	88 bb       	out	0x18, r24	; 24
     340:	08 95       	ret
     342:	25 b3       	in	r18, 0x15	; 21
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	02 c0       	rjmp	.+4      	; 0x34e <DIO_SetPin_Value+0xc2>
     34a:	88 0f       	add	r24, r24
     34c:	99 1f       	adc	r25, r25
     34e:	6a 95       	dec	r22
     350:	e2 f7       	brpl	.-8      	; 0x34a <DIO_SetPin_Value+0xbe>
     352:	82 2b       	or	r24, r18
     354:	85 bb       	out	0x15, r24	; 21
     356:	08 95       	ret
     358:	22 b3       	in	r18, 0x12	; 18
     35a:	81 e0       	ldi	r24, 0x01	; 1
     35c:	90 e0       	ldi	r25, 0x00	; 0
     35e:	02 c0       	rjmp	.+4      	; 0x364 <DIO_SetPin_Value+0xd8>
     360:	88 0f       	add	r24, r24
     362:	99 1f       	adc	r25, r25
     364:	6a 95       	dec	r22
     366:	e2 f7       	brpl	.-8      	; 0x360 <DIO_SetPin_Value+0xd4>
     368:	82 2b       	or	r24, r18
     36a:	82 bb       	out	0x12, r24	; 18
     36c:	08 95       	ret

0000036e <DIO_GetPin_Value>:
     36e:	81 30       	cpi	r24, 0x01	; 1
     370:	79 f0       	breq	.+30     	; 0x390 <DIO_GetPin_Value+0x22>
     372:	28 f0       	brcs	.+10     	; 0x37e <DIO_GetPin_Value+0x10>
     374:	82 30       	cpi	r24, 0x02	; 2
     376:	a9 f0       	breq	.+42     	; 0x3a2 <DIO_GetPin_Value+0x34>
     378:	83 30       	cpi	r24, 0x03	; 3
     37a:	e1 f0       	breq	.+56     	; 0x3b4 <DIO_GetPin_Value+0x46>
     37c:	24 c0       	rjmp	.+72     	; 0x3c6 <DIO_GetPin_Value+0x58>
     37e:	89 b3       	in	r24, 0x19	; 25
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	02 c0       	rjmp	.+4      	; 0x388 <DIO_GetPin_Value+0x1a>
     384:	95 95       	asr	r25
     386:	87 95       	ror	r24
     388:	6a 95       	dec	r22
     38a:	e2 f7       	brpl	.-8      	; 0x384 <DIO_GetPin_Value+0x16>
     38c:	81 70       	andi	r24, 0x01	; 1
     38e:	08 95       	ret
     390:	86 b3       	in	r24, 0x16	; 22
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	02 c0       	rjmp	.+4      	; 0x39a <DIO_GetPin_Value+0x2c>
     396:	95 95       	asr	r25
     398:	87 95       	ror	r24
     39a:	6a 95       	dec	r22
     39c:	e2 f7       	brpl	.-8      	; 0x396 <DIO_GetPin_Value+0x28>
     39e:	81 70       	andi	r24, 0x01	; 1
     3a0:	08 95       	ret
     3a2:	83 b3       	in	r24, 0x13	; 19
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	02 c0       	rjmp	.+4      	; 0x3ac <DIO_GetPin_Value+0x3e>
     3a8:	95 95       	asr	r25
     3aa:	87 95       	ror	r24
     3ac:	6a 95       	dec	r22
     3ae:	e2 f7       	brpl	.-8      	; 0x3a8 <DIO_GetPin_Value+0x3a>
     3b0:	81 70       	andi	r24, 0x01	; 1
     3b2:	08 95       	ret
     3b4:	80 b3       	in	r24, 0x10	; 16
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	02 c0       	rjmp	.+4      	; 0x3be <DIO_GetPin_Value+0x50>
     3ba:	95 95       	asr	r25
     3bc:	87 95       	ror	r24
     3be:	6a 95       	dec	r22
     3c0:	e2 f7       	brpl	.-8      	; 0x3ba <DIO_GetPin_Value+0x4c>
     3c2:	81 70       	andi	r24, 0x01	; 1
     3c4:	08 95       	ret
     3c6:	80 e0       	ldi	r24, 0x00	; 0
     3c8:	08 95       	ret

000003ca <DIO_TogglePin_Value>:
     3ca:	81 30       	cpi	r24, 0x01	; 1
     3cc:	89 f0       	breq	.+34     	; 0x3f0 <DIO_TogglePin_Value+0x26>
     3ce:	28 f0       	brcs	.+10     	; 0x3da <DIO_TogglePin_Value+0x10>
     3d0:	82 30       	cpi	r24, 0x02	; 2
     3d2:	c9 f0       	breq	.+50     	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
     3d4:	83 30       	cpi	r24, 0x03	; 3
     3d6:	11 f1       	breq	.+68     	; 0x41c <__EEPROM_REGION_LENGTH__+0x1c>
     3d8:	08 95       	ret
     3da:	2b b3       	in	r18, 0x1b	; 27
     3dc:	81 e0       	ldi	r24, 0x01	; 1
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	02 c0       	rjmp	.+4      	; 0x3e6 <DIO_TogglePin_Value+0x1c>
     3e2:	88 0f       	add	r24, r24
     3e4:	99 1f       	adc	r25, r25
     3e6:	6a 95       	dec	r22
     3e8:	e2 f7       	brpl	.-8      	; 0x3e2 <DIO_TogglePin_Value+0x18>
     3ea:	82 27       	eor	r24, r18
     3ec:	8b bb       	out	0x1b, r24	; 27
     3ee:	08 95       	ret
     3f0:	28 b3       	in	r18, 0x18	; 24
     3f2:	81 e0       	ldi	r24, 0x01	; 1
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	02 c0       	rjmp	.+4      	; 0x3fc <DIO_TogglePin_Value+0x32>
     3f8:	88 0f       	add	r24, r24
     3fa:	99 1f       	adc	r25, r25
     3fc:	6a 95       	dec	r22
     3fe:	e2 f7       	brpl	.-8      	; 0x3f8 <DIO_TogglePin_Value+0x2e>
     400:	82 27       	eor	r24, r18
     402:	88 bb       	out	0x18, r24	; 24
     404:	08 95       	ret
     406:	25 b3       	in	r18, 0x15	; 21
     408:	81 e0       	ldi	r24, 0x01	; 1
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	02 c0       	rjmp	.+4      	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>
     40e:	88 0f       	add	r24, r24
     410:	99 1f       	adc	r25, r25
     412:	6a 95       	dec	r22
     414:	e2 f7       	brpl	.-8      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
     416:	82 27       	eor	r24, r18
     418:	85 bb       	out	0x15, r24	; 21
     41a:	08 95       	ret
     41c:	22 b3       	in	r18, 0x12	; 18
     41e:	81 e0       	ldi	r24, 0x01	; 1
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	02 c0       	rjmp	.+4      	; 0x428 <__EEPROM_REGION_LENGTH__+0x28>
     424:	88 0f       	add	r24, r24
     426:	99 1f       	adc	r25, r25
     428:	6a 95       	dec	r22
     42a:	e2 f7       	brpl	.-8      	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
     42c:	82 27       	eor	r24, r18
     42e:	82 bb       	out	0x12, r24	; 18
     430:	08 95       	ret

00000432 <EEPROM_WriteByte>:
	
	//Sending stop condition
		I2C_SendStopCond();	
	
	_delay_ms(10);
}
     432:	1f 93       	push	r17
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	16 2f       	mov	r17, r22
     43a:	d4 2f       	mov	r29, r20
     43c:	88 30       	cpi	r24, 0x08	; 8
     43e:	08 f0       	brcs	.+2      	; 0x442 <EEPROM_WriteByte+0x10>
     440:	87 e0       	ldi	r24, 0x07	; 7
     442:	c8 2f       	mov	r28, r24
     444:	c0 65       	ori	r28, 0x50	; 80
     446:	0e 94 bc 07 	call	0xf78	; 0xf78 <I2C_SendStartCond>
     44a:	8c 2f       	mov	r24, r28
     44c:	0e 94 c8 07 	call	0xf90	; 0xf90 <I2C_SendSlaveAdd_WriteOP>
     450:	81 2f       	mov	r24, r17
     452:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <I2C_SendData>
     456:	8d 2f       	mov	r24, r29
     458:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <I2C_SendData>
     45c:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <I2C_SendStopCond>
     460:	8f e3       	ldi	r24, 0x3F	; 63
     462:	9c e9       	ldi	r25, 0x9C	; 156
     464:	01 97       	sbiw	r24, 0x01	; 1
     466:	f1 f7       	brne	.-4      	; 0x464 <EEPROM_WriteByte+0x32>
     468:	00 c0       	rjmp	.+0      	; 0x46a <EEPROM_WriteByte+0x38>
     46a:	00 00       	nop
     46c:	df 91       	pop	r29
     46e:	cf 91       	pop	r28
     470:	1f 91       	pop	r17
     472:	08 95       	ret

00000474 <EEPROM_ReadByte>:


Uint8 EEPROM_ReadByte(Uint8 Device_Page, Uint8 Data_Add)
{
     474:	cf 93       	push	r28
     476:	df 93       	push	r29
     478:	d6 2f       	mov	r29, r22
	Uint8 Data = 0;
	if (Device_Page > 7)
     47a:	88 30       	cpi	r24, 0x08	; 8
     47c:	08 f0       	brcs	.+2      	; 0x480 <EEPROM_ReadByte+0xc>
	Device_Page = 7;
     47e:	87 e0       	ldi	r24, 0x07	; 7
	
	//Device address calculation
		Uint8 Device_Add = 0X50 | Device_Page;
     480:	c8 2f       	mov	r28, r24
     482:	c0 65       	ori	r28, 0x50	; 80
	
	//Sending start condition
		I2C_SendStartCond();
     484:	0e 94 bc 07 	call	0xf78	; 0xf78 <I2C_SendStartCond>
	
	//sending slave address with write operation
		I2C_SendSlaveAdd_WriteOP(Device_Add);
     488:	8c 2f       	mov	r24, r28
     48a:	0e 94 c8 07 	call	0xf90	; 0xf90 <I2C_SendSlaveAdd_WriteOP>
	
	//sending data byte address
		I2C_SendData(Data_Add);
     48e:	8d 2f       	mov	r24, r29
     490:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <I2C_SendData>
	
	//Sending repeated start condition
		I2C_SendRepStartCond();
     494:	0e 94 c2 07 	call	0xf84	; 0xf84 <I2C_SendRepStartCond>
	
	//sending slave address with read operation
		I2C_SendSlaveAdd_ReadOP(Device_Add);	
     498:	8c 2f       	mov	r24, r28
     49a:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <I2C_SendSlaveAdd_ReadOP>
		
	//Receiving the data byte
		Data = I2C_ReadData();
     49e:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <I2C_ReadData>
     4a2:	c8 2f       	mov	r28, r24
	
	//Sending stop condition
		I2C_SendStopCond();	
     4a4:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <I2C_SendStopCond>
	
	return Data;
}
     4a8:	8c 2f       	mov	r24, r28
     4aa:	df 91       	pop	r29
     4ac:	cf 91       	pop	r28
     4ae:	08 95       	ret

000004b0 <__vector_1>:

    /*EXT INT0 Trigger*/
    MCUCR |= EXT_INT2_Trigger;
}

ISR(INT0_vect) {
     4b0:	1f 92       	push	r1
     4b2:	0f 92       	push	r0
     4b4:	0f b6       	in	r0, 0x3f	; 63
     4b6:	0f 92       	push	r0
     4b8:	11 24       	eor	r1, r1
     4ba:	2f 92       	push	r2
     4bc:	3f 92       	push	r3
     4be:	4f 92       	push	r4
     4c0:	5f 92       	push	r5
     4c2:	7f 92       	push	r7
     4c4:	8f 92       	push	r8
     4c6:	9f 92       	push	r9
     4c8:	af 92       	push	r10
     4ca:	bf 92       	push	r11
     4cc:	cf 92       	push	r12
     4ce:	df 92       	push	r13
     4d0:	ef 92       	push	r14
     4d2:	ff 92       	push	r15
     4d4:	0f 93       	push	r16
     4d6:	1f 93       	push	r17
     4d8:	2f 93       	push	r18
     4da:	3f 93       	push	r19
     4dc:	4f 93       	push	r20
     4de:	5f 93       	push	r21
     4e0:	6f 93       	push	r22
     4e2:	7f 93       	push	r23
     4e4:	8f 93       	push	r24
     4e6:	9f 93       	push	r25
     4e8:	af 93       	push	r26
     4ea:	bf 93       	push	r27
     4ec:	ef 93       	push	r30
     4ee:	ff 93       	push	r31
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	cd b7       	in	r28, 0x3d	; 61
     4f6:	de b7       	in	r29, 0x3e	; 62
     4f8:	28 97       	sbiw	r28, 0x08	; 8
     4fa:	de bf       	out	0x3e, r29	; 62
     4fc:	cd bf       	out	0x3d, r28	; 61
    // Write the first external interrupt handler here
	
	  /*----------------->login to KEYPAD-LCD system <-----------------*/
    if (!eme_check) {
     4fe:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
     502:	90 91 30 07 	lds	r25, 0x0730	; 0x800730 <eme_check+0x1>
     506:	89 2b       	or	r24, r25
     508:	09 f0       	breq	.+2      	; 0x50c <__vector_1+0x5c>
     50a:	d2 c1       	rjmp	.+932    	; 0x8b0 <__stack+0x51>
        Uint8 k = 0;
        Uint8 i = 0;
        Uint8 user[2][4];
        LCD_Clear();
     50c:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
        UART_TX_Str("\r\n");
     510:	8d e0       	ldi	r24, 0x0D	; 13
     512:	92 e0       	ldi	r25, 0x02	; 2
     514:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("The system is busy!\r\n");
     518:	81 e7       	ldi	r24, 0x71	; 113
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        Servoo_Motor(97); //Closing the door in case the system stuck here for a while 
     520:	61 e6       	ldi	r22, 0x61	; 97
     522:	70 e0       	ldi	r23, 0x00	; 0
     524:	80 e0       	ldi	r24, 0x00	; 0
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	0e 94 ba 0a 	call	0x1574	; 0x1574 <Servoo_Motor>
		
      /*----------------->Reciving username & password from KEYPAD <-----------------*/
        for (Uint8 j = 0; j < 3; j++) {
     52c:	71 2c       	mov	r7, r1
ISR(INT0_vect) {
    // Write the first external interrupt handler here
	
	  /*----------------->login to KEYPAD-LCD system <-----------------*/
    if (!eme_check) {
        Uint8 k = 0;
     52e:	00 e0       	ldi	r16, 0x00	; 0
        UART_TX_Str("\r\n");
        UART_TX_Str("The system is busy!\r\n");
        Servoo_Motor(97); //Closing the door in case the system stuck here for a while 
		
      /*----------------->Reciving username & password from KEYPAD <-----------------*/
        for (Uint8 j = 0; j < 3; j++) {
     530:	aa c1       	rjmp	.+852    	; 0x886 <__stack+0x27>
            i = 0;
            LCD_Write_String("user name:");
     532:	87 e8       	ldi	r24, 0x87	; 135
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
        UART_TX_Str("The system is busy!\r\n");
        Servoo_Motor(97); //Closing the door in case the system stuck here for a while 
		
      /*----------------->Reciving username & password from KEYPAD <-----------------*/
        for (Uint8 j = 0; j < 3; j++) {
            i = 0;
     53a:	10 e0       	ldi	r17, 0x00	; 0
            LCD_Write_String("user name:");
            while (i < 4) {
     53c:	15 c0       	rjmp	.+42     	; 0x568 <__vector_1+0xb8>
                button = Keypad_GetValue();
     53e:	0e 94 f8 07 	call	0xff0	; 0xff0 <Keypad_GetValue>
     542:	80 93 2e 07 	sts	0x072E, r24	; 0x80072e <__data_end>

                while (button != NULL_KEYPAD) {
     546:	0c c0       	rjmp	.+24     	; 0x560 <__vector_1+0xb0>
                    user[0][i] = button;
     548:	e1 e0       	ldi	r30, 0x01	; 1
     54a:	f0 e0       	ldi	r31, 0x00	; 0
     54c:	ec 0f       	add	r30, r28
     54e:	fd 1f       	adc	r31, r29
     550:	e1 0f       	add	r30, r17
     552:	f1 1d       	adc	r31, r1
     554:	80 83       	st	Z, r24
                    LCD_Write_Char(button);
     556:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <LCD_Write_Char>
                    button = NULL_KEYPAD;
     55a:	10 92 2e 07 	sts	0x072E, r1	; 0x80072e <__data_end>
                    i++;
     55e:	1f 5f       	subi	r17, 0xFF	; 255
            i = 0;
            LCD_Write_String("user name:");
            while (i < 4) {
                button = Keypad_GetValue();

                while (button != NULL_KEYPAD) {
     560:	80 91 2e 07 	lds	r24, 0x072E	; 0x80072e <__data_end>
     564:	81 11       	cpse	r24, r1
     566:	f0 cf       	rjmp	.-32     	; 0x548 <__vector_1+0x98>
		
      /*----------------->Reciving username & password from KEYPAD <-----------------*/
        for (Uint8 j = 0; j < 3; j++) {
            i = 0;
            LCD_Write_String("user name:");
            while (i < 4) {
     568:	14 30       	cpi	r17, 0x04	; 4
     56a:	48 f3       	brcs	.-46     	; 0x53e <__vector_1+0x8e>
                    button = NULL_KEYPAD;
                    i++;
                }
            }
            i = 0;
            LCD_Goto(1, 0);
     56c:	60 e0       	ldi	r22, 0x00	; 0
     56e:	81 e0       	ldi	r24, 0x01	; 1
     570:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
            LCD_Write_String("password:");
     574:	82 e9       	ldi	r24, 0x92	; 146
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                    LCD_Write_Char(button);
                    button = NULL_KEYPAD;
                    i++;
                }
            }
            i = 0;
     57c:	10 e0       	ldi	r17, 0x00	; 0
            LCD_Goto(1, 0);
            LCD_Write_String("password:");
            while (i < 4) {
     57e:	16 c0       	rjmp	.+44     	; 0x5ac <__vector_1+0xfc>
                button = Keypad_GetValue();
     580:	0e 94 f8 07 	call	0xff0	; 0xff0 <Keypad_GetValue>
     584:	80 93 2e 07 	sts	0x072E, r24	; 0x80072e <__data_end>
                while (button != NULL_KEYPAD) {
     588:	0d c0       	rjmp	.+26     	; 0x5a4 <__vector_1+0xf4>
                    user[1][i] = button;
     58a:	e5 e0       	ldi	r30, 0x05	; 5
     58c:	f0 e0       	ldi	r31, 0x00	; 0
     58e:	ec 0f       	add	r30, r28
     590:	fd 1f       	adc	r31, r29
     592:	e1 0f       	add	r30, r17
     594:	f1 1d       	adc	r31, r1
     596:	80 83       	st	Z, r24
                    LCD_Write_Char('*');
     598:	8a e2       	ldi	r24, 0x2A	; 42
     59a:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <LCD_Write_Char>
                    button = NULL_KEYPAD;
     59e:	10 92 2e 07 	sts	0x072E, r1	; 0x80072e <__data_end>
                    i++;
     5a2:	1f 5f       	subi	r17, 0xFF	; 255
            i = 0;
            LCD_Goto(1, 0);
            LCD_Write_String("password:");
            while (i < 4) {
                button = Keypad_GetValue();
                while (button != NULL_KEYPAD) {
     5a4:	80 91 2e 07 	lds	r24, 0x072E	; 0x80072e <__data_end>
     5a8:	81 11       	cpse	r24, r1
     5aa:	ef cf       	rjmp	.-34     	; 0x58a <__vector_1+0xda>
                }
            }
            i = 0;
            LCD_Goto(1, 0);
            LCD_Write_String("password:");
            while (i < 4) {
     5ac:	14 30       	cpi	r17, 0x04	; 4
     5ae:	40 f3       	brcs	.-48     	; 0x580 <__vector_1+0xd0>
                    i++;
                }
            }
			
     /*----------------->Option for showing the passward  <-----------------*/
            LCD_Clear();
     5b0:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
            LCD_Write_String("Show password *");
     5b4:	8c e9       	ldi	r24, 0x9C	; 156
     5b6:	90 e0       	ldi	r25, 0x00	; 0
     5b8:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
            LCD_Goto(1, 0);
     5bc:	60 e0       	ldi	r22, 0x00	; 0
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
            LCD_Write_String("other press #");
     5c4:	8c ea       	ldi	r24, 0xAC	; 172
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>

            while (!(button == '*' || button == '#'))
     5cc:	04 c0       	rjmp	.+8      	; 0x5d6 <__vector_1+0x126>
                button = Keypad_GetValue();
     5ce:	0e 94 f8 07 	call	0xff0	; 0xff0 <Keypad_GetValue>
     5d2:	80 93 2e 07 	sts	0x072E, r24	; 0x80072e <__data_end>
            LCD_Clear();
            LCD_Write_String("Show password *");
            LCD_Goto(1, 0);
            LCD_Write_String("other press #");

            while (!(button == '*' || button == '#'))
     5d6:	80 91 2e 07 	lds	r24, 0x072E	; 0x80072e <__data_end>
     5da:	8a 32       	cpi	r24, 0x2A	; 42
     5dc:	11 f0       	breq	.+4      	; 0x5e2 <__vector_1+0x132>
     5de:	83 32       	cpi	r24, 0x23	; 35
     5e0:	b1 f7       	brne	.-20     	; 0x5ce <__vector_1+0x11e>
                button = Keypad_GetValue();

            if (button == '*') {
     5e2:	8a 32       	cpi	r24, 0x2A	; 42
     5e4:	e9 f4       	brne	.+58     	; 0x620 <__vector_1+0x170>
                LCD_Clear();
     5e6:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                LCD_Write_String("password:");
     5ea:	82 e9       	ldi	r24, 0x92	; 146
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                i = 0;
     5f2:	10 e0       	ldi	r17, 0x00	; 0
                while (i < 4) {
     5f4:	0a c0       	rjmp	.+20     	; 0x60a <__vector_1+0x15a>
                    LCD_Write_Char(user[1][i]);
     5f6:	e5 e0       	ldi	r30, 0x05	; 5
     5f8:	f0 e0       	ldi	r31, 0x00	; 0
     5fa:	ec 0f       	add	r30, r28
     5fc:	fd 1f       	adc	r31, r29
     5fe:	e1 0f       	add	r30, r17
     600:	f1 1d       	adc	r31, r1
     602:	80 81       	ld	r24, Z
     604:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <LCD_Write_Char>
                    i++;
     608:	1f 5f       	subi	r17, 0xFF	; 255

            if (button == '*') {
                LCD_Clear();
                LCD_Write_String("password:");
                i = 0;
                while (i < 4) {
     60a:	14 30       	cpi	r17, 0x04	; 4
     60c:	a0 f3       	brcs	.-24     	; 0x5f6 <__vector_1+0x146>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     60e:	2f ef       	ldi	r18, 0xFF	; 255
     610:	89 e6       	ldi	r24, 0x69	; 105
     612:	98 e1       	ldi	r25, 0x18	; 24
     614:	21 50       	subi	r18, 0x01	; 1
     616:	80 40       	sbci	r24, 0x00	; 0
     618:	90 40       	sbci	r25, 0x00	; 0
     61a:	e1 f7       	brne	.-8      	; 0x614 <__vector_1+0x164>
     61c:	00 c0       	rjmp	.+0      	; 0x61e <__vector_1+0x16e>
     61e:	00 00       	nop
                    i++;
                }
                _delay_ms(500);

            }
            LCD_Clear();
     620:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>


            for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
     624:	10 e0       	ldi	r17, 0x00	; 0
     626:	04 c1       	rjmp	.+520    	; 0x830 <__DATA_REGION_LENGTH__+0x30>
                /*----------------->Username Check<------------------*/

                if (user[0][0] == EEPROM_ReadByte(0, Check_Counter + 1) && user[0][1] == EEPROM_ReadByte(0, Check_Counter + 2) && user[0][2] == EEPROM_ReadByte(0, Check_Counter + 3) && user[0][3] == EEPROM_ReadByte(0, Check_Counter + 4))
     628:	a9 80       	ldd	r10, Y+1	; 0x01
     62a:	b1 2c       	mov	r11, r1
     62c:	e1 2e       	mov	r14, r17
     62e:	f1 2c       	mov	r15, r1
     630:	67 01       	movw	r12, r14
     632:	2f ef       	ldi	r18, 0xFF	; 255
     634:	c2 1a       	sub	r12, r18
     636:	d2 0a       	sbc	r13, r18
     638:	b6 01       	movw	r22, r12
     63a:	80 e0       	ldi	r24, 0x00	; 0
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
     642:	a8 16       	cp	r10, r24
     644:	b9 06       	cpc	r11, r25
     646:	09 f0       	breq	.+2      	; 0x64a <__vector_1+0x19a>
     648:	f2 c0       	rjmp	.+484    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
     64a:	aa 80       	ldd	r10, Y+2	; 0x02
     64c:	b1 2c       	mov	r11, r1
     64e:	47 01       	movw	r8, r14
     650:	82 e0       	ldi	r24, 0x02	; 2
     652:	88 0e       	add	r8, r24
     654:	91 1c       	adc	r9, r1
     656:	b4 01       	movw	r22, r8
     658:	80 e0       	ldi	r24, 0x00	; 0
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
     660:	a8 16       	cp	r10, r24
     662:	b9 06       	cpc	r11, r25
     664:	09 f0       	breq	.+2      	; 0x668 <__vector_1+0x1b8>
     666:	e3 c0       	rjmp	.+454    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
     668:	ab 80       	ldd	r10, Y+3	; 0x03
     66a:	b1 2c       	mov	r11, r1
     66c:	17 01       	movw	r2, r14
     66e:	93 e0       	ldi	r25, 0x03	; 3
     670:	29 0e       	add	r2, r25
     672:	31 1c       	adc	r3, r1
     674:	b1 01       	movw	r22, r2
     676:	80 e0       	ldi	r24, 0x00	; 0
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
     67e:	a8 16       	cp	r10, r24
     680:	b9 06       	cpc	r11, r25
     682:	09 f0       	breq	.+2      	; 0x686 <__vector_1+0x1d6>
     684:	d4 c0       	rjmp	.+424    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
     686:	4c 80       	ldd	r4, Y+4	; 0x04
     688:	51 2c       	mov	r5, r1
     68a:	57 01       	movw	r10, r14
     68c:	24 e0       	ldi	r18, 0x04	; 4
     68e:	a2 0e       	add	r10, r18
     690:	b1 1c       	adc	r11, r1
     692:	b5 01       	movw	r22, r10
     694:	80 e0       	ldi	r24, 0x00	; 0
     696:	90 e0       	ldi	r25, 0x00	; 0
     698:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
     69c:	48 16       	cp	r4, r24
     69e:	59 06       	cpc	r5, r25
     6a0:	09 f0       	breq	.+2      	; 0x6a4 <__vector_1+0x1f4>
     6a2:	c5 c0       	rjmp	.+394    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>

                {
                    /*----------------->Password Check<------------------*/

                    if (user[1][0] == EEPROM_ReadByte(1, Check_Counter + 1) && user[1][1] == EEPROM_ReadByte(1, Check_Counter + 2) && user[1][2] == EEPROM_ReadByte(1, Check_Counter + 3) && user[1][3] == EEPROM_ReadByte(1, Check_Counter + 4))
     6a4:	ed 80       	ldd	r14, Y+5	; 0x05
     6a6:	f1 2c       	mov	r15, r1
     6a8:	b6 01       	movw	r22, r12
     6aa:	81 e0       	ldi	r24, 0x01	; 1
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
     6b2:	e8 16       	cp	r14, r24
     6b4:	f9 06       	cpc	r15, r25
     6b6:	09 f0       	breq	.+2      	; 0x6ba <__vector_1+0x20a>
     6b8:	ba c0       	rjmp	.+372    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
     6ba:	ee 80       	ldd	r14, Y+6	; 0x06
     6bc:	f1 2c       	mov	r15, r1
     6be:	b4 01       	movw	r22, r8
     6c0:	81 e0       	ldi	r24, 0x01	; 1
     6c2:	90 e0       	ldi	r25, 0x00	; 0
     6c4:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
     6c8:	e8 16       	cp	r14, r24
     6ca:	f9 06       	cpc	r15, r25
     6cc:	09 f0       	breq	.+2      	; 0x6d0 <__vector_1+0x220>
     6ce:	af c0       	rjmp	.+350    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
     6d0:	ef 80       	ldd	r14, Y+7	; 0x07
     6d2:	f1 2c       	mov	r15, r1
     6d4:	b1 01       	movw	r22, r2
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	90 e0       	ldi	r25, 0x00	; 0
     6da:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
     6de:	e8 16       	cp	r14, r24
     6e0:	f9 06       	cpc	r15, r25
     6e2:	09 f0       	breq	.+2      	; 0x6e6 <__vector_1+0x236>
     6e4:	a4 c0       	rjmp	.+328    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
     6e6:	e8 84       	ldd	r14, Y+8	; 0x08
     6e8:	f1 2c       	mov	r15, r1
     6ea:	b5 01       	movw	r22, r10
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
     6f4:	e8 16       	cp	r14, r24
     6f6:	f9 06       	cpc	r15, r25
     6f8:	09 f0       	breq	.+2      	; 0x6fc <__vector_1+0x24c>
     6fa:	99 c0       	rjmp	.+306    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
                        j = 4;
                        k = 4;
						
					
              /*----------------->Check if there is admin uses the system to ask for accessing the KEYPAD-LCD system <-----------------*/
                        if (SYS_Check == 0 || SYS_Check == 2) //Case of there is no one controlling yet via PC/Mobile or there is a user
     6fc:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <SYS_Check>
     700:	88 23       	and	r24, r24
     702:	11 f0       	breq	.+4      	; 0x708 <__vector_1+0x258>
     704:	82 30       	cpi	r24, 0x02	; 2
     706:	29 f5       	brne	.+74     	; 0x752 <__vector_1+0x2a2>
						 {
                            eme_check = 1; //Changing it to 1 to use the emergency case function (controlling system with KEYPAD-LCD)
     708:	81 e0       	ldi	r24, 0x01	; 1
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	90 93 30 07 	sts	0x0730, r25	; 0x800730 <eme_check+0x1>
     710:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <eme_check>
							LCD_Write_String("User verified");
     714:	8a eb       	ldi	r24, 0xBA	; 186
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
							LCD_Goto(1, 0);
     71c:	60 e0       	ldi	r22, 0x00	; 0
     71e:	81 e0       	ldi	r24, 0x01	; 1
     720:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
							LCD_Write_String("Welcome!");
     724:	88 ec       	ldi	r24, 0xC8	; 200
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
							Check_Counter = KP_Counter + 1; //To exit the for loop of user-pass check
     72c:	10 91 51 07 	lds	r17, 0x0751	; 0x800751 <KP_Counter>
     730:	1f 5f       	subi	r17, 0xFF	; 255
     732:	8f ef       	ldi	r24, 0xFF	; 255
     734:	99 e6       	ldi	r25, 0x69	; 105
     736:	28 e1       	ldi	r18, 0x18	; 24
     738:	81 50       	subi	r24, 0x01	; 1
     73a:	90 40       	sbci	r25, 0x00	; 0
     73c:	20 40       	sbci	r18, 0x00	; 0
     73e:	e1 f7       	brne	.-8      	; 0x738 <__vector_1+0x288>
     740:	00 c0       	rjmp	.+0      	; 0x742 <__vector_1+0x292>
     742:	00 00       	nop
							_delay_ms(500); 
							LCD_Clear();
     744:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>

                    if (user[1][0] == EEPROM_ReadByte(1, Check_Counter + 1) && user[1][1] == EEPROM_ReadByte(1, Check_Counter + 2) && user[1][2] == EEPROM_ReadByte(1, Check_Counter + 3) && user[1][3] == EEPROM_ReadByte(1, Check_Counter + 4))

                    {
                        /*----------------->right Username & Password<-----------------*/
                        j = 4;
     748:	68 94       	set
     74a:	77 24       	eor	r7, r7
     74c:	72 f8       	bld	r7, 2
                        k = 4;
     74e:	04 e0       	ldi	r16, 0x04	; 4
							LCD_Write_String("User verified");
							LCD_Goto(1, 0);
							LCD_Write_String("Welcome!");
							Check_Counter = KP_Counter + 1; //To exit the for loop of user-pass check
							_delay_ms(500); 
							LCD_Clear();
     750:	6e c0       	rjmp	.+220    	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
                        }
						 else if (SYS_Check == 1) //Case of Admin is controlling 
     752:	81 30       	cpi	r24, 0x01	; 1
     754:	09 f0       	breq	.+2      	; 0x758 <__vector_1+0x2a8>
     756:	67 c0       	rjmp	.+206    	; 0x826 <__DATA_REGION_LENGTH__+0x26>
						  {
							LCD_Clear();
     758:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
							LCD_Write_String("Asking Admin");
     75c:	81 ed       	ldi	r24, 0xD1	; 209
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
     764:	8f ef       	ldi	r24, 0xFF	; 255
     766:	99 e6       	ldi	r25, 0x69	; 105
     768:	28 e1       	ldi	r18, 0x18	; 24
     76a:	81 50       	subi	r24, 0x01	; 1
     76c:	90 40       	sbci	r25, 0x00	; 0
     76e:	20 40       	sbci	r18, 0x00	; 0
     770:	e1 f7       	brne	.-8      	; 0x76a <__vector_1+0x2ba>
     772:	00 c0       	rjmp	.+0      	; 0x774 <__vector_1+0x2c4>
     774:	00 00       	nop
							_delay_ms(500); 
							LCD_Clear();
     776:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
							/*----------------->Asking for acceptance the request or Not <-----------------*/
                            UART_TX_Str("\r\n");
     77a:	8d e0       	ldi	r24, 0x0D	; 13
     77c:	92 e0       	ldi	r25, 0x02	; 2
     77e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("1.Accept user request to control the system\r\n");
     782:	8e ed       	ldi	r24, 0xDE	; 222
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("2.Reject user request to control the system\r\n");
     78a:	8c e0       	ldi	r24, 0x0C	; 12
     78c:	91 e0       	ldi	r25, 0x01	; 1
     78e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("\r\n");
     792:	8d e0       	ldi	r24, 0x0D	; 13
     794:	92 e0       	ldi	r25, 0x02	; 2
     796:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("\r\n");
     79a:	8d e0       	ldi	r24, 0x0D	; 13
     79c:	92 e0       	ldi	r25, 0x02	; 2
     79e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            while (!Get_Bit(UCSRA, 7)); 
     7a2:	5f 9b       	sbis	0x0b, 7	; 11
     7a4:	fe cf       	rjmp	.-4      	; 0x7a2 <__vector_1+0x2f2>
							UART_GetValue = UDR; //Getting response from al Admin 
     7a6:	8c b1       	in	r24, 0x0c	; 12
     7a8:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>
                            UART_TX_Str("\r\n");
     7ac:	8d e0       	ldi	r24, 0x0D	; 13
     7ae:	92 e0       	ldi	r25, 0x02	; 2
     7b0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            if (UART_GetValue == '1') {
     7b4:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART_GetValue>
     7b8:	81 33       	cpi	r24, 0x31	; 49
     7ba:	99 f4       	brne	.+38     	; 0x7e2 <__vector_1+0x332>
                                eme_check = 1; 
     7bc:	81 e0       	ldi	r24, 0x01	; 1
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	90 93 30 07 	sts	0x0730, r25	; 0x800730 <eme_check+0x1>
     7c4:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <eme_check>
								LCD_Write_String("User verified");
     7c8:	8a eb       	ldi	r24, 0xBA	; 186
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
								LCD_Goto(1, 0);
     7d0:	60 e0       	ldi	r22, 0x00	; 0
     7d2:	81 e0       	ldi	r24, 0x01	; 1
     7d4:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
								LCD_Write_String("Welcome!"); 
     7d8:	88 ec       	ldi	r24, 0xC8	; 200
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
     7e0:	0c c0       	rjmp	.+24     	; 0x7fa <__vector_1+0x34a>
                            } else if (UART_GetValue == '2') {
     7e2:	82 33       	cpi	r24, 0x32	; 50
     7e4:	51 f4       	brne	.+20     	; 0x7fa <__vector_1+0x34a>
                                eme_check = 0;
     7e6:	10 92 30 07 	sts	0x0730, r1	; 0x800730 <eme_check+0x1>
     7ea:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <eme_check>
								LCD_Clear();
     7ee:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
								LCD_Write_String("Admin Denied");
     7f2:	8a e3       	ldi	r24, 0x3A	; 58
     7f4:	91 e0       	ldi	r25, 0x01	; 1
     7f6:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                            }
							Check_Counter = KP_Counter + 1;
     7fa:	10 91 51 07 	lds	r17, 0x0751	; 0x800751 <KP_Counter>
     7fe:	1f 5f       	subi	r17, 0xFF	; 255
     800:	8f ef       	ldi	r24, 0xFF	; 255
     802:	99 e6       	ldi	r25, 0x69	; 105
     804:	28 e1       	ldi	r18, 0x18	; 24
     806:	81 50       	subi	r24, 0x01	; 1
     808:	90 40       	sbci	r25, 0x00	; 0
     80a:	20 40       	sbci	r18, 0x00	; 0
     80c:	e1 f7       	brne	.-8      	; 0x806 <__DATA_REGION_LENGTH__+0x6>
     80e:	00 c0       	rjmp	.+0      	; 0x810 <__DATA_REGION_LENGTH__+0x10>
     810:	00 00       	nop
							_delay_ms(500);
							LCD_Clear();
     812:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
							UART_GetValue = 8;
     816:	88 e0       	ldi	r24, 0x08	; 8
     818:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>

                    if (user[1][0] == EEPROM_ReadByte(1, Check_Counter + 1) && user[1][1] == EEPROM_ReadByte(1, Check_Counter + 2) && user[1][2] == EEPROM_ReadByte(1, Check_Counter + 3) && user[1][3] == EEPROM_ReadByte(1, Check_Counter + 4))

                    {
                        /*----------------->right Username & Password<-----------------*/
                        j = 4;
     81c:	68 94       	set
     81e:	77 24       	eor	r7, r7
     820:	72 f8       	bld	r7, 2
                        k = 4;
     822:	04 e0       	ldi	r16, 0x04	; 4
     824:	04 c0       	rjmp	.+8      	; 0x82e <__DATA_REGION_LENGTH__+0x2e>

                    if (user[1][0] == EEPROM_ReadByte(1, Check_Counter + 1) && user[1][1] == EEPROM_ReadByte(1, Check_Counter + 2) && user[1][2] == EEPROM_ReadByte(1, Check_Counter + 3) && user[1][3] == EEPROM_ReadByte(1, Check_Counter + 4))

                    {
                        /*----------------->right Username & Password<-----------------*/
                        j = 4;
     826:	68 94       	set
     828:	77 24       	eor	r7, r7
     82a:	72 f8       	bld	r7, 2
                        k = 4;
     82c:	04 e0       	ldi	r16, 0x04	; 4

            }
            LCD_Clear();


            for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
     82e:	1c 5f       	subi	r17, 0xFC	; 252
     830:	80 91 51 07 	lds	r24, 0x0751	; 0x800751 <KP_Counter>
     834:	81 17       	cp	r24, r17
     836:	08 f0       	brcs	.+2      	; 0x83a <__DATA_REGION_LENGTH__+0x3a>
     838:	f7 ce       	rjmp	.-530    	; 0x628 <__vector_1+0x178>
                    }
                }
            }

            /*----------------->Wrong Username or Password<-----------------*/
            if (k != 4) {
     83a:	04 30       	cpi	r16, 0x04	; 4
     83c:	b9 f0       	breq	.+46     	; 0x86c <__stack+0xd>
                LCD_Write_String("User/Pass Wrong");
     83e:	87 e4       	ldi	r24, 0x47	; 71
     840:	91 e0       	ldi	r25, 0x01	; 1
     842:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                LCD_Goto(1, 0);
     846:	60 e0       	ldi	r22, 0x00	; 0
     848:	81 e0       	ldi	r24, 0x01	; 1
     84a:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
                LCD_Write_String("Try again");
     84e:	87 e5       	ldi	r24, 0x57	; 87
     850:	91 e0       	ldi	r25, 0x01	; 1
     852:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
     856:	8f ef       	ldi	r24, 0xFF	; 255
     858:	99 e6       	ldi	r25, 0x69	; 105
     85a:	28 e1       	ldi	r18, 0x18	; 24
     85c:	81 50       	subi	r24, 0x01	; 1
     85e:	90 40       	sbci	r25, 0x00	; 0
     860:	20 40       	sbci	r18, 0x00	; 0
     862:	e1 f7       	brne	.-8      	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
     864:	00 c0       	rjmp	.+0      	; 0x866 <__stack+0x7>
     866:	00 00       	nop
                _delay_ms(500);
                LCD_Clear();
     868:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
            }
            k++;
     86c:	0f 5f       	subi	r16, 0xFF	; 255
           /*----------------->Firing alarm in the third wrong trial of entering user and password <-----------------*/
            if (k == 3) {
     86e:	03 30       	cpi	r16, 0x03	; 3
     870:	49 f4       	brne	.+18     	; 0x884 <__stack+0x25>
                LCD_Clear();
     872:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                LCD_Write_String("Firing Alarm!");
     876:	81 e6       	ldi	r24, 0x61	; 97
     878:	91 e0       	ldi	r25, 0x01	; 1
     87a:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>

                while (1) {
                    Alarm_Fn();
     87e:	0e 94 86 04 	call	0x90c	; 0x90c <Alarm_Fn>
     882:	fd cf       	rjmp	.-6      	; 0x87e <__stack+0x1f>
        UART_TX_Str("\r\n");
        UART_TX_Str("The system is busy!\r\n");
        Servoo_Motor(97); //Closing the door in case the system stuck here for a while 
		
      /*----------------->Reciving username & password from KEYPAD <-----------------*/
        for (Uint8 j = 0; j < 3; j++) {
     884:	73 94       	inc	r7
     886:	82 e0       	ldi	r24, 0x02	; 2
     888:	87 15       	cp	r24, r7
     88a:	08 f0       	brcs	.+2      	; 0x88e <__stack+0x2f>
     88c:	52 ce       	rjmp	.-860    	; 0x532 <__vector_1+0x82>
                    Alarm_Fn();
                }
            }
        }

        UART_TX_Str("System online!\r\n");
     88e:	8f e6       	ldi	r24, 0x6F	; 111
     890:	91 e0       	ldi	r25, 0x01	; 1
     892:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("Press any key to control the system\r\n");
     896:	80 e8       	ldi	r24, 0x80	; 128
     898:	91 e0       	ldi	r25, 0x01	; 1
     89a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("\r\n");
     89e:	8d e0       	ldi	r24, 0x0D	; 13
     8a0:	92 e0       	ldi	r25, 0x02	; 2
     8a2:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("\r\n");
     8a6:	8d e0       	ldi	r24, 0x0D	; 13
     8a8:	92 e0       	ldi	r25, 0x02	; 2
     8aa:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
     8ae:	06 c0       	rjmp	.+12     	; 0x8bc <__stack+0x5d>
    }
	
	         /*----------------->logout from KEYPAD-LCD system <-----------------*/
	else{
		eme_check=0;
     8b0:	10 92 30 07 	sts	0x0730, r1	; 0x800730 <eme_check+0x1>
     8b4:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <eme_check>
		LCD_Clear();
     8b8:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
	    }
}
     8bc:	28 96       	adiw	r28, 0x08	; 8
     8be:	0f b6       	in	r0, 0x3f	; 63
     8c0:	f8 94       	cli
     8c2:	de bf       	out	0x3e, r29	; 62
     8c4:	0f be       	out	0x3f, r0	; 63
     8c6:	cd bf       	out	0x3d, r28	; 61
     8c8:	df 91       	pop	r29
     8ca:	cf 91       	pop	r28
     8cc:	ff 91       	pop	r31
     8ce:	ef 91       	pop	r30
     8d0:	bf 91       	pop	r27
     8d2:	af 91       	pop	r26
     8d4:	9f 91       	pop	r25
     8d6:	8f 91       	pop	r24
     8d8:	7f 91       	pop	r23
     8da:	6f 91       	pop	r22
     8dc:	5f 91       	pop	r21
     8de:	4f 91       	pop	r20
     8e0:	3f 91       	pop	r19
     8e2:	2f 91       	pop	r18
     8e4:	1f 91       	pop	r17
     8e6:	0f 91       	pop	r16
     8e8:	ff 90       	pop	r15
     8ea:	ef 90       	pop	r14
     8ec:	df 90       	pop	r13
     8ee:	cf 90       	pop	r12
     8f0:	bf 90       	pop	r11
     8f2:	af 90       	pop	r10
     8f4:	9f 90       	pop	r9
     8f6:	8f 90       	pop	r8
     8f8:	7f 90       	pop	r7
     8fa:	5f 90       	pop	r5
     8fc:	4f 90       	pop	r4
     8fe:	3f 90       	pop	r3
     900:	2f 90       	pop	r2
     902:	0f 90       	pop	r0
     904:	0f be       	out	0x3f, r0	; 63
     906:	0f 90       	pop	r0
     908:	1f 90       	pop	r1
     90a:	18 95       	reti

0000090c <Alarm_Fn>:
#include "Functions.h"
#define Delay  60
#include <util/delay.h>
void Alarm_Fn(void){
	
	Buzzer_ON();
     90c:	0e 94 79 00 	call	0xf2	; 0xf2 <Buzzer_ON>
	LED3_ON();
     910:	0e 94 f5 09 	call	0x13ea	; 0x13ea <LED3_ON>
	LED4_ON();
     914:	0e 94 06 0a 	call	0x140c	; 0x140c <LED4_ON>
	
	LED0_ON();
     918:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     91c:	2f ef       	ldi	r18, 0xFF	; 255
     91e:	8d ee       	ldi	r24, 0xED	; 237
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	21 50       	subi	r18, 0x01	; 1
     924:	80 40       	sbci	r24, 0x00	; 0
     926:	90 40       	sbci	r25, 0x00	; 0
     928:	e1 f7       	brne	.-8      	; 0x922 <Alarm_Fn+0x16>
     92a:	00 c0       	rjmp	.+0      	; 0x92c <Alarm_Fn+0x20>
     92c:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     92e:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
     932:	2f ef       	ldi	r18, 0xFF	; 255
     934:	8d ee       	ldi	r24, 0xED	; 237
     936:	92 e0       	ldi	r25, 0x02	; 2
     938:	21 50       	subi	r18, 0x01	; 1
     93a:	80 40       	sbci	r24, 0x00	; 0
     93c:	90 40       	sbci	r25, 0x00	; 0
     93e:	e1 f7       	brne	.-8      	; 0x938 <Alarm_Fn+0x2c>
     940:	00 c0       	rjmp	.+0      	; 0x942 <Alarm_Fn+0x36>
     942:	00 00       	nop
	_delay_ms(Delay);
	LED3_ON();
     944:	0e 94 f5 09 	call	0x13ea	; 0x13ea <LED3_ON>
	
	LED0_ON();
     948:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     94c:	2f ef       	ldi	r18, 0xFF	; 255
     94e:	8d ee       	ldi	r24, 0xED	; 237
     950:	92 e0       	ldi	r25, 0x02	; 2
     952:	21 50       	subi	r18, 0x01	; 1
     954:	80 40       	sbci	r24, 0x00	; 0
     956:	90 40       	sbci	r25, 0x00	; 0
     958:	e1 f7       	brne	.-8      	; 0x952 <Alarm_Fn+0x46>
     95a:	00 c0       	rjmp	.+0      	; 0x95c <Alarm_Fn+0x50>
     95c:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     95e:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
     962:	2f ef       	ldi	r18, 0xFF	; 255
     964:	8d ee       	ldi	r24, 0xED	; 237
     966:	92 e0       	ldi	r25, 0x02	; 2
     968:	21 50       	subi	r18, 0x01	; 1
     96a:	80 40       	sbci	r24, 0x00	; 0
     96c:	90 40       	sbci	r25, 0x00	; 0
     96e:	e1 f7       	brne	.-8      	; 0x968 <Alarm_Fn+0x5c>
     970:	00 c0       	rjmp	.+0      	; 0x972 <Alarm_Fn+0x66>
     972:	00 00       	nop
	_delay_ms(Delay);
	
	
	LED2_ON();
     974:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     978:	2f ef       	ldi	r18, 0xFF	; 255
     97a:	8d ee       	ldi	r24, 0xED	; 237
     97c:	92 e0       	ldi	r25, 0x02	; 2
     97e:	21 50       	subi	r18, 0x01	; 1
     980:	80 40       	sbci	r24, 0x00	; 0
     982:	90 40       	sbci	r25, 0x00	; 0
     984:	e1 f7       	brne	.-8      	; 0x97e <Alarm_Fn+0x72>
     986:	00 c0       	rjmp	.+0      	; 0x988 <Alarm_Fn+0x7c>
     988:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     98a:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     98e:	2f ef       	ldi	r18, 0xFF	; 255
     990:	8d ee       	ldi	r24, 0xED	; 237
     992:	92 e0       	ldi	r25, 0x02	; 2
     994:	21 50       	subi	r18, 0x01	; 1
     996:	80 40       	sbci	r24, 0x00	; 0
     998:	90 40       	sbci	r25, 0x00	; 0
     99a:	e1 f7       	brne	.-8      	; 0x994 <Alarm_Fn+0x88>
     99c:	00 c0       	rjmp	.+0      	; 0x99e <Alarm_Fn+0x92>
     99e:	00 00       	nop
	_delay_ms(Delay);
	
	
	LED2_ON();
     9a0:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     9a4:	2f ef       	ldi	r18, 0xFF	; 255
     9a6:	8d ee       	ldi	r24, 0xED	; 237
     9a8:	92 e0       	ldi	r25, 0x02	; 2
     9aa:	21 50       	subi	r18, 0x01	; 1
     9ac:	80 40       	sbci	r24, 0x00	; 0
     9ae:	90 40       	sbci	r25, 0x00	; 0
     9b0:	e1 f7       	brne	.-8      	; 0x9aa <Alarm_Fn+0x9e>
     9b2:	00 c0       	rjmp	.+0      	; 0x9b4 <Alarm_Fn+0xa8>
     9b4:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     9b6:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     9ba:	2f ef       	ldi	r18, 0xFF	; 255
     9bc:	8d ee       	ldi	r24, 0xED	; 237
     9be:	92 e0       	ldi	r25, 0x02	; 2
     9c0:	21 50       	subi	r18, 0x01	; 1
     9c2:	80 40       	sbci	r24, 0x00	; 0
     9c4:	90 40       	sbci	r25, 0x00	; 0
     9c6:	e1 f7       	brne	.-8      	; 0x9c0 <Alarm_Fn+0xb4>
     9c8:	00 c0       	rjmp	.+0      	; 0x9ca <Alarm_Fn+0xbe>
     9ca:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     9cc:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
	LED2_ON();
     9d0:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     9d4:	2f ef       	ldi	r18, 0xFF	; 255
     9d6:	8d ee       	ldi	r24, 0xED	; 237
     9d8:	92 e0       	ldi	r25, 0x02	; 2
     9da:	21 50       	subi	r18, 0x01	; 1
     9dc:	80 40       	sbci	r24, 0x00	; 0
     9de:	90 40       	sbci	r25, 0x00	; 0
     9e0:	e1 f7       	brne	.-8      	; 0x9da <Alarm_Fn+0xce>
     9e2:	00 c0       	rjmp	.+0      	; 0x9e4 <Alarm_Fn+0xd8>
     9e4:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
     9e6:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_OFF();
     9ea:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     9ee:	2f ef       	ldi	r18, 0xFF	; 255
     9f0:	8d ee       	ldi	r24, 0xED	; 237
     9f2:	92 e0       	ldi	r25, 0x02	; 2
     9f4:	21 50       	subi	r18, 0x01	; 1
     9f6:	80 40       	sbci	r24, 0x00	; 0
     9f8:	90 40       	sbci	r25, 0x00	; 0
     9fa:	e1 f7       	brne	.-8      	; 0x9f4 <Alarm_Fn+0xe8>
     9fc:	00 c0       	rjmp	.+0      	; 0x9fe <Alarm_Fn+0xf2>
     9fe:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
     a00:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_OFF();
     a04:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     a08:	2f ef       	ldi	r18, 0xFF	; 255
     a0a:	8d ee       	ldi	r24, 0xED	; 237
     a0c:	92 e0       	ldi	r25, 0x02	; 2
     a0e:	21 50       	subi	r18, 0x01	; 1
     a10:	80 40       	sbci	r24, 0x00	; 0
     a12:	90 40       	sbci	r25, 0x00	; 0
     a14:	e1 f7       	brne	.-8      	; 0xa0e <Alarm_Fn+0x102>
     a16:	00 c0       	rjmp	.+0      	; 0xa18 <Alarm_Fn+0x10c>
     a18:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     a1a:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
	LED2_ON();
     a1e:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     a22:	2f ef       	ldi	r18, 0xFF	; 255
     a24:	8d ee       	ldi	r24, 0xED	; 237
     a26:	92 e0       	ldi	r25, 0x02	; 2
     a28:	21 50       	subi	r18, 0x01	; 1
     a2a:	80 40       	sbci	r24, 0x00	; 0
     a2c:	90 40       	sbci	r25, 0x00	; 0
     a2e:	e1 f7       	brne	.-8      	; 0xa28 <Alarm_Fn+0x11c>
     a30:	00 c0       	rjmp	.+0      	; 0xa32 <Alarm_Fn+0x126>
     a32:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
     a34:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_OFF();
     a38:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     a3c:	2f ef       	ldi	r18, 0xFF	; 255
     a3e:	8d ee       	ldi	r24, 0xED	; 237
     a40:	92 e0       	ldi	r25, 0x02	; 2
     a42:	21 50       	subi	r18, 0x01	; 1
     a44:	80 40       	sbci	r24, 0x00	; 0
     a46:	90 40       	sbci	r25, 0x00	; 0
     a48:	e1 f7       	brne	.-8      	; 0xa42 <Alarm_Fn+0x136>
     a4a:	00 c0       	rjmp	.+0      	; 0xa4c <Alarm_Fn+0x140>
     a4c:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     a4e:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     a52:	2f ef       	ldi	r18, 0xFF	; 255
     a54:	8d ee       	ldi	r24, 0xED	; 237
     a56:	92 e0       	ldi	r25, 0x02	; 2
     a58:	21 50       	subi	r18, 0x01	; 1
     a5a:	80 40       	sbci	r24, 0x00	; 0
     a5c:	90 40       	sbci	r25, 0x00	; 0
     a5e:	e1 f7       	brne	.-8      	; 0xa58 <Alarm_Fn+0x14c>
     a60:	00 c0       	rjmp	.+0      	; 0xa62 <Alarm_Fn+0x156>
     a62:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     a64:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_ON();
     a68:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     a6c:	2f ef       	ldi	r18, 0xFF	; 255
     a6e:	8d ee       	ldi	r24, 0xED	; 237
     a70:	92 e0       	ldi	r25, 0x02	; 2
     a72:	21 50       	subi	r18, 0x01	; 1
     a74:	80 40       	sbci	r24, 0x00	; 0
     a76:	90 40       	sbci	r25, 0x00	; 0
     a78:	e1 f7       	brne	.-8      	; 0xa72 <Alarm_Fn+0x166>
     a7a:	00 c0       	rjmp	.+0      	; 0xa7c <Alarm_Fn+0x170>
     a7c:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     a7e:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     a82:	2f ef       	ldi	r18, 0xFF	; 255
     a84:	8d ee       	ldi	r24, 0xED	; 237
     a86:	92 e0       	ldi	r25, 0x02	; 2
     a88:	21 50       	subi	r18, 0x01	; 1
     a8a:	80 40       	sbci	r24, 0x00	; 0
     a8c:	90 40       	sbci	r25, 0x00	; 0
     a8e:	e1 f7       	brne	.-8      	; 0xa88 <Alarm_Fn+0x17c>
     a90:	00 c0       	rjmp	.+0      	; 0xa92 <Alarm_Fn+0x186>
     a92:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     a94:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     a98:	2f ef       	ldi	r18, 0xFF	; 255
     a9a:	8d ee       	ldi	r24, 0xED	; 237
     a9c:	92 e0       	ldi	r25, 0x02	; 2
     a9e:	21 50       	subi	r18, 0x01	; 1
     aa0:	80 40       	sbci	r24, 0x00	; 0
     aa2:	90 40       	sbci	r25, 0x00	; 0
     aa4:	e1 f7       	brne	.-8      	; 0xa9e <Alarm_Fn+0x192>
     aa6:	00 c0       	rjmp	.+0      	; 0xaa8 <Alarm_Fn+0x19c>
     aa8:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     aaa:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_ON();
     aae:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     ab2:	2f ef       	ldi	r18, 0xFF	; 255
     ab4:	8d ee       	ldi	r24, 0xED	; 237
     ab6:	92 e0       	ldi	r25, 0x02	; 2
     ab8:	21 50       	subi	r18, 0x01	; 1
     aba:	80 40       	sbci	r24, 0x00	; 0
     abc:	90 40       	sbci	r25, 0x00	; 0
     abe:	e1 f7       	brne	.-8      	; 0xab8 <Alarm_Fn+0x1ac>
     ac0:	00 c0       	rjmp	.+0      	; 0xac2 <Alarm_Fn+0x1b6>
     ac2:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     ac4:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     ac8:	2f ef       	ldi	r18, 0xFF	; 255
     aca:	8d ee       	ldi	r24, 0xED	; 237
     acc:	92 e0       	ldi	r25, 0x02	; 2
     ace:	21 50       	subi	r18, 0x01	; 1
     ad0:	80 40       	sbci	r24, 0x00	; 0
     ad2:	90 40       	sbci	r25, 0x00	; 0
     ad4:	e1 f7       	brne	.-8      	; 0xace <Alarm_Fn+0x1c2>
     ad6:	00 c0       	rjmp	.+0      	; 0xad8 <Alarm_Fn+0x1cc>
     ad8:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     ada:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     ade:	2f ef       	ldi	r18, 0xFF	; 255
     ae0:	8d ee       	ldi	r24, 0xED	; 237
     ae2:	92 e0       	ldi	r25, 0x02	; 2
     ae4:	21 50       	subi	r18, 0x01	; 1
     ae6:	80 40       	sbci	r24, 0x00	; 0
     ae8:	90 40       	sbci	r25, 0x00	; 0
     aea:	e1 f7       	brne	.-8      	; 0xae4 <Alarm_Fn+0x1d8>
     aec:	00 c0       	rjmp	.+0      	; 0xaee <Alarm_Fn+0x1e2>
     aee:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     af0:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_ON();
     af4:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     af8:	2f ef       	ldi	r18, 0xFF	; 255
     afa:	8d ee       	ldi	r24, 0xED	; 237
     afc:	92 e0       	ldi	r25, 0x02	; 2
     afe:	21 50       	subi	r18, 0x01	; 1
     b00:	80 40       	sbci	r24, 0x00	; 0
     b02:	90 40       	sbci	r25, 0x00	; 0
     b04:	e1 f7       	brne	.-8      	; 0xafe <Alarm_Fn+0x1f2>
     b06:	00 c0       	rjmp	.+0      	; 0xb08 <Alarm_Fn+0x1fc>
     b08:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     b0a:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     b0e:	2f ef       	ldi	r18, 0xFF	; 255
     b10:	8d ee       	ldi	r24, 0xED	; 237
     b12:	92 e0       	ldi	r25, 0x02	; 2
     b14:	21 50       	subi	r18, 0x01	; 1
     b16:	80 40       	sbci	r24, 0x00	; 0
     b18:	90 40       	sbci	r25, 0x00	; 0
     b1a:	e1 f7       	brne	.-8      	; 0xb14 <Alarm_Fn+0x208>
     b1c:	00 c0       	rjmp	.+0      	; 0xb1e <Alarm_Fn+0x212>
     b1e:	00 00       	nop
	_delay_ms(Delay);
	Buzzer_OFF();
     b20:	0e 94 7f 00 	call	0xfe	; 0xfe <Buzzer_OFF>
	
	LED0_ON();
     b24:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     b28:	2f ef       	ldi	r18, 0xFF	; 255
     b2a:	8d ee       	ldi	r24, 0xED	; 237
     b2c:	92 e0       	ldi	r25, 0x02	; 2
     b2e:	21 50       	subi	r18, 0x01	; 1
     b30:	80 40       	sbci	r24, 0x00	; 0
     b32:	90 40       	sbci	r25, 0x00	; 0
     b34:	e1 f7       	brne	.-8      	; 0xb2e <Alarm_Fn+0x222>
     b36:	00 c0       	rjmp	.+0      	; 0xb38 <Alarm_Fn+0x22c>
     b38:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     b3a:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_ON();
     b3e:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     b42:	2f ef       	ldi	r18, 0xFF	; 255
     b44:	8d ee       	ldi	r24, 0xED	; 237
     b46:	92 e0       	ldi	r25, 0x02	; 2
     b48:	21 50       	subi	r18, 0x01	; 1
     b4a:	80 40       	sbci	r24, 0x00	; 0
     b4c:	90 40       	sbci	r25, 0x00	; 0
     b4e:	e1 f7       	brne	.-8      	; 0xb48 <Alarm_Fn+0x23c>
     b50:	00 c0       	rjmp	.+0      	; 0xb52 <Alarm_Fn+0x246>
     b52:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     b54:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     b58:	2f ef       	ldi	r18, 0xFF	; 255
     b5a:	8d ee       	ldi	r24, 0xED	; 237
     b5c:	92 e0       	ldi	r25, 0x02	; 2
     b5e:	21 50       	subi	r18, 0x01	; 1
     b60:	80 40       	sbci	r24, 0x00	; 0
     b62:	90 40       	sbci	r25, 0x00	; 0
     b64:	e1 f7       	brne	.-8      	; 0xb5e <Alarm_Fn+0x252>
     b66:	00 c0       	rjmp	.+0      	; 0xb68 <Alarm_Fn+0x25c>
     b68:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     b6a:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     b6e:	2f ef       	ldi	r18, 0xFF	; 255
     b70:	8d ee       	ldi	r24, 0xED	; 237
     b72:	92 e0       	ldi	r25, 0x02	; 2
     b74:	21 50       	subi	r18, 0x01	; 1
     b76:	80 40       	sbci	r24, 0x00	; 0
     b78:	90 40       	sbci	r25, 0x00	; 0
     b7a:	e1 f7       	brne	.-8      	; 0xb74 <Alarm_Fn+0x268>
     b7c:	00 c0       	rjmp	.+0      	; 0xb7e <Alarm_Fn+0x272>
     b7e:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     b80:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
     b84:	2f ef       	ldi	r18, 0xFF	; 255
     b86:	8d ee       	ldi	r24, 0xED	; 237
     b88:	92 e0       	ldi	r25, 0x02	; 2
     b8a:	21 50       	subi	r18, 0x01	; 1
     b8c:	80 40       	sbci	r24, 0x00	; 0
     b8e:	90 40       	sbci	r25, 0x00	; 0
     b90:	e1 f7       	brne	.-8      	; 0xb8a <Alarm_Fn+0x27e>
     b92:	00 c0       	rjmp	.+0      	; 0xb94 <Alarm_Fn+0x288>
     b94:	00 00       	nop
	_delay_ms(Delay);
	
	
	LED2_ON();
     b96:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     b9a:	2f ef       	ldi	r18, 0xFF	; 255
     b9c:	8d ee       	ldi	r24, 0xED	; 237
     b9e:	92 e0       	ldi	r25, 0x02	; 2
     ba0:	21 50       	subi	r18, 0x01	; 1
     ba2:	80 40       	sbci	r24, 0x00	; 0
     ba4:	90 40       	sbci	r25, 0x00	; 0
     ba6:	e1 f7       	brne	.-8      	; 0xba0 <Alarm_Fn+0x294>
     ba8:	00 c0       	rjmp	.+0      	; 0xbaa <Alarm_Fn+0x29e>
     baa:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     bac:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     bb0:	2f ef       	ldi	r18, 0xFF	; 255
     bb2:	8d ee       	ldi	r24, 0xED	; 237
     bb4:	92 e0       	ldi	r25, 0x02	; 2
     bb6:	21 50       	subi	r18, 0x01	; 1
     bb8:	80 40       	sbci	r24, 0x00	; 0
     bba:	90 40       	sbci	r25, 0x00	; 0
     bbc:	e1 f7       	brne	.-8      	; 0xbb6 <Alarm_Fn+0x2aa>
     bbe:	00 c0       	rjmp	.+0      	; 0xbc0 <Alarm_Fn+0x2b4>
     bc0:	00 00       	nop
	_delay_ms(Delay);
	
	LED2_ON();
     bc2:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     bc6:	2f ef       	ldi	r18, 0xFF	; 255
     bc8:	8d ee       	ldi	r24, 0xED	; 237
     bca:	92 e0       	ldi	r25, 0x02	; 2
     bcc:	21 50       	subi	r18, 0x01	; 1
     bce:	80 40       	sbci	r24, 0x00	; 0
     bd0:	90 40       	sbci	r25, 0x00	; 0
     bd2:	e1 f7       	brne	.-8      	; 0xbcc <Alarm_Fn+0x2c0>
     bd4:	00 c0       	rjmp	.+0      	; 0xbd6 <Alarm_Fn+0x2ca>
     bd6:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     bd8:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     bdc:	2f ef       	ldi	r18, 0xFF	; 255
     bde:	8d ee       	ldi	r24, 0xED	; 237
     be0:	92 e0       	ldi	r25, 0x02	; 2
     be2:	21 50       	subi	r18, 0x01	; 1
     be4:	80 40       	sbci	r24, 0x00	; 0
     be6:	90 40       	sbci	r25, 0x00	; 0
     be8:	e1 f7       	brne	.-8      	; 0xbe2 <Alarm_Fn+0x2d6>
     bea:	00 c0       	rjmp	.+0      	; 0xbec <Alarm_Fn+0x2e0>
     bec:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     bee:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
	LED2_ON();
     bf2:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     bf6:	2f ef       	ldi	r18, 0xFF	; 255
     bf8:	8d ee       	ldi	r24, 0xED	; 237
     bfa:	92 e0       	ldi	r25, 0x02	; 2
     bfc:	21 50       	subi	r18, 0x01	; 1
     bfe:	80 40       	sbci	r24, 0x00	; 0
     c00:	90 40       	sbci	r25, 0x00	; 0
     c02:	e1 f7       	brne	.-8      	; 0xbfc <Alarm_Fn+0x2f0>
     c04:	00 c0       	rjmp	.+0      	; 0xc06 <Alarm_Fn+0x2fa>
     c06:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
     c08:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_OFF();
     c0c:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     c10:	2f ef       	ldi	r18, 0xFF	; 255
     c12:	8d ee       	ldi	r24, 0xED	; 237
     c14:	92 e0       	ldi	r25, 0x02	; 2
     c16:	21 50       	subi	r18, 0x01	; 1
     c18:	80 40       	sbci	r24, 0x00	; 0
     c1a:	90 40       	sbci	r25, 0x00	; 0
     c1c:	e1 f7       	brne	.-8      	; 0xc16 <Alarm_Fn+0x30a>
     c1e:	00 c0       	rjmp	.+0      	; 0xc20 <Alarm_Fn+0x314>
     c20:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     c22:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
	LED2_ON();
     c26:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     c2a:	2f ef       	ldi	r18, 0xFF	; 255
     c2c:	8d ee       	ldi	r24, 0xED	; 237
     c2e:	92 e0       	ldi	r25, 0x02	; 2
     c30:	21 50       	subi	r18, 0x01	; 1
     c32:	80 40       	sbci	r24, 0x00	; 0
     c34:	90 40       	sbci	r25, 0x00	; 0
     c36:	e1 f7       	brne	.-8      	; 0xc30 <Alarm_Fn+0x324>
     c38:	00 c0       	rjmp	.+0      	; 0xc3a <Alarm_Fn+0x32e>
     c3a:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
     c3c:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_OFF();
     c40:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     c44:	2f ef       	ldi	r18, 0xFF	; 255
     c46:	8d ee       	ldi	r24, 0xED	; 237
     c48:	92 e0       	ldi	r25, 0x02	; 2
     c4a:	21 50       	subi	r18, 0x01	; 1
     c4c:	80 40       	sbci	r24, 0x00	; 0
     c4e:	90 40       	sbci	r25, 0x00	; 0
     c50:	e1 f7       	brne	.-8      	; 0xc4a <Alarm_Fn+0x33e>
     c52:	00 c0       	rjmp	.+0      	; 0xc54 <Alarm_Fn+0x348>
     c54:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     c56:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     c5a:	2f ef       	ldi	r18, 0xFF	; 255
     c5c:	8d ee       	ldi	r24, 0xED	; 237
     c5e:	92 e0       	ldi	r25, 0x02	; 2
     c60:	21 50       	subi	r18, 0x01	; 1
     c62:	80 40       	sbci	r24, 0x00	; 0
     c64:	90 40       	sbci	r25, 0x00	; 0
     c66:	e1 f7       	brne	.-8      	; 0xc60 <Alarm_Fn+0x354>
     c68:	00 c0       	rjmp	.+0      	; 0xc6a <Alarm_Fn+0x35e>
     c6a:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     c6c:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_ON();
     c70:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     c74:	2f ef       	ldi	r18, 0xFF	; 255
     c76:	8d ee       	ldi	r24, 0xED	; 237
     c78:	92 e0       	ldi	r25, 0x02	; 2
     c7a:	21 50       	subi	r18, 0x01	; 1
     c7c:	80 40       	sbci	r24, 0x00	; 0
     c7e:	90 40       	sbci	r25, 0x00	; 0
     c80:	e1 f7       	brne	.-8      	; 0xc7a <Alarm_Fn+0x36e>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <Alarm_Fn+0x378>
     c84:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     c86:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     c8a:	2f ef       	ldi	r18, 0xFF	; 255
     c8c:	8d ee       	ldi	r24, 0xED	; 237
     c8e:	92 e0       	ldi	r25, 0x02	; 2
     c90:	21 50       	subi	r18, 0x01	; 1
     c92:	80 40       	sbci	r24, 0x00	; 0
     c94:	90 40       	sbci	r25, 0x00	; 0
     c96:	e1 f7       	brne	.-8      	; 0xc90 <Alarm_Fn+0x384>
     c98:	00 c0       	rjmp	.+0      	; 0xc9a <Alarm_Fn+0x38e>
     c9a:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     c9c:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
     ca0:	2f ef       	ldi	r18, 0xFF	; 255
     ca2:	8d ee       	ldi	r24, 0xED	; 237
     ca4:	92 e0       	ldi	r25, 0x02	; 2
     ca6:	21 50       	subi	r18, 0x01	; 1
     ca8:	80 40       	sbci	r24, 0x00	; 0
     caa:	90 40       	sbci	r25, 0x00	; 0
     cac:	e1 f7       	brne	.-8      	; 0xca6 <Alarm_Fn+0x39a>
     cae:	00 c0       	rjmp	.+0      	; 0xcb0 <Alarm_Fn+0x3a4>
     cb0:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     cb2:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	LED2_ON();
     cb6:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
     cba:	2f ef       	ldi	r18, 0xFF	; 255
     cbc:	8d ee       	ldi	r24, 0xED	; 237
     cbe:	92 e0       	ldi	r25, 0x02	; 2
     cc0:	21 50       	subi	r18, 0x01	; 1
     cc2:	80 40       	sbci	r24, 0x00	; 0
     cc4:	90 40       	sbci	r25, 0x00	; 0
     cc6:	e1 f7       	brne	.-8      	; 0xcc0 <Alarm_Fn+0x3b4>
     cc8:	00 c0       	rjmp	.+0      	; 0xcca <Alarm_Fn+0x3be>
     cca:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     ccc:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
     cd0:	2f ef       	ldi	r18, 0xFF	; 255
     cd2:	8d ee       	ldi	r24, 0xED	; 237
     cd4:	92 e0       	ldi	r25, 0x02	; 2
     cd6:	21 50       	subi	r18, 0x01	; 1
     cd8:	80 40       	sbci	r24, 0x00	; 0
     cda:	90 40       	sbci	r25, 0x00	; 0
     cdc:	e1 f7       	brne	.-8      	; 0xcd6 <Alarm_Fn+0x3ca>
     cde:	00 c0       	rjmp	.+0      	; 0xce0 <Alarm_Fn+0x3d4>
     ce0:	00 00       	nop
	_delay_ms(Delay);
	
	
	
	
	LED0_Toggle();
     ce2:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     ce6:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     cea:	2f ef       	ldi	r18, 0xFF	; 255
     cec:	8d ee       	ldi	r24, 0xED	; 237
     cee:	92 e0       	ldi	r25, 0x02	; 2
     cf0:	21 50       	subi	r18, 0x01	; 1
     cf2:	80 40       	sbci	r24, 0x00	; 0
     cf4:	90 40       	sbci	r25, 0x00	; 0
     cf6:	e1 f7       	brne	.-8      	; 0xcf0 <Alarm_Fn+0x3e4>
     cf8:	00 c0       	rjmp	.+0      	; 0xcfa <Alarm_Fn+0x3ee>
     cfa:	00 00       	nop
	_delay_ms(Delay);
	LED0_Toggle();
     cfc:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     d00:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     d04:	2f ef       	ldi	r18, 0xFF	; 255
     d06:	83 ec       	ldi	r24, 0xC3	; 195
     d08:	99 e0       	ldi	r25, 0x09	; 9
     d0a:	21 50       	subi	r18, 0x01	; 1
     d0c:	80 40       	sbci	r24, 0x00	; 0
     d0e:	90 40       	sbci	r25, 0x00	; 0
     d10:	e1 f7       	brne	.-8      	; 0xd0a <Alarm_Fn+0x3fe>
     d12:	00 c0       	rjmp	.+0      	; 0xd14 <Alarm_Fn+0x408>
     d14:	00 00       	nop
	_delay_ms(200);
	LED0_Toggle();
     d16:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     d1a:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     d1e:	2f ef       	ldi	r18, 0xFF	; 255
     d20:	89 e6       	ldi	r24, 0x69	; 105
     d22:	98 e1       	ldi	r25, 0x18	; 24
     d24:	21 50       	subi	r18, 0x01	; 1
     d26:	80 40       	sbci	r24, 0x00	; 0
     d28:	90 40       	sbci	r25, 0x00	; 0
     d2a:	e1 f7       	brne	.-8      	; 0xd24 <Alarm_Fn+0x418>
     d2c:	00 c0       	rjmp	.+0      	; 0xd2e <Alarm_Fn+0x422>
     d2e:	00 00       	nop
	_delay_ms(500);
	LED0_Toggle();
     d30:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     d34:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     d38:	2f ef       	ldi	r18, 0xFF	; 255
     d3a:	81 ee       	ldi	r24, 0xE1	; 225
     d3c:	94 e0       	ldi	r25, 0x04	; 4
     d3e:	21 50       	subi	r18, 0x01	; 1
     d40:	80 40       	sbci	r24, 0x00	; 0
     d42:	90 40       	sbci	r25, 0x00	; 0
     d44:	e1 f7       	brne	.-8      	; 0xd3e <Alarm_Fn+0x432>
     d46:	00 c0       	rjmp	.+0      	; 0xd48 <Alarm_Fn+0x43c>
     d48:	00 00       	nop
	_delay_ms(100);
	LED0_Toggle();
     d4a:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     d4e:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     d52:	2f ef       	ldi	r18, 0xFF	; 255
     d54:	8d ee       	ldi	r24, 0xED	; 237
     d56:	92 e0       	ldi	r25, 0x02	; 2
     d58:	21 50       	subi	r18, 0x01	; 1
     d5a:	80 40       	sbci	r24, 0x00	; 0
     d5c:	90 40       	sbci	r25, 0x00	; 0
     d5e:	e1 f7       	brne	.-8      	; 0xd58 <Alarm_Fn+0x44c>
     d60:	00 c0       	rjmp	.+0      	; 0xd62 <Alarm_Fn+0x456>
     d62:	00 00       	nop
	_delay_ms(Delay);
	LED0_Toggle();
     d64:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     d68:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     d6c:	2f ef       	ldi	r18, 0xFF	; 255
     d6e:	8d ee       	ldi	r24, 0xED	; 237
     d70:	92 e0       	ldi	r25, 0x02	; 2
     d72:	21 50       	subi	r18, 0x01	; 1
     d74:	80 40       	sbci	r24, 0x00	; 0
     d76:	90 40       	sbci	r25, 0x00	; 0
     d78:	e1 f7       	brne	.-8      	; 0xd72 <Alarm_Fn+0x466>
     d7a:	00 c0       	rjmp	.+0      	; 0xd7c <Alarm_Fn+0x470>
     d7c:	00 00       	nop
	_delay_ms(Delay);
	LED0_Toggle();
     d7e:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     d82:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     d86:	8f e3       	ldi	r24, 0x3F	; 63
     d88:	9c e9       	ldi	r25, 0x9C	; 156
     d8a:	01 97       	sbiw	r24, 0x01	; 1
     d8c:	f1 f7       	brne	.-4      	; 0xd8a <Alarm_Fn+0x47e>
     d8e:	00 c0       	rjmp	.+0      	; 0xd90 <Alarm_Fn+0x484>
     d90:	00 00       	nop
	_delay_ms(10);
	LED0_Toggle();
     d92:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     d96:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     d9a:	9f ef       	ldi	r25, 0xFF	; 255
     d9c:	2d ee       	ldi	r18, 0xED	; 237
     d9e:	82 e0       	ldi	r24, 0x02	; 2
     da0:	91 50       	subi	r25, 0x01	; 1
     da2:	20 40       	sbci	r18, 0x00	; 0
     da4:	80 40       	sbci	r24, 0x00	; 0
     da6:	e1 f7       	brne	.-8      	; 0xda0 <Alarm_Fn+0x494>
     da8:	00 c0       	rjmp	.+0      	; 0xdaa <Alarm_Fn+0x49e>
     daa:	00 00       	nop
	_delay_ms(Delay);
	LED0_Toggle();
     dac:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     db0:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     db4:	9f ef       	ldi	r25, 0xFF	; 255
     db6:	2d ee       	ldi	r18, 0xED	; 237
     db8:	82 e0       	ldi	r24, 0x02	; 2
     dba:	91 50       	subi	r25, 0x01	; 1
     dbc:	20 40       	sbci	r18, 0x00	; 0
     dbe:	80 40       	sbci	r24, 0x00	; 0
     dc0:	e1 f7       	brne	.-8      	; 0xdba <Alarm_Fn+0x4ae>
     dc2:	00 c0       	rjmp	.+0      	; 0xdc4 <Alarm_Fn+0x4b8>
     dc4:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_Toggle();
     dc6:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     dca:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     dce:	9f ef       	ldi	r25, 0xFF	; 255
     dd0:	2d ee       	ldi	r18, 0xED	; 237
     dd2:	82 e0       	ldi	r24, 0x02	; 2
     dd4:	91 50       	subi	r25, 0x01	; 1
     dd6:	20 40       	sbci	r18, 0x00	; 0
     dd8:	80 40       	sbci	r24, 0x00	; 0
     dda:	e1 f7       	brne	.-8      	; 0xdd4 <Alarm_Fn+0x4c8>
     ddc:	00 c0       	rjmp	.+0      	; 0xdde <Alarm_Fn+0x4d2>
     dde:	00 00       	nop
	_delay_ms(Delay);
	LED2_Toggle();
     de0:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED2_Toggle>
	LED3_Toggle();
     de4:	0e 94 01 0a 	call	0x1402	; 0x1402 <LED3_Toggle>
	LED0_Toggle();
     de8:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	LED1_Toggle();
     dec:	0e 94 df 09 	call	0x13be	; 0x13be <LED1_Toggle>
	LED4_Toggle();
     df0:	0e 94 12 0a 	call	0x1424	; 0x1424 <LED4_Toggle>
	Buzzer_Toggle();
     df4:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     df8:	9f ef       	ldi	r25, 0xFF	; 255
     dfa:	23 ec       	ldi	r18, 0xC3	; 195
     dfc:	89 e0       	ldi	r24, 0x09	; 9
     dfe:	91 50       	subi	r25, 0x01	; 1
     e00:	20 40       	sbci	r18, 0x00	; 0
     e02:	80 40       	sbci	r24, 0x00	; 0
     e04:	e1 f7       	brne	.-8      	; 0xdfe <Alarm_Fn+0x4f2>
     e06:	00 c0       	rjmp	.+0      	; 0xe08 <Alarm_Fn+0x4fc>
     e08:	00 00       	nop
	_delay_ms(200);
	LED0_Toggle();
     e0a:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	LED2_Toggle();
     e0e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED2_Toggle>
	LED3_Toggle();
     e12:	0e 94 01 0a 	call	0x1402	; 0x1402 <LED3_Toggle>
	LED1_Toggle();
     e16:	0e 94 df 09 	call	0x13be	; 0x13be <LED1_Toggle>
	LED4_Toggle();
     e1a:	0e 94 12 0a 	call	0x1424	; 0x1424 <LED4_Toggle>
	Buzzer_Toggle();
     e1e:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     e22:	9f ef       	ldi	r25, 0xFF	; 255
     e24:	2d ee       	ldi	r18, 0xED	; 237
     e26:	82 e0       	ldi	r24, 0x02	; 2
     e28:	91 50       	subi	r25, 0x01	; 1
     e2a:	20 40       	sbci	r18, 0x00	; 0
     e2c:	80 40       	sbci	r24, 0x00	; 0
     e2e:	e1 f7       	brne	.-8      	; 0xe28 <Alarm_Fn+0x51c>
     e30:	00 c0       	rjmp	.+0      	; 0xe32 <Alarm_Fn+0x526>
     e32:	00 00       	nop
	_delay_ms(Delay);
	LED2_Toggle();
     e34:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED2_Toggle>
	LED3_Toggle();
     e38:	0e 94 01 0a 	call	0x1402	; 0x1402 <LED3_Toggle>
	LED0_Toggle();
     e3c:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	LED1_Toggle();
     e40:	0e 94 df 09 	call	0x13be	; 0x13be <LED1_Toggle>
	LED4_Toggle();
     e44:	0e 94 12 0a 	call	0x1424	; 0x1424 <LED4_Toggle>
	Buzzer_Toggle();
     e48:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     e4c:	9f ef       	ldi	r25, 0xFF	; 255
     e4e:	21 ee       	ldi	r18, 0xE1	; 225
     e50:	84 e0       	ldi	r24, 0x04	; 4
     e52:	91 50       	subi	r25, 0x01	; 1
     e54:	20 40       	sbci	r18, 0x00	; 0
     e56:	80 40       	sbci	r24, 0x00	; 0
     e58:	e1 f7       	brne	.-8      	; 0xe52 <Alarm_Fn+0x546>
     e5a:	00 c0       	rjmp	.+0      	; 0xe5c <Alarm_Fn+0x550>
     e5c:	00 00       	nop
	_delay_ms(100);
	LED2_Toggle();
     e5e:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED2_Toggle>
	LED3_Toggle();
     e62:	0e 94 01 0a 	call	0x1402	; 0x1402 <LED3_Toggle>
	LED0_Toggle();
     e66:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	LED1_Toggle();
     e6a:	0e 94 df 09 	call	0x13be	; 0x13be <LED1_Toggle>
	LED4_Toggle();
     e6e:	0e 94 12 0a 	call	0x1424	; 0x1424 <LED4_Toggle>
	Buzzer_Toggle();
     e72:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     e76:	9f ef       	ldi	r25, 0xFF	; 255
     e78:	2d ee       	ldi	r18, 0xED	; 237
     e7a:	82 e0       	ldi	r24, 0x02	; 2
     e7c:	91 50       	subi	r25, 0x01	; 1
     e7e:	20 40       	sbci	r18, 0x00	; 0
     e80:	80 40       	sbci	r24, 0x00	; 0
     e82:	e1 f7       	brne	.-8      	; 0xe7c <Alarm_Fn+0x570>
     e84:	00 c0       	rjmp	.+0      	; 0xe86 <Alarm_Fn+0x57a>
     e86:	00 00       	nop
	_delay_ms(Delay);
	LED2_Toggle();
     e88:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED2_Toggle>
	LED3_Toggle();
     e8c:	0e 94 01 0a 	call	0x1402	; 0x1402 <LED3_Toggle>
	LED0_Toggle();
     e90:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	LED1_Toggle();
     e94:	0e 94 df 09 	call	0x13be	; 0x13be <LED1_Toggle>
	LED4_Toggle();
     e98:	0e 94 12 0a 	call	0x1424	; 0x1424 <LED4_Toggle>
	Buzzer_Toggle();
     e9c:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     ea0:	9f ef       	ldi	r25, 0xFF	; 255
     ea2:	23 ed       	ldi	r18, 0xD3	; 211
     ea4:	80 e3       	ldi	r24, 0x30	; 48
     ea6:	91 50       	subi	r25, 0x01	; 1
     ea8:	20 40       	sbci	r18, 0x00	; 0
     eaa:	80 40       	sbci	r24, 0x00	; 0
     eac:	e1 f7       	brne	.-8      	; 0xea6 <Alarm_Fn+0x59a>
     eae:	00 c0       	rjmp	.+0      	; 0xeb0 <Alarm_Fn+0x5a4>
     eb0:	00 00       	nop
	_delay_ms(1000);
	LED2_Toggle();
     eb2:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED2_Toggle>
	LED3_Toggle();
     eb6:	0e 94 01 0a 	call	0x1402	; 0x1402 <LED3_Toggle>
	LED0_Toggle();
     eba:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	LED1_Toggle();
     ebe:	0e 94 df 09 	call	0x13be	; 0x13be <LED1_Toggle>
	LED4_Toggle();
     ec2:	0e 94 12 0a 	call	0x1424	; 0x1424 <LED4_Toggle>
	Buzzer_Toggle();
     ec6:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     eca:	8f e3       	ldi	r24, 0x3F	; 63
     ecc:	9c e9       	ldi	r25, 0x9C	; 156
     ece:	01 97       	sbiw	r24, 0x01	; 1
     ed0:	f1 f7       	brne	.-4      	; 0xece <Alarm_Fn+0x5c2>
     ed2:	00 c0       	rjmp	.+0      	; 0xed4 <Alarm_Fn+0x5c8>
     ed4:	00 00       	nop
	_delay_ms(10);
	LED2_Toggle();
     ed6:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED2_Toggle>
	LED3_Toggle();
     eda:	0e 94 01 0a 	call	0x1402	; 0x1402 <LED3_Toggle>
	LED0_Toggle();
     ede:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	LED1_Toggle();
     ee2:	0e 94 df 09 	call	0x13be	; 0x13be <LED1_Toggle>
	LED4_Toggle();
     ee6:	0e 94 12 0a 	call	0x1424	; 0x1424 <LED4_Toggle>
	Buzzer_Toggle();
     eea:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     eee:	8f e3       	ldi	r24, 0x3F	; 63
     ef0:	9c e9       	ldi	r25, 0x9C	; 156
     ef2:	01 97       	sbiw	r24, 0x01	; 1
     ef4:	f1 f7       	brne	.-4      	; 0xef2 <Alarm_Fn+0x5e6>
     ef6:	00 c0       	rjmp	.+0      	; 0xef8 <Alarm_Fn+0x5ec>
     ef8:	00 00       	nop
	_delay_ms(10);
	LED2_Toggle();
     efa:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <LED2_Toggle>
	LED3_Toggle();
     efe:	0e 94 01 0a 	call	0x1402	; 0x1402 <LED3_Toggle>
	LED0_Toggle();
     f02:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	LED1_Toggle();
     f06:	0e 94 df 09 	call	0x13be	; 0x13be <LED1_Toggle>
	LED4_Toggle();
     f0a:	0e 94 12 0a 	call	0x1424	; 0x1424 <LED4_Toggle>
	Buzzer_Toggle();
     f0e:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     f12:	9f ef       	ldi	r25, 0xFF	; 255
     f14:	21 ee       	ldi	r18, 0xE1	; 225
     f16:	84 e0       	ldi	r24, 0x04	; 4
     f18:	91 50       	subi	r25, 0x01	; 1
     f1a:	20 40       	sbci	r18, 0x00	; 0
     f1c:	80 40       	sbci	r24, 0x00	; 0
     f1e:	e1 f7       	brne	.-8      	; 0xf18 <Alarm_Fn+0x60c>
     f20:	00 c0       	rjmp	.+0      	; 0xf22 <Alarm_Fn+0x616>
     f22:	00 00       	nop
	_delay_ms(100);
	
	LED0_Toggle();
     f24:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_ON();
     f28:	0e 94 79 00 	call	0xf2	; 0xf2 <Buzzer_ON>
     f2c:	9f ef       	ldi	r25, 0xFF	; 255
     f2e:	24 e3       	ldi	r18, 0x34	; 52
     f30:	8c e0       	ldi	r24, 0x0C	; 12
     f32:	91 50       	subi	r25, 0x01	; 1
     f34:	20 40       	sbci	r18, 0x00	; 0
     f36:	80 40       	sbci	r24, 0x00	; 0
     f38:	e1 f7       	brne	.-8      	; 0xf32 <Alarm_Fn+0x626>
     f3a:	00 c0       	rjmp	.+0      	; 0xf3c <Alarm_Fn+0x630>
     f3c:	00 00       	nop
	_delay_ms(250);
	LED0_Toggle();
     f3e:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_Toggle();
     f42:	0e 94 85 00 	call	0x10a	; 0x10a <Buzzer_Toggle>
     f46:	9f ef       	ldi	r25, 0xFF	; 255
     f48:	24 e3       	ldi	r18, 0x34	; 52
     f4a:	8c e0       	ldi	r24, 0x0C	; 12
     f4c:	91 50       	subi	r25, 0x01	; 1
     f4e:	20 40       	sbci	r18, 0x00	; 0
     f50:	80 40       	sbci	r24, 0x00	; 0
     f52:	e1 f7       	brne	.-8      	; 0xf4c <Alarm_Fn+0x640>
     f54:	00 c0       	rjmp	.+0      	; 0xf56 <Alarm_Fn+0x64a>
     f56:	00 00       	nop
	_delay_ms(250);
	LED0_Toggle();
     f58:	0e 94 ce 09 	call	0x139c	; 0x139c <LED0_Toggle>
	Buzzer_ON();
     f5c:	0e 94 79 00 	call	0xf2	; 0xf2 <Buzzer_ON>
     f60:	9f ef       	ldi	r25, 0xFF	; 255
     f62:	2d ee       	ldi	r18, 0xED	; 237
     f64:	82 e0       	ldi	r24, 0x02	; 2
     f66:	91 50       	subi	r25, 0x01	; 1
     f68:	20 40       	sbci	r18, 0x00	; 0
     f6a:	80 40       	sbci	r24, 0x00	; 0
     f6c:	e1 f7       	brne	.-8      	; 0xf66 <Alarm_Fn+0x65a>
     f6e:	00 c0       	rjmp	.+0      	; 0xf70 <Alarm_Fn+0x664>
     f70:	00 00       	nop
	_delay_ms(Delay);
	Buzzer_OFF();
     f72:	0e 94 7f 00 	call	0xfe	; 0xfe <Buzzer_OFF>
     f76:	08 95       	ret

00000f78 <I2C_SendStartCond>:
// 	{
// 		(*pptr0)();
// 		(*pptr1)(string16);
// 	}
	return TWDR;
}
     f78:	84 ea       	ldi	r24, 0xA4	; 164
     f7a:	86 bf       	out	0x36, r24	; 54
     f7c:	06 b6       	in	r0, 0x36	; 54
     f7e:	07 fe       	sbrs	r0, 7
     f80:	fd cf       	rjmp	.-6      	; 0xf7c <I2C_SendStartCond+0x4>
     f82:	08 95       	ret

00000f84 <I2C_SendRepStartCond>:
     f84:	84 ea       	ldi	r24, 0xA4	; 164
     f86:	86 bf       	out	0x36, r24	; 54
     f88:	06 b6       	in	r0, 0x36	; 54
     f8a:	07 fe       	sbrs	r0, 7
     f8c:	fd cf       	rjmp	.-6      	; 0xf88 <I2C_SendRepStartCond+0x4>
     f8e:	08 95       	ret

00000f90 <I2C_SendSlaveAdd_WriteOP>:
     f90:	88 0f       	add	r24, r24
     f92:	83 b9       	out	0x03, r24	; 3
     f94:	84 e8       	ldi	r24, 0x84	; 132
     f96:	86 bf       	out	0x36, r24	; 54
     f98:	06 b6       	in	r0, 0x36	; 54
     f9a:	07 fe       	sbrs	r0, 7
     f9c:	fd cf       	rjmp	.-6      	; 0xf98 <I2C_SendSlaveAdd_WriteOP+0x8>
     f9e:	2f ef       	ldi	r18, 0xFF	; 255
     fa0:	81 ee       	ldi	r24, 0xE1	; 225
     fa2:	94 e0       	ldi	r25, 0x04	; 4
     fa4:	21 50       	subi	r18, 0x01	; 1
     fa6:	80 40       	sbci	r24, 0x00	; 0
     fa8:	90 40       	sbci	r25, 0x00	; 0
     faa:	e1 f7       	brne	.-8      	; 0xfa4 <I2C_SendSlaveAdd_WriteOP+0x14>
     fac:	00 c0       	rjmp	.+0      	; 0xfae <I2C_SendSlaveAdd_WriteOP+0x1e>
     fae:	00 00       	nop
     fb0:	08 95       	ret

00000fb2 <I2C_SendSlaveAdd_ReadOP>:
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	88 0f       	add	r24, r24
     fb6:	99 1f       	adc	r25, r25
     fb8:	81 60       	ori	r24, 0x01	; 1
     fba:	83 b9       	out	0x03, r24	; 3
     fbc:	84 e8       	ldi	r24, 0x84	; 132
     fbe:	86 bf       	out	0x36, r24	; 54
     fc0:	06 b6       	in	r0, 0x36	; 54
     fc2:	07 fe       	sbrs	r0, 7
     fc4:	fd cf       	rjmp	.-6      	; 0xfc0 <I2C_SendSlaveAdd_ReadOP+0xe>
     fc6:	08 95       	ret

00000fc8 <I2C_SendData>:
     fc8:	83 b9       	out	0x03, r24	; 3
     fca:	84 e8       	ldi	r24, 0x84	; 132
     fcc:	86 bf       	out	0x36, r24	; 54
     fce:	06 b6       	in	r0, 0x36	; 54
     fd0:	07 fe       	sbrs	r0, 7
     fd2:	fd cf       	rjmp	.-6      	; 0xfce <I2C_SendData+0x6>
     fd4:	08 95       	ret

00000fd6 <I2C_ReadData>:
     fd6:	84 e8       	ldi	r24, 0x84	; 132
     fd8:	86 bf       	out	0x36, r24	; 54
     fda:	06 b6       	in	r0, 0x36	; 54
     fdc:	07 fe       	sbrs	r0, 7
     fde:	fd cf       	rjmp	.-6      	; 0xfda <I2C_ReadData+0x4>
     fe0:	83 b1       	in	r24, 0x03	; 3
     fe2:	08 95       	ret

00000fe4 <I2C_SendStopCond>:

void I2C_SendStopCond(void)
{
	TWCR = (1<<TWSTO)|(1<<TWEN)|(1<<TWINT);
     fe4:	84 e9       	ldi	r24, 0x94	; 148
     fe6:	86 bf       	out	0x36, r24	; 54
	Set_Bit(TWCR, 7);
     fe8:	86 b7       	in	r24, 0x36	; 54
     fea:	80 68       	ori	r24, 0x80	; 128
     fec:	86 bf       	out	0x36, r24	; 54
     fee:	08 95       	ret

00000ff0 <Keypad_GetValue>:
     ff0:	1f 93       	push	r17
     ff2:	cf 93       	push	r28
     ff4:	df 93       	push	r29
     ff6:	d0 e0       	ldi	r29, 0x00	; 0
     ff8:	10 e0       	ldi	r17, 0x00	; 0
     ffa:	28 c0       	rjmp	.+80     	; 0x104c <Keypad_GetValue+0x5c>
     ffc:	41 e0       	ldi	r20, 0x01	; 1
     ffe:	6d 2f       	mov	r22, r29
    1000:	80 e0       	ldi	r24, 0x00	; 0
    1002:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1006:	c3 e0       	ldi	r28, 0x03	; 3
    1008:	19 c0       	rjmp	.+50     	; 0x103c <Keypad_GetValue+0x4c>
    100a:	6c 2f       	mov	r22, r28
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	0e 94 b7 01 	call	0x36e	; 0x36e <DIO_GetPin_Value>
    1012:	81 11       	cpse	r24, r1
    1014:	12 c0       	rjmp	.+36     	; 0x103a <Keypad_GetValue+0x4a>
    1016:	ec 2f       	mov	r30, r28
    1018:	f0 e0       	ldi	r31, 0x00	; 0
    101a:	33 97       	sbiw	r30, 0x03	; 3
    101c:	ee 0f       	add	r30, r30
    101e:	ff 1f       	adc	r31, r31
    1020:	ee 0f       	add	r30, r30
    1022:	ff 1f       	adc	r31, r31
    1024:	e0 5a       	subi	r30, 0xA0	; 160
    1026:	ff 4f       	sbci	r31, 0xFF	; 255
    1028:	ed 0f       	add	r30, r29
    102a:	f1 1d       	adc	r31, r1
    102c:	10 81       	ld	r17, Z
    102e:	6c 2f       	mov	r22, r28
    1030:	80 e0       	ldi	r24, 0x00	; 0
    1032:	0e 94 b7 01 	call	0x36e	; 0x36e <DIO_GetPin_Value>
    1036:	88 23       	and	r24, r24
    1038:	d1 f3       	breq	.-12     	; 0x102e <Keypad_GetValue+0x3e>
    103a:	cf 5f       	subi	r28, 0xFF	; 255
    103c:	c7 30       	cpi	r28, 0x07	; 7
    103e:	28 f3       	brcs	.-54     	; 0x100a <Keypad_GetValue+0x1a>
    1040:	40 e0       	ldi	r20, 0x00	; 0
    1042:	6d 2f       	mov	r22, r29
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    104a:	df 5f       	subi	r29, 0xFF	; 255
    104c:	d3 30       	cpi	r29, 0x03	; 3
    104e:	b0 f2       	brcs	.-84     	; 0xffc <Keypad_GetValue+0xc>
    1050:	81 2f       	mov	r24, r17
    1052:	df 91       	pop	r29
    1054:	cf 91       	pop	r28
    1056:	1f 91       	pop	r17
    1058:	08 95       	ret

0000105a <LCD_Write_CMD>:
		data *= 10;
		num = data;
		LCD_Write_Char(num + 48);
		data -= num;
	}
}
    105a:	cf 93       	push	r28
    105c:	c8 2f       	mov	r28, r24
    105e:	41 e0       	ldi	r20, 0x01	; 1
    1060:	60 e0       	ldi	r22, 0x00	; 0
    1062:	83 e0       	ldi	r24, 0x03	; 3
    1064:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1068:	41 e0       	ldi	r20, 0x01	; 1
    106a:	61 e0       	ldi	r22, 0x01	; 1
    106c:	83 e0       	ldi	r24, 0x03	; 3
    106e:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1072:	41 e0       	ldi	r20, 0x01	; 1
    1074:	62 e0       	ldi	r22, 0x02	; 2
    1076:	83 e0       	ldi	r24, 0x03	; 3
    1078:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    107c:	85 b3       	in	r24, 0x15	; 21
    107e:	9c 2f       	mov	r25, r28
    1080:	90 7f       	andi	r25, 0xF0	; 240
    1082:	8f 70       	andi	r24, 0x0F	; 15
    1084:	89 2b       	or	r24, r25
    1086:	85 bb       	out	0x15, r24	; 21
    1088:	40 e0       	ldi	r20, 0x00	; 0
    108a:	62 e0       	ldi	r22, 0x02	; 2
    108c:	83 e0       	ldi	r24, 0x03	; 3
    108e:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1092:	8f e9       	ldi	r24, 0x9F	; 159
    1094:	9f e0       	ldi	r25, 0x0F	; 15
    1096:	01 97       	sbiw	r24, 0x01	; 1
    1098:	f1 f7       	brne	.-4      	; 0x1096 <LCD_Write_CMD+0x3c>
    109a:	00 c0       	rjmp	.+0      	; 0x109c <LCD_Write_CMD+0x42>
    109c:	00 00       	nop
    109e:	41 e0       	ldi	r20, 0x01	; 1
    10a0:	62 e0       	ldi	r22, 0x02	; 2
    10a2:	83 e0       	ldi	r24, 0x03	; 3
    10a4:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    10a8:	20 e1       	ldi	r18, 0x10	; 16
    10aa:	c2 9f       	mul	r28, r18
    10ac:	c0 01       	movw	r24, r0
    10ae:	11 24       	eor	r1, r1
    10b0:	95 b3       	in	r25, 0x15	; 21
    10b2:	9f 70       	andi	r25, 0x0F	; 15
    10b4:	89 2b       	or	r24, r25
    10b6:	85 bb       	out	0x15, r24	; 21
    10b8:	40 e0       	ldi	r20, 0x00	; 0
    10ba:	62 e0       	ldi	r22, 0x02	; 2
    10bc:	83 e0       	ldi	r24, 0x03	; 3
    10be:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    10c2:	8f e9       	ldi	r24, 0x9F	; 159
    10c4:	9f e0       	ldi	r25, 0x0F	; 15
    10c6:	01 97       	sbiw	r24, 0x01	; 1
    10c8:	f1 f7       	brne	.-4      	; 0x10c6 <LCD_Write_CMD+0x6c>
    10ca:	00 c0       	rjmp	.+0      	; 0x10cc <LCD_Write_CMD+0x72>
    10cc:	00 00       	nop
    10ce:	41 e0       	ldi	r20, 0x01	; 1
    10d0:	62 e0       	ldi	r22, 0x02	; 2
    10d2:	83 e0       	ldi	r24, 0x03	; 3
    10d4:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    10d8:	8f e1       	ldi	r24, 0x1F	; 31
    10da:	9e e4       	ldi	r25, 0x4E	; 78
    10dc:	01 97       	sbiw	r24, 0x01	; 1
    10de:	f1 f7       	brne	.-4      	; 0x10dc <LCD_Write_CMD+0x82>
    10e0:	00 c0       	rjmp	.+0      	; 0x10e2 <LCD_Write_CMD+0x88>
    10e2:	00 00       	nop
    10e4:	cf 91       	pop	r28
    10e6:	08 95       	ret

000010e8 <LCD_Init>:
    10e8:	41 e0       	ldi	r20, 0x01	; 1
    10ea:	60 e0       	ldi	r22, 0x00	; 0
    10ec:	83 e0       	ldi	r24, 0x03	; 3
    10ee:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
    10f2:	41 e0       	ldi	r20, 0x01	; 1
    10f4:	61 e0       	ldi	r22, 0x01	; 1
    10f6:	83 e0       	ldi	r24, 0x03	; 3
    10f8:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
    10fc:	41 e0       	ldi	r20, 0x01	; 1
    10fe:	62 e0       	ldi	r22, 0x02	; 2
    1100:	83 e0       	ldi	r24, 0x03	; 3
    1102:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
    1106:	41 e0       	ldi	r20, 0x01	; 1
    1108:	64 e0       	ldi	r22, 0x04	; 4
    110a:	82 e0       	ldi	r24, 0x02	; 2
    110c:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
    1110:	41 e0       	ldi	r20, 0x01	; 1
    1112:	65 e0       	ldi	r22, 0x05	; 5
    1114:	82 e0       	ldi	r24, 0x02	; 2
    1116:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
    111a:	41 e0       	ldi	r20, 0x01	; 1
    111c:	66 e0       	ldi	r22, 0x06	; 6
    111e:	82 e0       	ldi	r24, 0x02	; 2
    1120:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
    1124:	41 e0       	ldi	r20, 0x01	; 1
    1126:	67 e0       	ldi	r22, 0x07	; 7
    1128:	82 e0       	ldi	r24, 0x02	; 2
    112a:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
    112e:	41 e0       	ldi	r20, 0x01	; 1
    1130:	60 e0       	ldi	r22, 0x00	; 0
    1132:	83 e0       	ldi	r24, 0x03	; 3
    1134:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1138:	41 e0       	ldi	r20, 0x01	; 1
    113a:	61 e0       	ldi	r22, 0x01	; 1
    113c:	83 e0       	ldi	r24, 0x03	; 3
    113e:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1142:	41 e0       	ldi	r20, 0x01	; 1
    1144:	62 e0       	ldi	r22, 0x02	; 2
    1146:	83 e0       	ldi	r24, 0x03	; 3
    1148:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    114c:	41 e0       	ldi	r20, 0x01	; 1
    114e:	64 e0       	ldi	r22, 0x04	; 4
    1150:	82 e0       	ldi	r24, 0x02	; 2
    1152:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1156:	41 e0       	ldi	r20, 0x01	; 1
    1158:	65 e0       	ldi	r22, 0x05	; 5
    115a:	82 e0       	ldi	r24, 0x02	; 2
    115c:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1160:	41 e0       	ldi	r20, 0x01	; 1
    1162:	66 e0       	ldi	r22, 0x06	; 6
    1164:	82 e0       	ldi	r24, 0x02	; 2
    1166:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    116a:	41 e0       	ldi	r20, 0x01	; 1
    116c:	67 e0       	ldi	r22, 0x07	; 7
    116e:	82 e0       	ldi	r24, 0x02	; 2
    1170:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1174:	2f ef       	ldi	r18, 0xFF	; 255
    1176:	81 ee       	ldi	r24, 0xE1	; 225
    1178:	94 e0       	ldi	r25, 0x04	; 4
    117a:	21 50       	subi	r18, 0x01	; 1
    117c:	80 40       	sbci	r24, 0x00	; 0
    117e:	90 40       	sbci	r25, 0x00	; 0
    1180:	e1 f7       	brne	.-8      	; 0x117a <LCD_Init+0x92>
    1182:	00 c0       	rjmp	.+0      	; 0x1184 <LCD_Init+0x9c>
    1184:	00 00       	nop
    1186:	83 e3       	ldi	r24, 0x33	; 51
    1188:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
    118c:	82 e3       	ldi	r24, 0x32	; 50
    118e:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
    1192:	88 e2       	ldi	r24, 0x28	; 40
    1194:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
    119e:	82 e0       	ldi	r24, 0x02	; 2
    11a0:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
    11a4:	86 e0       	ldi	r24, 0x06	; 6
    11a6:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
    11aa:	8c e0       	ldi	r24, 0x0C	; 12
    11ac:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
    11b0:	08 95       	ret

000011b2 <LCD_Write_Char>:
    11b2:	cf 93       	push	r28
    11b4:	c8 2f       	mov	r28, r24
    11b6:	40 e0       	ldi	r20, 0x00	; 0
    11b8:	60 e0       	ldi	r22, 0x00	; 0
    11ba:	83 e0       	ldi	r24, 0x03	; 3
    11bc:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    11c0:	41 e0       	ldi	r20, 0x01	; 1
    11c2:	61 e0       	ldi	r22, 0x01	; 1
    11c4:	83 e0       	ldi	r24, 0x03	; 3
    11c6:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    11ca:	41 e0       	ldi	r20, 0x01	; 1
    11cc:	62 e0       	ldi	r22, 0x02	; 2
    11ce:	83 e0       	ldi	r24, 0x03	; 3
    11d0:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    11d4:	85 b3       	in	r24, 0x15	; 21
    11d6:	9c 2f       	mov	r25, r28
    11d8:	90 7f       	andi	r25, 0xF0	; 240
    11da:	8f 70       	andi	r24, 0x0F	; 15
    11dc:	89 2b       	or	r24, r25
    11de:	85 bb       	out	0x15, r24	; 21
    11e0:	40 e0       	ldi	r20, 0x00	; 0
    11e2:	62 e0       	ldi	r22, 0x02	; 2
    11e4:	83 e0       	ldi	r24, 0x03	; 3
    11e6:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    11ea:	8f e9       	ldi	r24, 0x9F	; 159
    11ec:	9f e0       	ldi	r25, 0x0F	; 15
    11ee:	01 97       	sbiw	r24, 0x01	; 1
    11f0:	f1 f7       	brne	.-4      	; 0x11ee <LCD_Write_Char+0x3c>
    11f2:	00 c0       	rjmp	.+0      	; 0x11f4 <LCD_Write_Char+0x42>
    11f4:	00 00       	nop
    11f6:	41 e0       	ldi	r20, 0x01	; 1
    11f8:	62 e0       	ldi	r22, 0x02	; 2
    11fa:	83 e0       	ldi	r24, 0x03	; 3
    11fc:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1200:	20 e1       	ldi	r18, 0x10	; 16
    1202:	c2 9f       	mul	r28, r18
    1204:	c0 01       	movw	r24, r0
    1206:	11 24       	eor	r1, r1
    1208:	95 b3       	in	r25, 0x15	; 21
    120a:	9f 70       	andi	r25, 0x0F	; 15
    120c:	89 2b       	or	r24, r25
    120e:	85 bb       	out	0x15, r24	; 21
    1210:	40 e0       	ldi	r20, 0x00	; 0
    1212:	62 e0       	ldi	r22, 0x02	; 2
    1214:	83 e0       	ldi	r24, 0x03	; 3
    1216:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    121a:	8f e9       	ldi	r24, 0x9F	; 159
    121c:	9f e0       	ldi	r25, 0x0F	; 15
    121e:	01 97       	sbiw	r24, 0x01	; 1
    1220:	f1 f7       	brne	.-4      	; 0x121e <LCD_Write_Char+0x6c>
    1222:	00 c0       	rjmp	.+0      	; 0x1224 <LCD_Write_Char+0x72>
    1224:	00 00       	nop
    1226:	41 e0       	ldi	r20, 0x01	; 1
    1228:	62 e0       	ldi	r22, 0x02	; 2
    122a:	83 e0       	ldi	r24, 0x03	; 3
    122c:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1230:	cf 91       	pop	r28
    1232:	08 95       	ret

00001234 <LCD_Write_String>:
    1234:	0f 93       	push	r16
    1236:	1f 93       	push	r17
    1238:	cf 93       	push	r28
    123a:	8c 01       	movw	r16, r24
    123c:	c0 e0       	ldi	r28, 0x00	; 0
    123e:	03 c0       	rjmp	.+6      	; 0x1246 <LCD_Write_String+0x12>
    1240:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <LCD_Write_Char>
    1244:	cf 5f       	subi	r28, 0xFF	; 255
    1246:	f8 01       	movw	r30, r16
    1248:	ec 0f       	add	r30, r28
    124a:	f1 1d       	adc	r31, r1
    124c:	80 81       	ld	r24, Z
    124e:	81 11       	cpse	r24, r1
    1250:	f7 cf       	rjmp	.-18     	; 0x1240 <LCD_Write_String+0xc>
    1252:	cf 91       	pop	r28
    1254:	1f 91       	pop	r17
    1256:	0f 91       	pop	r16
    1258:	08 95       	ret

0000125a <LCD_Write_Integer>:
    125a:	8f 92       	push	r8
    125c:	9f 92       	push	r9
    125e:	af 92       	push	r10
    1260:	bf 92       	push	r11
    1262:	ef 92       	push	r14
    1264:	ff 92       	push	r15
    1266:	0f 93       	push	r16
    1268:	1f 93       	push	r17
    126a:	cf 93       	push	r28
    126c:	df 93       	push	r29
    126e:	4b 01       	movw	r8, r22
    1270:	5c 01       	movw	r10, r24
    1272:	67 2b       	or	r22, r23
    1274:	68 2b       	or	r22, r24
    1276:	69 2b       	or	r22, r25
    1278:	19 f4       	brne	.+6      	; 0x1280 <LCD_Write_Integer+0x26>
    127a:	80 e3       	ldi	r24, 0x30	; 48
    127c:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <LCD_Write_Char>
    1280:	01 e0       	ldi	r16, 0x01	; 1
    1282:	10 e0       	ldi	r17, 0x00	; 0
    1284:	e1 2c       	mov	r14, r1
    1286:	f1 2c       	mov	r15, r1
    1288:	2f c0       	rjmp	.+94     	; 0x12e8 <LCD_Write_Integer+0x8e>
    128a:	c7 01       	movw	r24, r14
    128c:	88 0f       	add	r24, r24
    128e:	99 1f       	adc	r25, r25
    1290:	b7 01       	movw	r22, r14
    1292:	66 0f       	add	r22, r22
    1294:	77 1f       	adc	r23, r23
    1296:	66 0f       	add	r22, r22
    1298:	77 1f       	adc	r23, r23
    129a:	66 0f       	add	r22, r22
    129c:	77 1f       	adc	r23, r23
    129e:	7c 01       	movw	r14, r24
    12a0:	e6 0e       	add	r14, r22
    12a2:	f7 1e       	adc	r15, r23
    12a4:	c5 01       	movw	r24, r10
    12a6:	b4 01       	movw	r22, r8
    12a8:	2a e0       	ldi	r18, 0x0A	; 10
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	40 e0       	ldi	r20, 0x00	; 0
    12ae:	50 e0       	ldi	r21, 0x00	; 0
    12b0:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <__udivmodsi4>
    12b4:	e6 0e       	add	r14, r22
    12b6:	f7 1e       	adc	r15, r23
    12b8:	e1 14       	cp	r14, r1
    12ba:	f1 04       	cpc	r15, r1
    12bc:	59 f4       	brne	.+22     	; 0x12d4 <LCD_Write_Integer+0x7a>
    12be:	c8 01       	movw	r24, r16
    12c0:	88 0f       	add	r24, r24
    12c2:	99 1f       	adc	r25, r25
    12c4:	00 0f       	add	r16, r16
    12c6:	11 1f       	adc	r17, r17
    12c8:	00 0f       	add	r16, r16
    12ca:	11 1f       	adc	r17, r17
    12cc:	00 0f       	add	r16, r16
    12ce:	11 1f       	adc	r17, r17
    12d0:	08 0f       	add	r16, r24
    12d2:	19 1f       	adc	r17, r25
    12d4:	c5 01       	movw	r24, r10
    12d6:	b4 01       	movw	r22, r8
    12d8:	2a e0       	ldi	r18, 0x0A	; 10
    12da:	30 e0       	ldi	r19, 0x00	; 0
    12dc:	40 e0       	ldi	r20, 0x00	; 0
    12de:	50 e0       	ldi	r21, 0x00	; 0
    12e0:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <__udivmodsi4>
    12e4:	49 01       	movw	r8, r18
    12e6:	5a 01       	movw	r10, r20
    12e8:	81 14       	cp	r8, r1
    12ea:	91 04       	cpc	r9, r1
    12ec:	a1 04       	cpc	r10, r1
    12ee:	b1 04       	cpc	r11, r1
    12f0:	61 f6       	brne	.-104    	; 0x128a <LCD_Write_Integer+0x30>
    12f2:	a1 2c       	mov	r10, r1
    12f4:	b1 2c       	mov	r11, r1
    12f6:	16 c0       	rjmp	.+44     	; 0x1324 <LCD_Write_Integer+0xca>
    12f8:	c7 01       	movw	r24, r14
    12fa:	6a e0       	ldi	r22, 0x0A	; 10
    12fc:	70 e0       	ldi	r23, 0x00	; 0
    12fe:	0e 94 44 1a 	call	0x3488	; 0x3488 <__divmodhi4>
    1302:	d6 2f       	mov	r29, r22
    1304:	c7 2f       	mov	r28, r23
    1306:	80 5d       	subi	r24, 0xD0	; 208
    1308:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <LCD_Write_Char>
    130c:	ed 2e       	mov	r14, r29
    130e:	fc 2e       	mov	r15, r28
    1310:	e1 14       	cp	r14, r1
    1312:	f1 04       	cpc	r15, r1
    1314:	39 f4       	brne	.+14     	; 0x1324 <LCD_Write_Integer+0xca>
    1316:	0a 30       	cpi	r16, 0x0A	; 10
    1318:	11 05       	cpc	r17, r1
    131a:	24 f0       	brlt	.+8      	; 0x1324 <LCD_Write_Integer+0xca>
    131c:	78 01       	movw	r14, r16
    131e:	aa 24       	eor	r10, r10
    1320:	a3 94       	inc	r10
    1322:	b1 2c       	mov	r11, r1
    1324:	ea 14       	cp	r14, r10
    1326:	fb 04       	cpc	r15, r11
    1328:	39 f7       	brne	.-50     	; 0x12f8 <LCD_Write_Integer+0x9e>
    132a:	df 91       	pop	r29
    132c:	cf 91       	pop	r28
    132e:	1f 91       	pop	r17
    1330:	0f 91       	pop	r16
    1332:	ff 90       	pop	r15
    1334:	ef 90       	pop	r14
    1336:	bf 90       	pop	r11
    1338:	af 90       	pop	r10
    133a:	9f 90       	pop	r9
    133c:	8f 90       	pop	r8
    133e:	08 95       	ret

00001340 <LCD_Clear>:

void LCD_Clear(void)
{
	LCD_Write_CMD(Clear_Display_Screen);
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
    1346:	08 95       	ret

00001348 <LCD_Goto>:
}

void LCD_Goto(Uint8 row, Uint8 column)
{
    1348:	cf 93       	push	r28
    134a:	df 93       	push	r29
    134c:	00 d0       	rcall	.+0      	; 0x134e <LCD_Goto+0x6>
    134e:	cd b7       	in	r28, 0x3d	; 61
    1350:	de b7       	in	r29, 0x3e	; 62
	Uint8 arr[2] = {DDRAM_Cursor_Begin_1st_Line, DDRAM_Cursor_Begin_2st_Line};
    1352:	90 e8       	ldi	r25, 0x80	; 128
    1354:	99 83       	std	Y+1, r25	; 0x01
    1356:	90 ec       	ldi	r25, 0xC0	; 192
    1358:	9a 83       	std	Y+2, r25	; 0x02
		
	row = (row >= 0) && (row <= 1)? row : 0;
    135a:	82 30       	cpi	r24, 0x02	; 2
    135c:	08 f0       	brcs	.+2      	; 0x1360 <LCD_Goto+0x18>
    135e:	80 e0       	ldi	r24, 0x00	; 0
	column = (column >= 0) && (column <= 39)? column : 0; 
    1360:	68 32       	cpi	r22, 0x28	; 40
    1362:	08 f0       	brcs	.+2      	; 0x1366 <LCD_Goto+0x1e>
    1364:	60 e0       	ldi	r22, 0x00	; 0
	
	LCD_Write_CMD((arr[row] + column));	
    1366:	e1 e0       	ldi	r30, 0x01	; 1
    1368:	f0 e0       	ldi	r31, 0x00	; 0
    136a:	ec 0f       	add	r30, r28
    136c:	fd 1f       	adc	r31, r29
    136e:	e8 0f       	add	r30, r24
    1370:	f1 1d       	adc	r31, r1
    1372:	80 81       	ld	r24, Z
    1374:	86 0f       	add	r24, r22
    1376:	0e 94 2d 08 	call	0x105a	; 0x105a <LCD_Write_CMD>
}
    137a:	0f 90       	pop	r0
    137c:	0f 90       	pop	r0
    137e:	df 91       	pop	r29
    1380:	cf 91       	pop	r28
    1382:	08 95       	ret

00001384 <LED0_ON>:
    1384:	40 e0       	ldi	r20, 0x00	; 0
    1386:	62 e0       	ldi	r22, 0x02	; 2
    1388:	82 e0       	ldi	r24, 0x02	; 2
    138a:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    138e:	08 95       	ret

00001390 <LED0_OFF>:
    1390:	41 e0       	ldi	r20, 0x01	; 1
    1392:	62 e0       	ldi	r22, 0x02	; 2
    1394:	82 e0       	ldi	r24, 0x02	; 2
    1396:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    139a:	08 95       	ret

0000139c <LED0_Toggle>:
    139c:	62 e0       	ldi	r22, 0x02	; 2
    139e:	82 e0       	ldi	r24, 0x02	; 2
    13a0:	0e 94 e5 01 	call	0x3ca	; 0x3ca <DIO_TogglePin_Value>
    13a4:	08 95       	ret

000013a6 <LED1_ON>:
    13a6:	40 e0       	ldi	r20, 0x00	; 0
    13a8:	63 e0       	ldi	r22, 0x03	; 3
    13aa:	82 e0       	ldi	r24, 0x02	; 2
    13ac:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    13b0:	08 95       	ret

000013b2 <LED1_OFF>:
    13b2:	41 e0       	ldi	r20, 0x01	; 1
    13b4:	63 e0       	ldi	r22, 0x03	; 3
    13b6:	82 e0       	ldi	r24, 0x02	; 2
    13b8:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    13bc:	08 95       	ret

000013be <LED1_Toggle>:
    13be:	63 e0       	ldi	r22, 0x03	; 3
    13c0:	82 e0       	ldi	r24, 0x02	; 2
    13c2:	0e 94 e5 01 	call	0x3ca	; 0x3ca <DIO_TogglePin_Value>
    13c6:	08 95       	ret

000013c8 <LED2_ON>:
    13c8:	40 e0       	ldi	r20, 0x00	; 0
    13ca:	64 e0       	ldi	r22, 0x04	; 4
    13cc:	82 e0       	ldi	r24, 0x02	; 2
    13ce:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    13d2:	08 95       	ret

000013d4 <LED2_OFF>:
    13d4:	41 e0       	ldi	r20, 0x01	; 1
    13d6:	64 e0       	ldi	r22, 0x04	; 4
    13d8:	82 e0       	ldi	r24, 0x02	; 2
    13da:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    13de:	08 95       	ret

000013e0 <LED2_Toggle>:
    13e0:	64 e0       	ldi	r22, 0x04	; 4
    13e2:	82 e0       	ldi	r24, 0x02	; 2
    13e4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <DIO_TogglePin_Value>
    13e8:	08 95       	ret

000013ea <LED3_ON>:
    13ea:	40 e0       	ldi	r20, 0x00	; 0
    13ec:	65 e0       	ldi	r22, 0x05	; 5
    13ee:	82 e0       	ldi	r24, 0x02	; 2
    13f0:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    13f4:	08 95       	ret

000013f6 <LED3_OFF>:
    13f6:	41 e0       	ldi	r20, 0x01	; 1
    13f8:	65 e0       	ldi	r22, 0x05	; 5
    13fa:	82 e0       	ldi	r24, 0x02	; 2
    13fc:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1400:	08 95       	ret

00001402 <LED3_Toggle>:
    1402:	65 e0       	ldi	r22, 0x05	; 5
    1404:	82 e0       	ldi	r24, 0x02	; 2
    1406:	0e 94 e5 01 	call	0x3ca	; 0x3ca <DIO_TogglePin_Value>
    140a:	08 95       	ret

0000140c <LED4_ON>:
    140c:	40 e0       	ldi	r20, 0x00	; 0
    140e:	66 e0       	ldi	r22, 0x06	; 6
    1410:	82 e0       	ldi	r24, 0x02	; 2
    1412:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1416:	08 95       	ret

00001418 <LED4_OFF>:
    1418:	41 e0       	ldi	r20, 0x01	; 1
    141a:	66 e0       	ldi	r22, 0x06	; 6
    141c:	82 e0       	ldi	r24, 0x02	; 2
    141e:	0e 94 46 01 	call	0x28c	; 0x28c <DIO_SetPin_Value>
    1422:	08 95       	ret

00001424 <LED4_Toggle>:
    1424:	66 e0       	ldi	r22, 0x06	; 6
    1426:	82 e0       	ldi	r24, 0x02	; 2
    1428:	0e 94 e5 01 	call	0x3ca	; 0x3ca <DIO_TogglePin_Value>
    142c:	08 95       	ret

0000142e <main>:
#include "servoo.h"
// Extern the values of keypad and PC counters
Uint16 Temp=0;
int main(void)
{	
	Timer0_Init();
    142e:	0e 94 c9 0a 	call	0x1592	; 0x1592 <Timer0_Init>
	DC_Motor1_INIT();
    1432:	0e 94 8a 00 	call	0x114	; 0x114 <DC_Motor1_INIT>
	ADC_Init();
    1436:	0e 94 49 00 	call	0x92	; 0x92 <ADC_Init>
	LCD_Init();
    143a:	0e 94 74 08 	call	0x10e8	; 0x10e8 <LCD_Init>
	LCD_Goto(2,1);
    143e:	61 e0       	ldi	r22, 0x01	; 1
    1440:	82 e0       	ldi	r24, 0x02	; 2
    1442:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
	LCD_Write_String("Temp Is : ");
    1446:	86 ea       	ldi	r24, 0xA6	; 166
    1448:	91 e0       	ldi	r25, 0x01	; 1
    144a:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
	LCD_Goto(1,1);
    144e:	61 e0       	ldi	r22, 0x01	; 1
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
	LCD_Write_String("FAN  ");
    1456:	81 eb       	ldi	r24, 0xB1	; 177
    1458:	91 e0       	ldi	r25, 0x01	; 1
    145a:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>


	while (1)
	
	{		
			Temp=ADC_Read(ADC_PIN4)*.48875;
    145e:	84 e0       	ldi	r24, 0x04	; 4
    1460:	0e 94 63 00 	call	0xc6	; 0xc6 <ADC_Read>
    1464:	bc 01       	movw	r22, r24
    1466:	80 e0       	ldi	r24, 0x00	; 0
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	0e 94 20 19 	call	0x3240	; 0x3240 <__floatunsisf>
    146e:	21 e7       	ldi	r18, 0x71	; 113
    1470:	3d e3       	ldi	r19, 0x3D	; 61
    1472:	4a ef       	ldi	r20, 0xFA	; 250
    1474:	5e e3       	ldi	r21, 0x3E	; 62
    1476:	0e 94 d7 19 	call	0x33ae	; 0x33ae <__mulsf3>
    147a:	0e 94 f1 18 	call	0x31e2	; 0x31e2 <__fixunssfsi>
    147e:	70 93 32 07 	sts	0x0732, r23	; 0x800732 <Temp+0x1>
    1482:	60 93 31 07 	sts	0x0731, r22	; 0x800731 <Temp>
			LCD_Goto(2,10);
    1486:	6a e0       	ldi	r22, 0x0A	; 10
    1488:	82 e0       	ldi	r24, 0x02	; 2
    148a:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
			LCD_Write_Integer(Temp);
    148e:	60 91 31 07 	lds	r22, 0x0731	; 0x800731 <Temp>
    1492:	70 91 32 07 	lds	r23, 0x0732	; 0x800732 <Temp+0x1>
    1496:	80 e0       	ldi	r24, 0x00	; 0
    1498:	90 e0       	ldi	r25, 0x00	; 0
    149a:	0e 94 2d 09 	call	0x125a	; 0x125a <LCD_Write_Integer>

		if (Temp<30)
    149e:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <Temp>
    14a2:	90 91 32 07 	lds	r25, 0x0732	; 0x800732 <Temp+0x1>
    14a6:	4e 97       	sbiw	r24, 0x1e	; 30
    14a8:	50 f4       	brcc	.+20     	; 0x14be <main+0x90>
		{
			DC_Motor1_STOP();
    14aa:	0e 94 ca 00 	call	0x194	; 0x194 <DC_Motor1_STOP>
			
			LCD_Goto(1,5);
    14ae:	65 e0       	ldi	r22, 0x05	; 5
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
			LCD_Write_String("OFF");
    14b6:	87 eb       	ldi	r24, 0xB7	; 183
    14b8:	91 e0       	ldi	r25, 0x01	; 1
    14ba:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
			
		}
		if (Temp>=30 && Temp<60)
    14be:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <Temp>
    14c2:	90 91 32 07 	lds	r25, 0x0732	; 0x800732 <Temp+0x1>
    14c6:	4e 97       	sbiw	r24, 0x1e	; 30
    14c8:	4e 97       	sbiw	r24, 0x1e	; 30
    14ca:	78 f4       	brcc	.+30     	; 0x14ea <main+0xbc>
		{
			
			LCD_Goto(1,5);
    14cc:	65 e0       	ldi	r22, 0x05	; 5
    14ce:	81 e0       	ldi	r24, 0x01	; 1
    14d0:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
			LCD_Write_String("ON");
    14d4:	8b eb       	ldi	r24, 0xBB	; 187
    14d6:	91 e0       	ldi	r25, 0x01	; 1
    14d8:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
			DC_Motor1_START(25,Clock_Wise);
    14dc:	40 e0       	ldi	r20, 0x00	; 0
    14de:	60 e0       	ldi	r22, 0x00	; 0
    14e0:	70 e0       	ldi	r23, 0x00	; 0
    14e2:	88 ec       	ldi	r24, 0xC8	; 200
    14e4:	91 e4       	ldi	r25, 0x41	; 65
    14e6:	0e 94 a1 00 	call	0x142	; 0x142 <DC_Motor1_START>
		}
		if (Temp>=60 && Temp<90)
    14ea:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <Temp>
    14ee:	90 91 32 07 	lds	r25, 0x0732	; 0x800732 <Temp+0x1>
    14f2:	cc 97       	sbiw	r24, 0x3c	; 60
    14f4:	4e 97       	sbiw	r24, 0x1e	; 30
    14f6:	78 f4       	brcc	.+30     	; 0x1516 <main+0xe8>
		{
			
			LCD_Goto(1,5);
    14f8:	65 e0       	ldi	r22, 0x05	; 5
    14fa:	81 e0       	ldi	r24, 0x01	; 1
    14fc:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
			LCD_Write_String("ON");
    1500:	8b eb       	ldi	r24, 0xBB	; 187
    1502:	91 e0       	ldi	r25, 0x01	; 1
    1504:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
			DC_Motor1_START(50,Clock_Wise);
    1508:	40 e0       	ldi	r20, 0x00	; 0
    150a:	60 e0       	ldi	r22, 0x00	; 0
    150c:	70 e0       	ldi	r23, 0x00	; 0
    150e:	88 e4       	ldi	r24, 0x48	; 72
    1510:	92 e4       	ldi	r25, 0x42	; 66
    1512:	0e 94 a1 00 	call	0x142	; 0x142 <DC_Motor1_START>
		}
		if (Temp>=90 && Temp <120)
    1516:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <Temp>
    151a:	90 91 32 07 	lds	r25, 0x0732	; 0x800732 <Temp+0x1>
    151e:	8a 55       	subi	r24, 0x5A	; 90
    1520:	91 09       	sbc	r25, r1
    1522:	4e 97       	sbiw	r24, 0x1e	; 30
    1524:	78 f4       	brcc	.+30     	; 0x1544 <main+0x116>
		{
			
			LCD_Goto(1,5);
    1526:	65 e0       	ldi	r22, 0x05	; 5
    1528:	81 e0       	ldi	r24, 0x01	; 1
    152a:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
			LCD_Write_String("ON");
    152e:	8b eb       	ldi	r24, 0xBB	; 187
    1530:	91 e0       	ldi	r25, 0x01	; 1
    1532:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
			DC_Motor1_START(75,Clock_Wise);
    1536:	40 e0       	ldi	r20, 0x00	; 0
    1538:	60 e0       	ldi	r22, 0x00	; 0
    153a:	70 e0       	ldi	r23, 0x00	; 0
    153c:	86 e9       	ldi	r24, 0x96	; 150
    153e:	92 e4       	ldi	r25, 0x42	; 66
    1540:	0e 94 a1 00 	call	0x142	; 0x142 <DC_Motor1_START>
		}
		if (Temp>=120)
    1544:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <Temp>
    1548:	90 91 32 07 	lds	r25, 0x0732	; 0x800732 <Temp+0x1>
    154c:	88 37       	cpi	r24, 0x78	; 120
    154e:	91 05       	cpc	r25, r1
    1550:	08 f4       	brcc	.+2      	; 0x1554 <main+0x126>
    1552:	85 cf       	rjmp	.-246    	; 0x145e <main+0x30>
		{
			
			LCD_Goto(1,5);
    1554:	65 e0       	ldi	r22, 0x05	; 5
    1556:	81 e0       	ldi	r24, 0x01	; 1
    1558:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
			LCD_Write_String("ON");
    155c:	8b eb       	ldi	r24, 0xBB	; 187
    155e:	91 e0       	ldi	r25, 0x01	; 1
    1560:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
			DC_Motor1_START(100,Clock_Wise);
    1564:	40 e0       	ldi	r20, 0x00	; 0
    1566:	60 e0       	ldi	r22, 0x00	; 0
    1568:	70 e0       	ldi	r23, 0x00	; 0
    156a:	88 ec       	ldi	r24, 0xC8	; 200
    156c:	92 e4       	ldi	r25, 0x42	; 66
    156e:	0e 94 a1 00 	call	0x142	; 0x142 <DC_Motor1_START>
    1572:	75 cf       	rjmp	.-278    	; 0x145e <main+0x30>

00001574 <Servoo_Motor>:
	DDRD|=(1<<PIN_5);
	Servoo_Motor(97);
}

void Servoo_Motor(Uint32 duty_Cycle){
	TCNT1=0;
    1574:	1d bc       	out	0x2d, r1	; 45
    1576:	1c bc       	out	0x2c, r1	; 44
	ICR1=4999;  //fPWM=50Hz (Period = 20ms Standard).
    1578:	27 e8       	ldi	r18, 0x87	; 135
    157a:	33 e1       	ldi	r19, 0x13	; 19
    157c:	37 bd       	out	0x27, r19	; 39
    157e:	26 bd       	out	0x26, r18	; 38
	OCR1A=duty_Cycle; /* set the compare value*/
    1580:	7b bd       	out	0x2b, r23	; 43
    1582:	6a bd       	out	0x2a, r22	; 42
     * 1. Clear OC1A on compare match (non inverting mode) COM1A1=1 COM1A0=0
     * 2. Disconnect OC1B  COM1B0=0 COM1B1=0
     * 3. FOC1A=0 FOC1B=0 because these bits are only active in case non-pwm mode
     * 4. Fast Pwm Mode with the TOP in ICR1 WGM10=0 WGM11=1 (Mode Number 14)
	 */
	TCCR1A|=(1<<COM1A1)|(1<<COM1B1)|(1<<WGM11);        //NON Inverted PWM
    1584:	8f b5       	in	r24, 0x2f	; 47
    1586:	82 6a       	ori	r24, 0xA2	; 162
    1588:	8f bd       	out	0x2f, r24	; 47
	TCCR1B|=(1<<WGM13)|(1<<WGM12)|(1<<CS11)|(1<<CS10); //PRESCALER=64 MODE 14(FAST PWM)
    158a:	8e b5       	in	r24, 0x2e	; 46
    158c:	8b 61       	ori	r24, 0x1B	; 27
    158e:	8e bd       	out	0x2e, r24	; 46
    1590:	08 95       	ret

00001592 <Timer0_Init>:
	#elif P_PWM2_Mode == P_OC2_S_CompU_C_CompD
	OCR2 = 255 - (Duty_Cycle * 255 / 100);
	
	#endif
	#endif
}
    1592:	8f b7       	in	r24, 0x3f	; 63
    1594:	80 68       	ori	r24, 0x80	; 128
    1596:	8f bf       	out	0x3f, r24	; 63
    1598:	83 b7       	in	r24, 0x33	; 51
    159a:	87 7f       	andi	r24, 0xF7	; 247
    159c:	83 bf       	out	0x33, r24	; 51
    159e:	83 b7       	in	r24, 0x33	; 51
    15a0:	80 64       	ori	r24, 0x40	; 64
    15a2:	83 bf       	out	0x33, r24	; 51
    15a4:	83 b7       	in	r24, 0x33	; 51
    15a6:	8f 7c       	andi	r24, 0xCF	; 207
    15a8:	80 62       	ori	r24, 0x20	; 32
    15aa:	83 bf       	out	0x33, r24	; 51
    15ac:	89 b7       	in	r24, 0x39	; 57
    15ae:	81 60       	ori	r24, 0x01	; 1
    15b0:	89 bf       	out	0x39, r24	; 57
    15b2:	41 e0       	ldi	r20, 0x01	; 1
    15b4:	63 e0       	ldi	r22, 0x03	; 3
    15b6:	81 e0       	ldi	r24, 0x01	; 1
    15b8:	0e 94 d5 00 	call	0x1aa	; 0x1aa <DIO_SetPin_Dir>
    15bc:	08 95       	ret

000015be <PWM0_Gen>:
    15be:	cf 92       	push	r12
    15c0:	df 92       	push	r13
    15c2:	ef 92       	push	r14
    15c4:	ff 92       	push	r15
    15c6:	6b 01       	movw	r12, r22
    15c8:	7c 01       	movw	r14, r24
    15ca:	20 e0       	ldi	r18, 0x00	; 0
    15cc:	30 e0       	ldi	r19, 0x00	; 0
    15ce:	a9 01       	movw	r20, r18
    15d0:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__cmpsf2>
    15d4:	88 23       	and	r24, r24
    15d6:	5c f0       	brlt	.+22     	; 0x15ee <PWM0_Gen+0x30>
    15d8:	20 e0       	ldi	r18, 0x00	; 0
    15da:	30 e0       	ldi	r19, 0x00	; 0
    15dc:	48 ec       	ldi	r20, 0xC8	; 200
    15de:	52 e4       	ldi	r21, 0x42	; 66
    15e0:	c7 01       	movw	r24, r14
    15e2:	b6 01       	movw	r22, r12
    15e4:	0e 94 d2 19 	call	0x33a4	; 0x33a4 <__gesf2>
    15e8:	18 16       	cp	r1, r24
    15ea:	2c f0       	brlt	.+10     	; 0x15f6 <PWM0_Gen+0x38>
    15ec:	0c c0       	rjmp	.+24     	; 0x1606 <PWM0_Gen+0x48>
    15ee:	c1 2c       	mov	r12, r1
    15f0:	d1 2c       	mov	r13, r1
    15f2:	76 01       	movw	r14, r12
    15f4:	08 c0       	rjmp	.+16     	; 0x1606 <PWM0_Gen+0x48>
    15f6:	0f 2e       	mov	r0, r31
    15f8:	c1 2c       	mov	r12, r1
    15fa:	d1 2c       	mov	r13, r1
    15fc:	f8 ec       	ldi	r31, 0xC8	; 200
    15fe:	ef 2e       	mov	r14, r31
    1600:	f2 e4       	ldi	r31, 0x42	; 66
    1602:	ff 2e       	mov	r15, r31
    1604:	f0 2d       	mov	r31, r0
    1606:	20 e0       	ldi	r18, 0x00	; 0
    1608:	30 e0       	ldi	r19, 0x00	; 0
    160a:	4f e7       	ldi	r20, 0x7F	; 127
    160c:	53 e4       	ldi	r21, 0x43	; 67
    160e:	c7 01       	movw	r24, r14
    1610:	b6 01       	movw	r22, r12
    1612:	0e 94 d7 19 	call	0x33ae	; 0x33ae <__mulsf3>
    1616:	20 e0       	ldi	r18, 0x00	; 0
    1618:	30 e0       	ldi	r19, 0x00	; 0
    161a:	48 ec       	ldi	r20, 0xC8	; 200
    161c:	52 e4       	ldi	r21, 0x42	; 66
    161e:	0e 94 7f 18 	call	0x30fe	; 0x30fe <__divsf3>
    1622:	0e 94 f1 18 	call	0x31e2	; 0x31e2 <__fixunssfsi>
    1626:	6c bf       	out	0x3c, r22	; 60
    1628:	ff 90       	pop	r15
    162a:	ef 90       	pop	r14
    162c:	df 90       	pop	r13
    162e:	cf 90       	pop	r12
    1630:	08 95       	ret

00001632 <Timer0_Start>:
    1632:	83 b7       	in	r24, 0x33	; 51
    1634:	88 7f       	andi	r24, 0xF8	; 248
    1636:	85 60       	ori	r24, 0x05	; 5
    1638:	83 bf       	out	0x33, r24	; 51
    163a:	08 95       	ret

0000163c <__vector_11>:
    163c:	1f 92       	push	r1
    163e:	0f 92       	push	r0
    1640:	0f b6       	in	r0, 0x3f	; 63
    1642:	0f 92       	push	r0
    1644:	11 24       	eor	r1, r1
    1646:	4f 93       	push	r20
    1648:	5f 93       	push	r21
    164a:	6f 93       	push	r22
    164c:	7f 93       	push	r23
    164e:	8f 93       	push	r24
    1650:	9f 93       	push	r25
    1652:	af 93       	push	r26
    1654:	bf 93       	push	r27
    1656:	80 91 3f 07 	lds	r24, 0x073F	; 0x80073f <Count.1709>
    165a:	90 91 40 07 	lds	r25, 0x0740	; 0x800740 <Count.1709+0x1>
    165e:	a0 91 41 07 	lds	r26, 0x0741	; 0x800741 <Count.1709+0x2>
    1662:	b0 91 42 07 	lds	r27, 0x0742	; 0x800742 <Count.1709+0x3>
    1666:	01 96       	adiw	r24, 0x01	; 1
    1668:	a1 1d       	adc	r26, r1
    166a:	b1 1d       	adc	r27, r1
    166c:	80 93 3f 07 	sts	0x073F, r24	; 0x80073f <Count.1709>
    1670:	90 93 40 07 	sts	0x0740, r25	; 0x800740 <Count.1709+0x1>
    1674:	a0 93 41 07 	sts	0x0741, r26	; 0x800741 <Count.1709+0x2>
    1678:	b0 93 42 07 	sts	0x0742, r27	; 0x800742 <Count.1709+0x3>
    167c:	40 91 47 07 	lds	r20, 0x0747	; 0x800747 <Timer0_Num_OVF>
    1680:	50 91 48 07 	lds	r21, 0x0748	; 0x800748 <Timer0_Num_OVF+0x1>
    1684:	60 e0       	ldi	r22, 0x00	; 0
    1686:	70 e0       	ldi	r23, 0x00	; 0
    1688:	84 17       	cp	r24, r20
    168a:	95 07       	cpc	r25, r21
    168c:	a6 07       	cpc	r26, r22
    168e:	b7 07       	cpc	r27, r23
    1690:	59 f4       	brne	.+22     	; 0x16a8 <__vector_11+0x6c>
    1692:	10 92 3f 07 	sts	0x073F, r1	; 0x80073f <Count.1709>
    1696:	10 92 40 07 	sts	0x0740, r1	; 0x800740 <Count.1709+0x1>
    169a:	10 92 41 07 	sts	0x0741, r1	; 0x800741 <Count.1709+0x2>
    169e:	10 92 42 07 	sts	0x0742, r1	; 0x800742 <Count.1709+0x3>
    16a2:	80 91 46 07 	lds	r24, 0x0746	; 0x800746 <Timer0_Init_Value>
    16a6:	82 bf       	out	0x32, r24	; 50
    16a8:	bf 91       	pop	r27
    16aa:	af 91       	pop	r26
    16ac:	9f 91       	pop	r25
    16ae:	8f 91       	pop	r24
    16b0:	7f 91       	pop	r23
    16b2:	6f 91       	pop	r22
    16b4:	5f 91       	pop	r21
    16b6:	4f 91       	pop	r20
    16b8:	0f 90       	pop	r0
    16ba:	0f be       	out	0x3f, r0	; 63
    16bc:	0f 90       	pop	r0
    16be:	1f 90       	pop	r1
    16c0:	18 95       	reti

000016c2 <__vector_10>:
    16c2:	1f 92       	push	r1
    16c4:	0f 92       	push	r0
    16c6:	0f b6       	in	r0, 0x3f	; 63
    16c8:	0f 92       	push	r0
    16ca:	11 24       	eor	r1, r1
    16cc:	4f 93       	push	r20
    16ce:	5f 93       	push	r21
    16d0:	6f 93       	push	r22
    16d2:	7f 93       	push	r23
    16d4:	8f 93       	push	r24
    16d6:	9f 93       	push	r25
    16d8:	af 93       	push	r26
    16da:	bf 93       	push	r27
    16dc:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <Count.1715>
    16e0:	90 91 3c 07 	lds	r25, 0x073C	; 0x80073c <Count.1715+0x1>
    16e4:	a0 91 3d 07 	lds	r26, 0x073D	; 0x80073d <Count.1715+0x2>
    16e8:	b0 91 3e 07 	lds	r27, 0x073E	; 0x80073e <Count.1715+0x3>
    16ec:	01 96       	adiw	r24, 0x01	; 1
    16ee:	a1 1d       	adc	r26, r1
    16f0:	b1 1d       	adc	r27, r1
    16f2:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <Count.1715>
    16f6:	90 93 3c 07 	sts	0x073C, r25	; 0x80073c <Count.1715+0x1>
    16fa:	a0 93 3d 07 	sts	0x073D, r26	; 0x80073d <Count.1715+0x2>
    16fe:	b0 93 3e 07 	sts	0x073E, r27	; 0x80073e <Count.1715+0x3>
    1702:	81 30       	cpi	r24, 0x01	; 1
    1704:	91 05       	cpc	r25, r1
    1706:	a1 05       	cpc	r26, r1
    1708:	b1 05       	cpc	r27, r1
    170a:	b9 f4       	brne	.+46     	; 0x173a <__vector_10+0x78>
    170c:	40 91 47 07 	lds	r20, 0x0747	; 0x800747 <Timer0_Num_OVF>
    1710:	50 91 48 07 	lds	r21, 0x0748	; 0x800748 <Timer0_Num_OVF+0x1>
    1714:	60 e0       	ldi	r22, 0x00	; 0
    1716:	70 e0       	ldi	r23, 0x00	; 0
    1718:	84 17       	cp	r24, r20
    171a:	95 07       	cpc	r25, r21
    171c:	a6 07       	cpc	r26, r22
    171e:	b7 07       	cpc	r27, r23
    1720:	61 f4       	brne	.+24     	; 0x173a <__vector_10+0x78>
    1722:	10 92 3b 07 	sts	0x073B, r1	; 0x80073b <Count.1715>
    1726:	10 92 3c 07 	sts	0x073C, r1	; 0x80073c <Count.1715+0x1>
    172a:	10 92 3d 07 	sts	0x073D, r1	; 0x80073d <Count.1715+0x2>
    172e:	10 92 3e 07 	sts	0x073E, r1	; 0x80073e <Count.1715+0x3>
    1732:	80 91 46 07 	lds	r24, 0x0746	; 0x800746 <Timer0_Init_Value>
    1736:	8c bf       	out	0x3c, r24	; 60
    1738:	1e c0       	rjmp	.+60     	; 0x1776 <__vector_10+0xb4>
    173a:	81 30       	cpi	r24, 0x01	; 1
    173c:	91 05       	cpc	r25, r1
    173e:	a1 05       	cpc	r26, r1
    1740:	b1 05       	cpc	r27, r1
    1742:	19 f4       	brne	.+6      	; 0x174a <__vector_10+0x88>
    1744:	8f ef       	ldi	r24, 0xFF	; 255
    1746:	8c bf       	out	0x3c, r24	; 60
    1748:	16 c0       	rjmp	.+44     	; 0x1776 <__vector_10+0xb4>
    174a:	40 91 47 07 	lds	r20, 0x0747	; 0x800747 <Timer0_Num_OVF>
    174e:	50 91 48 07 	lds	r21, 0x0748	; 0x800748 <Timer0_Num_OVF+0x1>
    1752:	60 e0       	ldi	r22, 0x00	; 0
    1754:	70 e0       	ldi	r23, 0x00	; 0
    1756:	84 17       	cp	r24, r20
    1758:	95 07       	cpc	r25, r21
    175a:	a6 07       	cpc	r26, r22
    175c:	b7 07       	cpc	r27, r23
    175e:	59 f4       	brne	.+22     	; 0x1776 <__vector_10+0xb4>
    1760:	10 92 3b 07 	sts	0x073B, r1	; 0x80073b <Count.1715>
    1764:	10 92 3c 07 	sts	0x073C, r1	; 0x80073c <Count.1715+0x1>
    1768:	10 92 3d 07 	sts	0x073D, r1	; 0x80073d <Count.1715+0x2>
    176c:	10 92 3e 07 	sts	0x073E, r1	; 0x80073e <Count.1715+0x3>
    1770:	80 91 46 07 	lds	r24, 0x0746	; 0x800746 <Timer0_Init_Value>
    1774:	8c bf       	out	0x3c, r24	; 60
    1776:	bf 91       	pop	r27
    1778:	af 91       	pop	r26
    177a:	9f 91       	pop	r25
    177c:	8f 91       	pop	r24
    177e:	7f 91       	pop	r23
    1780:	6f 91       	pop	r22
    1782:	5f 91       	pop	r21
    1784:	4f 91       	pop	r20
    1786:	0f 90       	pop	r0
    1788:	0f be       	out	0x3f, r0	; 63
    178a:	0f 90       	pop	r0
    178c:	1f 90       	pop	r1
    178e:	18 95       	reti

00001790 <Timer2_SetDelay>:
    1790:	08 95       	ret

00001792 <Timer2_Start>:
    1792:	85 b5       	in	r24, 0x25	; 37
    1794:	87 60       	ori	r24, 0x07	; 7
    1796:	85 bd       	out	0x25, r24	; 37
    1798:	08 95       	ret

0000179a <Timer2_Stop>:
    179a:	85 b5       	in	r24, 0x25	; 37
    179c:	88 7f       	andi	r24, 0xF8	; 248
    179e:	85 bd       	out	0x25, r24	; 37
    17a0:	08 95       	ret

000017a2 <__vector_5>:

ISR(TIMER2_OVF_vect)
{
    17a2:	1f 92       	push	r1
    17a4:	0f 92       	push	r0
    17a6:	0f b6       	in	r0, 0x3f	; 63
    17a8:	0f 92       	push	r0
    17aa:	11 24       	eor	r1, r1
    17ac:	2f 93       	push	r18
    17ae:	3f 93       	push	r19
    17b0:	4f 93       	push	r20
    17b2:	5f 93       	push	r21
    17b4:	6f 93       	push	r22
    17b6:	7f 93       	push	r23
    17b8:	8f 93       	push	r24
    17ba:	9f 93       	push	r25
    17bc:	af 93       	push	r26
    17be:	bf 93       	push	r27
    17c0:	ef 93       	push	r30
    17c2:	ff 93       	push	r31
	static Uint32 Count = 0;
	Count++;
    17c4:	80 91 37 07 	lds	r24, 0x0737	; 0x800737 <Count.1759>
    17c8:	90 91 38 07 	lds	r25, 0x0738	; 0x800738 <Count.1759+0x1>
    17cc:	a0 91 39 07 	lds	r26, 0x0739	; 0x800739 <Count.1759+0x2>
    17d0:	b0 91 3a 07 	lds	r27, 0x073A	; 0x80073a <Count.1759+0x3>
    17d4:	01 96       	adiw	r24, 0x01	; 1
    17d6:	a1 1d       	adc	r26, r1
    17d8:	b1 1d       	adc	r27, r1
    17da:	80 93 37 07 	sts	0x0737, r24	; 0x800737 <Count.1759>
    17de:	90 93 38 07 	sts	0x0738, r25	; 0x800738 <Count.1759+0x1>
    17e2:	a0 93 39 07 	sts	0x0739, r26	; 0x800739 <Count.1759+0x2>
    17e6:	b0 93 3a 07 	sts	0x073A, r27	; 0x80073a <Count.1759+0x3>
	if(Timer2_Num_OVF == Count)
    17ea:	40 91 44 07 	lds	r20, 0x0744	; 0x800744 <Timer2_Num_OVF>
    17ee:	50 91 45 07 	lds	r21, 0x0745	; 0x800745 <Timer2_Num_OVF+0x1>
    17f2:	60 e0       	ldi	r22, 0x00	; 0
    17f4:	70 e0       	ldi	r23, 0x00	; 0
    17f6:	84 17       	cp	r24, r20
    17f8:	95 07       	cpc	r25, r21
    17fa:	a6 07       	cpc	r26, r22
    17fc:	b7 07       	cpc	r27, r23
    17fe:	a1 f4       	brne	.+40     	; 0x1828 <__vector_5+0x86>
	{
		// Write OVF of Timer_2 handler here
		if(!eme_check)
    1800:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1804:	81 11       	cpse	r24, r1
    1806:	03 c0       	rjmp	.+6      	; 0x180e <__vector_5+0x6c>
			LCD_Clear();
    1808:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
    180c:	02 c0       	rjmp	.+4      	; 0x1812 <__vector_5+0x70>
		else
			Timer2_Stop();
    180e:	0e 94 cd 0b 	call	0x179a	; 0x179a <Timer2_Stop>
					
		Count = 0;
    1812:	10 92 37 07 	sts	0x0737, r1	; 0x800737 <Count.1759>
    1816:	10 92 38 07 	sts	0x0738, r1	; 0x800738 <Count.1759+0x1>
    181a:	10 92 39 07 	sts	0x0739, r1	; 0x800739 <Count.1759+0x2>
    181e:	10 92 3a 07 	sts	0x073A, r1	; 0x80073a <Count.1759+0x3>
		TCNT2 = Timer2_Init_Value;
    1822:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <Timer2_Init_Value>
    1826:	84 bd       	out	0x24, r24	; 36
	}
	
}
    1828:	ff 91       	pop	r31
    182a:	ef 91       	pop	r30
    182c:	bf 91       	pop	r27
    182e:	af 91       	pop	r26
    1830:	9f 91       	pop	r25
    1832:	8f 91       	pop	r24
    1834:	7f 91       	pop	r23
    1836:	6f 91       	pop	r22
    1838:	5f 91       	pop	r21
    183a:	4f 91       	pop	r20
    183c:	3f 91       	pop	r19
    183e:	2f 91       	pop	r18
    1840:	0f 90       	pop	r0
    1842:	0f be       	out	0x3f, r0	; 63
    1844:	0f 90       	pop	r0
    1846:	1f 90       	pop	r1
    1848:	18 95       	reti

0000184a <__vector_4>:

ISR(TIMER2_COMP_vect)
{
    184a:	1f 92       	push	r1
    184c:	0f 92       	push	r0
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	0f 92       	push	r0
    1852:	11 24       	eor	r1, r1
    1854:	4f 93       	push	r20
    1856:	5f 93       	push	r21
    1858:	6f 93       	push	r22
    185a:	7f 93       	push	r23
    185c:	8f 93       	push	r24
    185e:	9f 93       	push	r25
    1860:	af 93       	push	r26
    1862:	bf 93       	push	r27
	static Uint32 Count = 0;
	Count++;
    1864:	80 91 33 07 	lds	r24, 0x0733	; 0x800733 <Count.1765>
    1868:	90 91 34 07 	lds	r25, 0x0734	; 0x800734 <Count.1765+0x1>
    186c:	a0 91 35 07 	lds	r26, 0x0735	; 0x800735 <Count.1765+0x2>
    1870:	b0 91 36 07 	lds	r27, 0x0736	; 0x800736 <Count.1765+0x3>
    1874:	01 96       	adiw	r24, 0x01	; 1
    1876:	a1 1d       	adc	r26, r1
    1878:	b1 1d       	adc	r27, r1
    187a:	80 93 33 07 	sts	0x0733, r24	; 0x800733 <Count.1765>
    187e:	90 93 34 07 	sts	0x0734, r25	; 0x800734 <Count.1765+0x1>
    1882:	a0 93 35 07 	sts	0x0735, r26	; 0x800735 <Count.1765+0x2>
    1886:	b0 93 36 07 	sts	0x0736, r27	; 0x800736 <Count.1765+0x3>
	if(Count == 1 && Timer2_Num_OVF == Count)
    188a:	81 30       	cpi	r24, 0x01	; 1
    188c:	91 05       	cpc	r25, r1
    188e:	a1 05       	cpc	r26, r1
    1890:	b1 05       	cpc	r27, r1
    1892:	b9 f4       	brne	.+46     	; 0x18c2 <__vector_4+0x78>
    1894:	40 91 44 07 	lds	r20, 0x0744	; 0x800744 <Timer2_Num_OVF>
    1898:	50 91 45 07 	lds	r21, 0x0745	; 0x800745 <Timer2_Num_OVF+0x1>
    189c:	60 e0       	ldi	r22, 0x00	; 0
    189e:	70 e0       	ldi	r23, 0x00	; 0
    18a0:	84 17       	cp	r24, r20
    18a2:	95 07       	cpc	r25, r21
    18a4:	a6 07       	cpc	r26, r22
    18a6:	b7 07       	cpc	r27, r23
    18a8:	61 f4       	brne	.+24     	; 0x18c2 <__vector_4+0x78>
	{
		// Write CMP of Timer_2 handler here
		
		
		Count = 0;
    18aa:	10 92 33 07 	sts	0x0733, r1	; 0x800733 <Count.1765>
    18ae:	10 92 34 07 	sts	0x0734, r1	; 0x800734 <Count.1765+0x1>
    18b2:	10 92 35 07 	sts	0x0735, r1	; 0x800735 <Count.1765+0x2>
    18b6:	10 92 36 07 	sts	0x0736, r1	; 0x800736 <Count.1765+0x3>
		OCR2 = Timer2_Init_Value;
    18ba:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <Timer2_Init_Value>
    18be:	83 bd       	out	0x23, r24	; 35
    18c0:	1e c0       	rjmp	.+60     	; 0x18fe <__vector_4+0xb4>
	}
	else if(Count == 1)
    18c2:	81 30       	cpi	r24, 0x01	; 1
    18c4:	91 05       	cpc	r25, r1
    18c6:	a1 05       	cpc	r26, r1
    18c8:	b1 05       	cpc	r27, r1
    18ca:	19 f4       	brne	.+6      	; 0x18d2 <__vector_4+0x88>
	OCR2 = 255;
    18cc:	8f ef       	ldi	r24, 0xFF	; 255
    18ce:	83 bd       	out	0x23, r24	; 35
    18d0:	16 c0       	rjmp	.+44     	; 0x18fe <__vector_4+0xb4>
	else if(Timer2_Num_OVF == Count)
    18d2:	40 91 44 07 	lds	r20, 0x0744	; 0x800744 <Timer2_Num_OVF>
    18d6:	50 91 45 07 	lds	r21, 0x0745	; 0x800745 <Timer2_Num_OVF+0x1>
    18da:	60 e0       	ldi	r22, 0x00	; 0
    18dc:	70 e0       	ldi	r23, 0x00	; 0
    18de:	84 17       	cp	r24, r20
    18e0:	95 07       	cpc	r25, r21
    18e2:	a6 07       	cpc	r26, r22
    18e4:	b7 07       	cpc	r27, r23
    18e6:	59 f4       	brne	.+22     	; 0x18fe <__vector_4+0xb4>
	{
		// Write CMP of Timer_2 handler here
		
		
		Count = 0;
    18e8:	10 92 33 07 	sts	0x0733, r1	; 0x800733 <Count.1765>
    18ec:	10 92 34 07 	sts	0x0734, r1	; 0x800734 <Count.1765+0x1>
    18f0:	10 92 35 07 	sts	0x0735, r1	; 0x800735 <Count.1765+0x2>
    18f4:	10 92 36 07 	sts	0x0736, r1	; 0x800736 <Count.1765+0x3>
		OCR2 = Timer2_Init_Value;
    18f8:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <Timer2_Init_Value>
    18fc:	83 bd       	out	0x23, r24	; 35
	}
}
    18fe:	bf 91       	pop	r27
    1900:	af 91       	pop	r26
    1902:	9f 91       	pop	r25
    1904:	8f 91       	pop	r24
    1906:	7f 91       	pop	r23
    1908:	6f 91       	pop	r22
    190a:	5f 91       	pop	r21
    190c:	4f 91       	pop	r20
    190e:	0f 90       	pop	r0
    1910:	0f be       	out	0x3f, r0	; 63
    1912:	0f 90       	pop	r0
    1914:	1f 90       	pop	r1
    1916:	18 95       	reti

00001918 <UART_TX_Char>:
    UBRRH = (UART_Baud_Rate >> 8);
}

void UART_TX_Char(Uint8 data) {
    // Sending Data
    UDR = data;
    1918:	8c b9       	out	0x0c, r24	; 12

    // Checking the data is sent
    while (!Get_Bit(UCSRA, 5));
    191a:	5d 9b       	sbis	0x0b, 5	; 11
    191c:	fe cf       	rjmp	.-4      	; 0x191a <UART_TX_Char+0x2>
}
    191e:	08 95       	ret

00001920 <UART_TX_Str>:

void UART_TX_Str(Uint8 * str) {
    1920:	0f 93       	push	r16
    1922:	1f 93       	push	r17
    1924:	cf 93       	push	r28
    1926:	8c 01       	movw	r16, r24
    for (Uint8 i = 0; str[i] != '\n'; i++) {
    1928:	c0 e0       	ldi	r28, 0x00	; 0
    192a:	03 c0       	rjmp	.+6      	; 0x1932 <UART_TX_Str+0x12>
        UART_TX_Char(str[i]);
    192c:	0e 94 8c 0c 	call	0x1918	; 0x1918 <UART_TX_Char>
    // Checking the data is sent
    while (!Get_Bit(UCSRA, 5));
}

void UART_TX_Str(Uint8 * str) {
    for (Uint8 i = 0; str[i] != '\n'; i++) {
    1930:	cf 5f       	subi	r28, 0xFF	; 255
    1932:	f8 01       	movw	r30, r16
    1934:	ec 0f       	add	r30, r28
    1936:	f1 1d       	adc	r31, r1
    1938:	80 81       	ld	r24, Z
    193a:	8a 30       	cpi	r24, 0x0A	; 10
    193c:	b9 f7       	brne	.-18     	; 0x192c <UART_TX_Str+0xc>
        UART_TX_Char(str[i]);
    }
}
    193e:	cf 91       	pop	r28
    1940:	1f 91       	pop	r17
    1942:	0f 91       	pop	r16
    1944:	08 95       	ret

00001946 <UART_RX_Char>:
Uint8 UART_RX_Char(void) {
	// Receiving data 
    Uint8 Value = 0;
	
	// Checking the data is received 
    while (!Get_Bit(UCSRA, 5));
    1946:	5d 9b       	sbis	0x0b, 5	; 11
    1948:	fe cf       	rjmp	.-4      	; 0x1946 <UART_RX_Char>
	
	// Storing the data received in a variable
    Value = UDR;
    194a:	8c b1       	in	r24, 0x0c	; 12
    return Value;
}
    194c:	08 95       	ret

0000194e <__vector_13>:

ISR(USART_RXC_vect) {
    194e:	1f 92       	push	r1
    1950:	0f 92       	push	r0
    1952:	0f b6       	in	r0, 0x3f	; 63
    1954:	0f 92       	push	r0
    1956:	11 24       	eor	r1, r1
    1958:	4f 92       	push	r4
    195a:	5f 92       	push	r5
    195c:	6f 92       	push	r6
    195e:	7f 92       	push	r7
    1960:	8f 92       	push	r8
    1962:	9f 92       	push	r9
    1964:	af 92       	push	r10
    1966:	bf 92       	push	r11
    1968:	cf 92       	push	r12
    196a:	df 92       	push	r13
    196c:	ef 92       	push	r14
    196e:	ff 92       	push	r15
    1970:	0f 93       	push	r16
    1972:	1f 93       	push	r17
    1974:	2f 93       	push	r18
    1976:	3f 93       	push	r19
    1978:	4f 93       	push	r20
    197a:	5f 93       	push	r21
    197c:	6f 93       	push	r22
    197e:	7f 93       	push	r23
    1980:	8f 93       	push	r24
    1982:	9f 93       	push	r25
    1984:	af 93       	push	r26
    1986:	bf 93       	push	r27
    1988:	ef 93       	push	r30
    198a:	ff 93       	push	r31
    198c:	cf 93       	push	r28
    198e:	df 93       	push	r29
    1990:	cd b7       	in	r28, 0x3d	; 61
    1992:	de b7       	in	r29, 0x3e	; 62
    1994:	2a 97       	sbiw	r28, 0x0a	; 10
    1996:	de bf       	out	0x3e, r29	; 62
    1998:	cd bf       	out	0x3d, r28	; 61
	// Write UART receive handler here
	/*---------> Where all the UART system work <---------*/
	
	// Initialization of local arrays used for taking username and password of any user
    Uint8 User[4] = {
    199a:	19 82       	std	Y+1, r1	; 0x01
    199c:	1a 82       	std	Y+2, r1	; 0x02
    199e:	1b 82       	std	Y+3, r1	; 0x03
    19a0:	1c 82       	std	Y+4, r1	; 0x04
        0
    };
    Uint8 Pass[4] = {
    19a2:	1d 82       	std	Y+5, r1	; 0x05
    19a4:	1e 82       	std	Y+6, r1	; 0x06
    19a6:	1f 82       	std	Y+7, r1	; 0x07
    19a8:	18 86       	std	Y+8, r1	; 0x08
        0
    };

	// if the there is no keypad user start the timer that clear LCD if there is keypad user don't clear the LCD 
    if (!eme_check)
    19aa:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    19ae:	81 11       	cpse	r24, r1
    19b0:	02 c0       	rjmp	.+4      	; 0x19b6 <__vector_13+0x68>
        Timer2_Start();
    19b2:	0e 94 c9 0b 	call	0x1792	; 0x1792 <Timer2_Start>
	
	// For login the system where SYS_Check value is 0 	
    if (!SYS_Check) {
    19b6:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <SYS_Check>
    19ba:	81 11       	cpse	r24, r1
    19bc:	07 c2       	rjmp	.+1038   	; 0x1dcc <__vector_13+0x47e>
		while (!Get_Bit(UCSRA, 7));	// Polling until the user enter a character
    19be:	5f 9b       	sbis	0x0b, 7	; 11
    19c0:	fe cf       	rjmp	.-4      	; 0x19be <__vector_13+0x70>
		A_U_Check = UDR; // Receiving the character 
    19c2:	8c b1       	in	r24, 0x0c	; 12
    19c4:	80 93 53 07 	sts	0x0753, r24	; 0x800753 <A_U_Check>
		
		// 3 times for login if the user exceed 3 times the alarm will fire
        for (Uint8 i = 0; i < 3; i++) {
    19c8:	91 2c       	mov	r9, r1
    19ca:	fc c1       	rjmp	.+1016   	; 0x1dc4 <__vector_13+0x476>
			// Login as admin
            if (A_U_Check == '1') {
    19cc:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <A_U_Check>
    19d0:	81 33       	cpi	r24, 0x31	; 49
    19d2:	09 f0       	breq	.+2      	; 0x19d6 <__vector_13+0x88>
    19d4:	e2 c0       	rjmp	.+452    	; 0x1b9a <__vector_13+0x24c>
                // Admin enter the system
                /*------------->Entering Username<-------------*/
                UART_TX_Str("\r\n");
    19d6:	8d e0       	ldi	r24, 0x0D	; 13
    19d8:	92 e0       	ldi	r25, 0x02	; 2
    19da:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
				UART_TX_Str("\r\n");
    19de:	8d e0       	ldi	r24, 0x0D	; 13
    19e0:	92 e0       	ldi	r25, 0x02	; 2
    19e2:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter your username\r\n");
    19e6:	8e eb       	ldi	r24, 0xBE	; 190
    19e8:	91 e0       	ldi	r25, 0x01	; 1
    19ea:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    19ee:	8d e0       	ldi	r24, 0x0D	; 13
    19f0:	92 e0       	ldi	r25, 0x02	; 2
    19f2:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

                for (Uint8 i = 0; i < 4; i++) {
    19f6:	10 e0       	ldi	r17, 0x00	; 0
    19f8:	0e c0       	rjmp	.+28     	; 0x1a16 <__vector_13+0xc8>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    19fa:	5f 9b       	sbis	0x0b, 7	; 11
    19fc:	fe cf       	rjmp	.-4      	; 0x19fa <__vector_13+0xac>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
    19fe:	e1 2e       	mov	r14, r17
    1a00:	f1 2c       	mov	r15, r1
    1a02:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    1a06:	e1 e0       	ldi	r30, 0x01	; 1
    1a08:	f0 e0       	ldi	r31, 0x00	; 0
    1a0a:	ec 0f       	add	r30, r28
    1a0c:	fd 1f       	adc	r31, r29
    1a0e:	ee 0d       	add	r30, r14
    1a10:	ff 1d       	adc	r31, r15
    1a12:	80 83       	st	Z, r24
                UART_TX_Str("\r\n");
				UART_TX_Str("\r\n");
                UART_TX_Str("Please enter your username\r\n");
                UART_TX_Str("\r\n");

                for (Uint8 i = 0; i < 4; i++) {
    1a14:	1f 5f       	subi	r17, 0xFF	; 255
    1a16:	14 30       	cpi	r17, 0x04	; 4
    1a18:	80 f3       	brcs	.-32     	; 0x19fa <__vector_13+0xac>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                    User[i] = UART_RX_Char(); // Receiving the character in username array
                }

                /*------------->Entering Password<-------------*/
                UART_TX_Str("\r\n");
    1a1a:	8d e0       	ldi	r24, 0x0D	; 13
    1a1c:	92 e0       	ldi	r25, 0x02	; 2
    1a1e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1a22:	8d e0       	ldi	r24, 0x0D	; 13
    1a24:	92 e0       	ldi	r25, 0x02	; 2
    1a26:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter your password\r\n");
    1a2a:	8b ed       	ldi	r24, 0xDB	; 219
    1a2c:	91 e0       	ldi	r25, 0x01	; 1
    1a2e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1a32:	8d e0       	ldi	r24, 0x0D	; 13
    1a34:	92 e0       	ldi	r25, 0x02	; 2
    1a36:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

                for (Uint8 i = 0; i < 4; i++) {
    1a3a:	10 e0       	ldi	r17, 0x00	; 0
    1a3c:	0e c0       	rjmp	.+28     	; 0x1a5a <__vector_13+0x10c>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    1a3e:	5f 9b       	sbis	0x0b, 7	; 11
    1a40:	fe cf       	rjmp	.-4      	; 0x1a3e <__vector_13+0xf0>
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
    1a42:	e1 2e       	mov	r14, r17
    1a44:	f1 2c       	mov	r15, r1
    1a46:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    1a4a:	e5 e0       	ldi	r30, 0x05	; 5
    1a4c:	f0 e0       	ldi	r31, 0x00	; 0
    1a4e:	ec 0f       	add	r30, r28
    1a50:	fd 1f       	adc	r31, r29
    1a52:	ee 0d       	add	r30, r14
    1a54:	ff 1d       	adc	r31, r15
    1a56:	80 83       	st	Z, r24
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter your password\r\n");
                UART_TX_Str("\r\n");

                for (Uint8 i = 0; i < 4; i++) {
    1a58:	1f 5f       	subi	r17, 0xFF	; 255
    1a5a:	14 30       	cpi	r17, 0x04	; 4
    1a5c:	80 f3       	brcs	.-32     	; 0x1a3e <__vector_13+0xf0>
    1a5e:	81 2c       	mov	r8, r1
    1a60:	82 c0       	rjmp	.+260    	; 0x1b66 <__vector_13+0x218>

                /*---------------> Checking Username & Password<---------------*/

                for (Uint8 Check_Counter = 0; Check_Counter <= AD_Counter; Check_Counter += 4) {
                    /*----------------->Username Check<------------------*/
                    if (User[0] == EEPROM_ReadByte(5, Check_Counter + 1) && User[1] == EEPROM_ReadByte(5, Check_Counter + 2) && User[2] == EEPROM_ReadByte(5, Check_Counter + 3) && User[3] == EEPROM_ReadByte(5, Check_Counter + 4)) {
    1a62:	c9 80       	ldd	r12, Y+1	; 0x01
    1a64:	d1 2c       	mov	r13, r1
    1a66:	08 2d       	mov	r16, r8
    1a68:	10 e0       	ldi	r17, 0x00	; 0
    1a6a:	78 01       	movw	r14, r16
    1a6c:	8f ef       	ldi	r24, 0xFF	; 255
    1a6e:	e8 1a       	sub	r14, r24
    1a70:	f8 0a       	sbc	r15, r24
    1a72:	b7 01       	movw	r22, r14
    1a74:	85 e0       	ldi	r24, 0x05	; 5
    1a76:	90 e0       	ldi	r25, 0x00	; 0
    1a78:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1a7c:	c8 16       	cp	r12, r24
    1a7e:	d9 06       	cpc	r13, r25
    1a80:	09 f0       	breq	.+2      	; 0x1a84 <__vector_13+0x136>
    1a82:	6f c0       	rjmp	.+222    	; 0x1b62 <__vector_13+0x214>
    1a84:	ca 80       	ldd	r12, Y+2	; 0x02
    1a86:	d1 2c       	mov	r13, r1
    1a88:	38 01       	movw	r6, r16
    1a8a:	82 e0       	ldi	r24, 0x02	; 2
    1a8c:	68 0e       	add	r6, r24
    1a8e:	71 1c       	adc	r7, r1
    1a90:	b3 01       	movw	r22, r6
    1a92:	85 e0       	ldi	r24, 0x05	; 5
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1a9a:	c8 16       	cp	r12, r24
    1a9c:	d9 06       	cpc	r13, r25
    1a9e:	09 f0       	breq	.+2      	; 0x1aa2 <__vector_13+0x154>
    1aa0:	60 c0       	rjmp	.+192    	; 0x1b62 <__vector_13+0x214>
    1aa2:	ab 80       	ldd	r10, Y+3	; 0x03
    1aa4:	b1 2c       	mov	r11, r1
    1aa6:	68 01       	movw	r12, r16
    1aa8:	83 e0       	ldi	r24, 0x03	; 3
    1aaa:	c8 0e       	add	r12, r24
    1aac:	d1 1c       	adc	r13, r1
    1aae:	b6 01       	movw	r22, r12
    1ab0:	85 e0       	ldi	r24, 0x05	; 5
    1ab2:	90 e0       	ldi	r25, 0x00	; 0
    1ab4:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1ab8:	a8 16       	cp	r10, r24
    1aba:	b9 06       	cpc	r11, r25
    1abc:	09 f0       	breq	.+2      	; 0x1ac0 <__vector_13+0x172>
    1abe:	51 c0       	rjmp	.+162    	; 0x1b62 <__vector_13+0x214>
    1ac0:	ac 80       	ldd	r10, Y+4	; 0x04
    1ac2:	b1 2c       	mov	r11, r1
    1ac4:	0c 5f       	subi	r16, 0xFC	; 252
    1ac6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ac8:	b8 01       	movw	r22, r16
    1aca:	85 e0       	ldi	r24, 0x05	; 5
    1acc:	90 e0       	ldi	r25, 0x00	; 0
    1ace:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1ad2:	a8 16       	cp	r10, r24
    1ad4:	b9 06       	cpc	r11, r25
    1ad6:	09 f0       	breq	.+2      	; 0x1ada <__vector_13+0x18c>
    1ad8:	44 c0       	rjmp	.+136    	; 0x1b62 <__vector_13+0x214>
                        /*----------------->Password Check<------------------*/

                        if (Pass[0] == EEPROM_ReadByte(6, Check_Counter + 1) && Pass[1] == EEPROM_ReadByte(6, Check_Counter + 2) && Pass[2] == EEPROM_ReadByte(6, Check_Counter + 3) && Pass[3] == EEPROM_ReadByte(6, Check_Counter + 4)) {
    1ada:	ad 80       	ldd	r10, Y+5	; 0x05
    1adc:	b1 2c       	mov	r11, r1
    1ade:	b7 01       	movw	r22, r14
    1ae0:	86 e0       	ldi	r24, 0x06	; 6
    1ae2:	90 e0       	ldi	r25, 0x00	; 0
    1ae4:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1ae8:	a8 16       	cp	r10, r24
    1aea:	b9 06       	cpc	r11, r25
    1aec:	d1 f5       	brne	.+116    	; 0x1b62 <__vector_13+0x214>
    1aee:	ee 80       	ldd	r14, Y+6	; 0x06
    1af0:	f1 2c       	mov	r15, r1
    1af2:	b3 01       	movw	r22, r6
    1af4:	86 e0       	ldi	r24, 0x06	; 6
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1afc:	e8 16       	cp	r14, r24
    1afe:	f9 06       	cpc	r15, r25
    1b00:	81 f5       	brne	.+96     	; 0x1b62 <__vector_13+0x214>
    1b02:	ef 80       	ldd	r14, Y+7	; 0x07
    1b04:	f1 2c       	mov	r15, r1
    1b06:	b6 01       	movw	r22, r12
    1b08:	86 e0       	ldi	r24, 0x06	; 6
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1b10:	e8 16       	cp	r14, r24
    1b12:	f9 06       	cpc	r15, r25
    1b14:	31 f5       	brne	.+76     	; 0x1b62 <__vector_13+0x214>
    1b16:	e8 84       	ldd	r14, Y+8	; 0x08
    1b18:	f1 2c       	mov	r15, r1
    1b1a:	b8 01       	movw	r22, r16
    1b1c:	86 e0       	ldi	r24, 0x06	; 6
    1b1e:	90 e0       	ldi	r25, 0x00	; 0
    1b20:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1b24:	e8 16       	cp	r14, r24
    1b26:	f9 06       	cpc	r15, r25
    1b28:	e1 f4       	brne	.+56     	; 0x1b62 <__vector_13+0x214>
                            /*----------------->right Username & Password<-----------------*/
                            UART_TX_Str("\r\n");
    1b2a:	8d e0       	ldi	r24, 0x0D	; 13
    1b2c:	92 e0       	ldi	r25, 0x02	; 2
    1b2e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("\r\n");
    1b32:	8d e0       	ldi	r24, 0x0D	; 13
    1b34:	92 e0       	ldi	r25, 0x02	; 2
    1b36:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("Admin exist, Welcome!\r\n");
    1b3a:	88 ef       	ldi	r24, 0xF8	; 248
    1b3c:	91 e0       	ldi	r25, 0x01	; 1
    1b3e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("\r\n");
    1b42:	8d e0       	ldi	r24, 0x0D	; 13
    1b44:	92 e0       	ldi	r25, 0x02	; 2
    1b46:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            Check_Counter = AD_Counter + 1; // Exiting the Check for loop
    1b4a:	80 90 70 00 	lds	r8, 0x0070	; 0x800070 <AD_Counter>
    1b4e:	83 94       	inc	r8
                            SYS_Check = 1;	// Means that admin entered the system (Admin = 1) 
    1b50:	81 e0       	ldi	r24, 0x01	; 1
    1b52:	80 93 54 07 	sts	0x0754, r24	; 0x800754 <SYS_Check>
                            CMD_Check = 1; // *Not Important to Know* it used to not take UART_Get value variable after login the system as 0 value
    1b56:	80 93 52 07 	sts	0x0752, r24	; 0x800752 <CMD_Check>
                            i = 5;	// Exiting the Alarm for loop  
    1b5a:	0f 2e       	mov	r0, r31
    1b5c:	f5 e0       	ldi	r31, 0x05	; 5
    1b5e:	9f 2e       	mov	r9, r31
    1b60:	f0 2d       	mov	r31, r0
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
                }

                /*---------------> Checking Username & Password<---------------*/

                for (Uint8 Check_Counter = 0; Check_Counter <= AD_Counter; Check_Counter += 4) {
    1b62:	84 e0       	ldi	r24, 0x04	; 4
    1b64:	88 0e       	add	r8, r24
    1b66:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <AD_Counter>
    1b6a:	88 15       	cp	r24, r8
    1b6c:	08 f0       	brcs	.+2      	; 0x1b70 <__vector_13+0x222>
    1b6e:	79 cf       	rjmp	.-270    	; 0x1a62 <__vector_13+0x114>
                        }
                    }
                }

                /*----------------->Wrong Username or Password<-----------------*/
                if (!SYS_Check) {
    1b70:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <SYS_Check>
    1b74:	81 11       	cpse	r24, r1
    1b76:	19 c1       	rjmp	.+562    	; 0x1daa <__vector_13+0x45c>
                    UART_TX_Str("\r\n");
    1b78:	8d e0       	ldi	r24, 0x0D	; 13
    1b7a:	92 e0       	ldi	r25, 0x02	; 2
    1b7c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                    UART_TX_Str("\r\n");
    1b80:	8d e0       	ldi	r24, 0x0D	; 13
    1b82:	92 e0       	ldi	r25, 0x02	; 2
    1b84:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                    UART_TX_Str("Admin does not exist. Please try again\r\n");
    1b88:	80 e1       	ldi	r24, 0x10	; 16
    1b8a:	92 e0       	ldi	r25, 0x02	; 2
    1b8c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                    UART_TX_Str("\r\n");
    1b90:	8d e0       	ldi	r24, 0x0D	; 13
    1b92:	92 e0       	ldi	r25, 0x02	; 2
    1b94:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    1b98:	08 c1       	rjmp	.+528    	; 0x1daa <__vector_13+0x45c>
                }
				
            }
			// Login as UART user
			else if (A_U_Check == '2') {
    1b9a:	82 33       	cpi	r24, 0x32	; 50
    1b9c:	09 f0       	breq	.+2      	; 0x1ba0 <__vector_13+0x252>
    1b9e:	df c0       	rjmp	.+446    	; 0x1d5e <__vector_13+0x410>
                // PC user enter the system
                /*------------->Entering Username<-------------*/
                UART_TX_Str("\r\n");
    1ba0:	8d e0       	ldi	r24, 0x0D	; 13
    1ba2:	92 e0       	ldi	r25, 0x02	; 2
    1ba4:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter your username\r\n");
    1ba8:	8e eb       	ldi	r24, 0xBE	; 190
    1baa:	91 e0       	ldi	r25, 0x01	; 1
    1bac:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1bb0:	8d e0       	ldi	r24, 0x0D	; 13
    1bb2:	92 e0       	ldi	r25, 0x02	; 2
    1bb4:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

                for (Uint8 i = 0; i < 4; i++) {
    1bb8:	10 e0       	ldi	r17, 0x00	; 0
    1bba:	0e c0       	rjmp	.+28     	; 0x1bd8 <__vector_13+0x28a>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    1bbc:	5f 9b       	sbis	0x0b, 7	; 11
    1bbe:	fe cf       	rjmp	.-4      	; 0x1bbc <__vector_13+0x26e>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
    1bc0:	e1 2e       	mov	r14, r17
    1bc2:	f1 2c       	mov	r15, r1
    1bc4:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    1bc8:	e1 e0       	ldi	r30, 0x01	; 1
    1bca:	f0 e0       	ldi	r31, 0x00	; 0
    1bcc:	ec 0f       	add	r30, r28
    1bce:	fd 1f       	adc	r31, r29
    1bd0:	ee 0d       	add	r30, r14
    1bd2:	ff 1d       	adc	r31, r15
    1bd4:	80 83       	st	Z, r24
                /*------------->Entering Username<-------------*/
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter your username\r\n");
                UART_TX_Str("\r\n");

                for (Uint8 i = 0; i < 4; i++) {
    1bd6:	1f 5f       	subi	r17, 0xFF	; 255
    1bd8:	14 30       	cpi	r17, 0x04	; 4
    1bda:	80 f3       	brcs	.-32     	; 0x1bbc <__vector_13+0x26e>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                    User[i] = UART_RX_Char(); // Receiving the character in username array
                }

                /*------------->Entering Password<-------------*/
                UART_TX_Str("\r\n");
    1bdc:	8d e0       	ldi	r24, 0x0D	; 13
    1bde:	92 e0       	ldi	r25, 0x02	; 2
    1be0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1be4:	8d e0       	ldi	r24, 0x0D	; 13
    1be6:	92 e0       	ldi	r25, 0x02	; 2
    1be8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter your password\r\n");
    1bec:	8b ed       	ldi	r24, 0xDB	; 219
    1bee:	91 e0       	ldi	r25, 0x01	; 1
    1bf0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1bf4:	8d e0       	ldi	r24, 0x0D	; 13
    1bf6:	92 e0       	ldi	r25, 0x02	; 2
    1bf8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

                for (Uint8 i = 0; i < 4; i++) {
    1bfc:	10 e0       	ldi	r17, 0x00	; 0
    1bfe:	0e c0       	rjmp	.+28     	; 0x1c1c <__vector_13+0x2ce>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    1c00:	5f 9b       	sbis	0x0b, 7	; 11
    1c02:	fe cf       	rjmp	.-4      	; 0x1c00 <__vector_13+0x2b2>
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
    1c04:	e1 2e       	mov	r14, r17
    1c06:	f1 2c       	mov	r15, r1
    1c08:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    1c0c:	e5 e0       	ldi	r30, 0x05	; 5
    1c0e:	f0 e0       	ldi	r31, 0x00	; 0
    1c10:	ec 0f       	add	r30, r28
    1c12:	fd 1f       	adc	r31, r29
    1c14:	ee 0d       	add	r30, r14
    1c16:	ff 1d       	adc	r31, r15
    1c18:	80 83       	st	Z, r24
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter your password\r\n");
                UART_TX_Str("\r\n");

                for (Uint8 i = 0; i < 4; i++) {
    1c1a:	1f 5f       	subi	r17, 0xFF	; 255
    1c1c:	14 30       	cpi	r17, 0x04	; 4
    1c1e:	80 f3       	brcs	.-32     	; 0x1c00 <__vector_13+0x2b2>
    1c20:	b1 2c       	mov	r11, r1
    1c22:	83 c0       	rjmp	.+262    	; 0x1d2a <__vector_13+0x3dc>
                }

                /*---------------> Checking Username & Password<---------------*/
                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
                    /*----------------->Username Check<------------------*/
                    if (User[0] == EEPROM_ReadByte(2, Check_Counter + 1) && User[1] == EEPROM_ReadByte(2, Check_Counter + 2) && User[2] == EEPROM_ReadByte(2, Check_Counter + 3) && User[3] == EEPROM_ReadByte(2, Check_Counter + 4)) {
    1c24:	c9 80       	ldd	r12, Y+1	; 0x01
    1c26:	d1 2c       	mov	r13, r1
    1c28:	0b 2d       	mov	r16, r11
    1c2a:	10 e0       	ldi	r17, 0x00	; 0
    1c2c:	78 01       	movw	r14, r16
    1c2e:	8f ef       	ldi	r24, 0xFF	; 255
    1c30:	e8 1a       	sub	r14, r24
    1c32:	f8 0a       	sbc	r15, r24
    1c34:	b7 01       	movw	r22, r14
    1c36:	82 e0       	ldi	r24, 0x02	; 2
    1c38:	90 e0       	ldi	r25, 0x00	; 0
    1c3a:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1c3e:	c8 16       	cp	r12, r24
    1c40:	d9 06       	cpc	r13, r25
    1c42:	09 f0       	breq	.+2      	; 0x1c46 <__vector_13+0x2f8>
    1c44:	70 c0       	rjmp	.+224    	; 0x1d26 <__vector_13+0x3d8>
    1c46:	ca 80       	ldd	r12, Y+2	; 0x02
    1c48:	d1 2c       	mov	r13, r1
    1c4a:	28 01       	movw	r4, r16
    1c4c:	82 e0       	ldi	r24, 0x02	; 2
    1c4e:	48 0e       	add	r4, r24
    1c50:	51 1c       	adc	r5, r1
    1c52:	b2 01       	movw	r22, r4
    1c54:	82 e0       	ldi	r24, 0x02	; 2
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1c5c:	c8 16       	cp	r12, r24
    1c5e:	d9 06       	cpc	r13, r25
    1c60:	09 f0       	breq	.+2      	; 0x1c64 <__vector_13+0x316>
    1c62:	61 c0       	rjmp	.+194    	; 0x1d26 <__vector_13+0x3d8>
    1c64:	cb 80       	ldd	r12, Y+3	; 0x03
    1c66:	d1 2c       	mov	r13, r1
    1c68:	38 01       	movw	r6, r16
    1c6a:	83 e0       	ldi	r24, 0x03	; 3
    1c6c:	68 0e       	add	r6, r24
    1c6e:	71 1c       	adc	r7, r1
    1c70:	b3 01       	movw	r22, r6
    1c72:	82 e0       	ldi	r24, 0x02	; 2
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1c7a:	c8 16       	cp	r12, r24
    1c7c:	d9 06       	cpc	r13, r25
    1c7e:	09 f0       	breq	.+2      	; 0x1c82 <__vector_13+0x334>
    1c80:	52 c0       	rjmp	.+164    	; 0x1d26 <__vector_13+0x3d8>
    1c82:	cc 80       	ldd	r12, Y+4	; 0x04
    1c84:	d1 2c       	mov	r13, r1
    1c86:	0c 5f       	subi	r16, 0xFC	; 252
    1c88:	1f 4f       	sbci	r17, 0xFF	; 255
    1c8a:	b8 01       	movw	r22, r16
    1c8c:	82 e0       	ldi	r24, 0x02	; 2
    1c8e:	90 e0       	ldi	r25, 0x00	; 0
    1c90:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1c94:	c8 16       	cp	r12, r24
    1c96:	d9 06       	cpc	r13, r25
    1c98:	09 f0       	breq	.+2      	; 0x1c9c <__vector_13+0x34e>
    1c9a:	45 c0       	rjmp	.+138    	; 0x1d26 <__vector_13+0x3d8>
                        /*----------------->Password Check<------------------*/
                        if (Pass[0] == EEPROM_ReadByte(3, Check_Counter + 1) && Pass[1] == EEPROM_ReadByte(3, Check_Counter + 2) && Pass[2] == EEPROM_ReadByte(3, Check_Counter + 3) && Pass[3] == EEPROM_ReadByte(3, Check_Counter + 4)) {
    1c9c:	cd 80       	ldd	r12, Y+5	; 0x05
    1c9e:	d1 2c       	mov	r13, r1
    1ca0:	b7 01       	movw	r22, r14
    1ca2:	83 e0       	ldi	r24, 0x03	; 3
    1ca4:	90 e0       	ldi	r25, 0x00	; 0
    1ca6:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1caa:	c8 16       	cp	r12, r24
    1cac:	d9 06       	cpc	r13, r25
    1cae:	d9 f5       	brne	.+118    	; 0x1d26 <__vector_13+0x3d8>
    1cb0:	ee 80       	ldd	r14, Y+6	; 0x06
    1cb2:	f1 2c       	mov	r15, r1
    1cb4:	b2 01       	movw	r22, r4
    1cb6:	83 e0       	ldi	r24, 0x03	; 3
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1cbe:	e8 16       	cp	r14, r24
    1cc0:	f9 06       	cpc	r15, r25
    1cc2:	89 f5       	brne	.+98     	; 0x1d26 <__vector_13+0x3d8>
    1cc4:	ef 80       	ldd	r14, Y+7	; 0x07
    1cc6:	f1 2c       	mov	r15, r1
    1cc8:	b3 01       	movw	r22, r6
    1cca:	83 e0       	ldi	r24, 0x03	; 3
    1ccc:	90 e0       	ldi	r25, 0x00	; 0
    1cce:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1cd2:	e8 16       	cp	r14, r24
    1cd4:	f9 06       	cpc	r15, r25
    1cd6:	39 f5       	brne	.+78     	; 0x1d26 <__vector_13+0x3d8>
    1cd8:	e8 84       	ldd	r14, Y+8	; 0x08
    1cda:	f1 2c       	mov	r15, r1
    1cdc:	b8 01       	movw	r22, r16
    1cde:	83 e0       	ldi	r24, 0x03	; 3
    1ce0:	90 e0       	ldi	r25, 0x00	; 0
    1ce2:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    1ce6:	e8 16       	cp	r14, r24
    1ce8:	f9 06       	cpc	r15, r25
    1cea:	e9 f4       	brne	.+58     	; 0x1d26 <__vector_13+0x3d8>
                            /*----------------->right Username & Password<-----------------*/
                            UART_TX_Str("\r\n");
    1cec:	8d e0       	ldi	r24, 0x0D	; 13
    1cee:	92 e0       	ldi	r25, 0x02	; 2
    1cf0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("\r\n");
    1cf4:	8d e0       	ldi	r24, 0x0D	; 13
    1cf6:	92 e0       	ldi	r25, 0x02	; 2
    1cf8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("User exist, Welcome!\r\n");
    1cfc:	89 e3       	ldi	r24, 0x39	; 57
    1cfe:	92 e0       	ldi	r25, 0x02	; 2
    1d00:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            UART_TX_Str("\r\n");
    1d04:	8d e0       	ldi	r24, 0x0D	; 13
    1d06:	92 e0       	ldi	r25, 0x02	; 2
    1d08:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                            Check_Counter = PC_Counter + 1; // Exiting the Check for loop
    1d0c:	b0 90 50 07 	lds	r11, 0x0750	; 0x800750 <PC_Counter>
    1d10:	b3 94       	inc	r11
                            SYS_Check = 2; // Means that UART user entered the system (PC user = 1)
    1d12:	82 e0       	ldi	r24, 0x02	; 2
    1d14:	80 93 54 07 	sts	0x0754, r24	; 0x800754 <SYS_Check>
                            CMD_Check = 1; // *Not Important to Know* it used to not take UART_Get value variable after login the system as 0 value
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	80 93 52 07 	sts	0x0752, r24	; 0x800752 <CMD_Check>
                            i = 5; // Exiting the Alarm for loop
    1d1e:	0f 2e       	mov	r0, r31
    1d20:	f5 e0       	ldi	r31, 0x05	; 5
    1d22:	9f 2e       	mov	r9, r31
    1d24:	f0 2d       	mov	r31, r0
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
                }

                /*---------------> Checking Username & Password<---------------*/
                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
    1d26:	84 e0       	ldi	r24, 0x04	; 4
    1d28:	b8 0e       	add	r11, r24
    1d2a:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <PC_Counter>
    1d2e:	8b 15       	cp	r24, r11
    1d30:	08 f0       	brcs	.+2      	; 0x1d34 <__vector_13+0x3e6>
    1d32:	78 cf       	rjmp	.-272    	; 0x1c24 <__vector_13+0x2d6>
                        }
                    }
                }

                /*----------------->Wrong Username or Password<-----------------*/
                if (!SYS_Check) {
    1d34:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <SYS_Check>
    1d38:	81 11       	cpse	r24, r1
    1d3a:	37 c0       	rjmp	.+110    	; 0x1daa <__vector_13+0x45c>
                    UART_TX_Str("\r\n");
    1d3c:	8d e0       	ldi	r24, 0x0D	; 13
    1d3e:	92 e0       	ldi	r25, 0x02	; 2
    1d40:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                    UART_TX_Str("\r\n");
    1d44:	8d e0       	ldi	r24, 0x0D	; 13
    1d46:	92 e0       	ldi	r25, 0x02	; 2
    1d48:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                    UART_TX_Str("User does not exist. Please try again\r\n");
    1d4c:	80 e5       	ldi	r24, 0x50	; 80
    1d4e:	92 e0       	ldi	r25, 0x02	; 2
    1d50:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                    UART_TX_Str("\r\n");
    1d54:	8d e0       	ldi	r24, 0x0D	; 13
    1d56:	92 e0       	ldi	r25, 0x02	; 2
    1d58:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    1d5c:	26 c0       	rjmp	.+76     	; 0x1daa <__vector_13+0x45c>
                }
            } 
			// If user entered wrong command
			else {
                UART_TX_Str("\r\n");
    1d5e:	8d e0       	ldi	r24, 0x0D	; 13
    1d60:	92 e0       	ldi	r25, 0x02	; 2
    1d62:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1d66:	8d e0       	ldi	r24, 0x0D	; 13
    1d68:	92 e0       	ldi	r25, 0x02	; 2
    1d6a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter command number\r\n");
    1d6e:	88 e7       	ldi	r24, 0x78	; 120
    1d70:	92 e0       	ldi	r25, 0x02	; 2
    1d72:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1d76:	8d e0       	ldi	r24, 0x0D	; 13
    1d78:	92 e0       	ldi	r25, 0x02	; 2
    1d7a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1d7e:	8d e0       	ldi	r24, 0x0D	; 13
    1d80:	92 e0       	ldi	r25, 0x02	; 2
    1d82:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("1.Enter Admin\r\n");
    1d86:	86 e9       	ldi	r24, 0x96	; 150
    1d88:	92 e0       	ldi	r25, 0x02	; 2
    1d8a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("2.Enter User\r\n");
    1d8e:	86 ea       	ldi	r24, 0xA6	; 166
    1d90:	92 e0       	ldi	r25, 0x02	; 2
    1d92:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    1d96:	8d e0       	ldi	r24, 0x0D	; 13
    1d98:	92 e0       	ldi	r25, 0x02	; 2
    1d9a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                i--;
    1d9e:	9a 94       	dec	r9
				while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    1da0:	5f 9b       	sbis	0x0b, 7	; 11
    1da2:	fe cf       	rjmp	.-4      	; 0x1da0 <__vector_13+0x452>
				A_U_Check = UDR; // Receiving the character
    1da4:	8c b1       	in	r24, 0x0c	; 12
    1da6:	80 93 53 07 	sts	0x0753, r24	; 0x800753 <A_U_Check>
            }
			
			// Case of firing alarm (3 times wrong username/password) 
            if (i == 2) {
    1daa:	82 e0       	ldi	r24, 0x02	; 2
    1dac:	98 12       	cpse	r9, r24
    1dae:	09 c0       	rjmp	.+18     	; 0x1dc2 <__vector_13+0x474>
                LCD_Clear();
    1db0:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                LCD_Write_String("Firing Alarm!");
    1db4:	81 e6       	ldi	r24, 0x61	; 97
    1db6:	91 e0       	ldi	r25, 0x01	; 1
    1db8:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>

                while (1) {
                    Alarm_Fn(); // Interrupt function that polling the system and does not exit except with reset pin
    1dbc:	0e 94 86 04 	call	0x90c	; 0x90c <Alarm_Fn>
    1dc0:	fd cf       	rjmp	.-6      	; 0x1dbc <__vector_13+0x46e>
    if (!SYS_Check) {
		while (!Get_Bit(UCSRA, 7));	// Polling until the user enter a character
		A_U_Check = UDR; // Receiving the character 
		
		// 3 times for login if the user exceed 3 times the alarm will fire
        for (Uint8 i = 0; i < 3; i++) {
    1dc2:	93 94       	inc	r9
    1dc4:	82 e0       	ldi	r24, 0x02	; 2
    1dc6:	89 15       	cp	r24, r9
    1dc8:	08 f0       	brcs	.+2      	; 0x1dcc <__vector_13+0x47e>
    1dca:	00 ce       	rjmp	.-1024   	; 0x19cc <__vector_13+0x7e>
            }
        }
    }
	
	/*----------> Admin Loged-in <----------*/
    if (SYS_Check == 1) {
    1dcc:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <SYS_Check>
    1dd0:	81 30       	cpi	r24, 0x01	; 1
    1dd2:	09 f0       	breq	.+2      	; 0x1dd6 <__vector_13+0x488>
    1dd4:	3d c6       	rjmp	.+3194   	; 0x2a50 <__vector_13+0x1102>
		// *Not Important to Know* it used to not take UART_Get value variable after login the system as 0 value (do nothing after entering the system)
		if(!CMD_Check){
    1dd6:	80 91 52 07 	lds	r24, 0x0752	; 0x800752 <CMD_Check>
    1dda:	81 11       	cpse	r24, r1
    1ddc:	04 c0       	rjmp	.+8      	; 0x1de6 <__vector_13+0x498>
			UART_GetValue = UDR;
    1dde:	8c b1       	in	r24, 0x0c	; 12
    1de0:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>
    1de4:	05 c0       	rjmp	.+10     	; 0x1df0 <__vector_13+0x4a2>
        }else {
            UART_GetValue = 8;
    1de6:	88 e0       	ldi	r24, 0x08	; 8
    1de8:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>
            CMD_Check = 0;
    1dec:	10 92 52 07 	sts	0x0752, r1	; 0x800752 <CMD_Check>
        }

        if (UART_GetValue == '1') {
    1df0:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART_GetValue>
    1df4:	81 33       	cpi	r24, 0x31	; 49
    1df6:	b9 f4       	brne	.+46     	; 0x1e26 <__vector_13+0x4d8>
            // Open the door
            Servoo_Motor(316); // 316 gives 90 degree servo rotation 
    1df8:	6c e3       	ldi	r22, 0x3C	; 60
    1dfa:	71 e0       	ldi	r23, 0x01	; 1
    1dfc:	80 e0       	ldi	r24, 0x00	; 0
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	0e 94 ba 0a 	call	0x1574	; 0x1574 <Servoo_Motor>
			// If there is no keypad user, using LCD to write the operating device
            if (!eme_check) {
    1e04:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1e08:	81 11       	cpse	r24, r1
    1e0a:	b3 c5       	rjmp	.+2918   	; 0x2972 <__vector_13+0x1024>
                LCD_Clear();
    1e0c:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                LCD_Write_String("Door Opened!");
    1e10:	85 eb       	ldi	r24, 0xB5	; 181
    1e12:	92 e0       	ldi	r25, 0x02	; 2
    1e14:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    1e18:	60 ed       	ldi	r22, 0xD0	; 208
    1e1a:	77 e0       	ldi	r23, 0x07	; 7
    1e1c:	80 e0       	ldi	r24, 0x00	; 0
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
    1e24:	a6 c5       	rjmp	.+2892   	; 0x2972 <__vector_13+0x1024>
            }
        } else if (UART_GetValue == '2') {
    1e26:	82 33       	cpi	r24, 0x32	; 50
    1e28:	b9 f4       	brne	.+46     	; 0x1e58 <__vector_13+0x50a>
            // Close the door
            Servoo_Motor(97); // 97 gives 0 degree servo
    1e2a:	61 e6       	ldi	r22, 0x61	; 97
    1e2c:	70 e0       	ldi	r23, 0x00	; 0
    1e2e:	80 e0       	ldi	r24, 0x00	; 0
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	0e 94 ba 0a 	call	0x1574	; 0x1574 <Servoo_Motor>
			// If there is no keypad user, using LCD to write the operating device
            if (!eme_check) {
    1e36:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1e3a:	81 11       	cpse	r24, r1
    1e3c:	9a c5       	rjmp	.+2868   	; 0x2972 <__vector_13+0x1024>
                LCD_Clear();
    1e3e:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                LCD_Write_String("Door Closed!");
    1e42:	82 ec       	ldi	r24, 0xC2	; 194
    1e44:	92 e0       	ldi	r25, 0x02	; 2
    1e46:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    1e4a:	60 ed       	ldi	r22, 0xD0	; 208
    1e4c:	77 e0       	ldi	r23, 0x07	; 7
    1e4e:	80 e0       	ldi	r24, 0x00	; 0
    1e50:	90 e0       	ldi	r25, 0x00	; 0
    1e52:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
    1e56:	8d c5       	rjmp	.+2842   	; 0x2972 <__vector_13+0x1024>
            }
        } else if (UART_GetValue == '3') {
    1e58:	83 33       	cpi	r24, 0x33	; 51
    1e5a:	09 f0       	breq	.+2      	; 0x1e5e <__vector_13+0x510>
    1e5c:	8e c0       	rjmp	.+284    	; 0x1f7a <__vector_13+0x62c>
            // Open lamps
            UART_TX_Str("\r\n");
    1e5e:	8d e0       	ldi	r24, 0x0D	; 13
    1e60:	92 e0       	ldi	r25, 0x02	; 2
    1e62:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    1e66:	8d e0       	ldi	r24, 0x0D	; 13
    1e68:	92 e0       	ldi	r25, 0x02	; 2
    1e6a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Which lamp do you want to be opened(From 1 to 5)\r\n");
    1e6e:	8f ec       	ldi	r24, 0xCF	; 207
    1e70:	92 e0       	ldi	r25, 0x02	; 2
    1e72:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("6.All Lamps\r\n");
    1e76:	82 e0       	ldi	r24, 0x02	; 2
    1e78:	93 e0       	ldi	r25, 0x03	; 3
    1e7a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    1e7e:	8d e0       	ldi	r24, 0x0D	; 13
    1e80:	92 e0       	ldi	r25, 0x02	; 2
    1e82:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

            while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    1e86:	5f 9b       	sbis	0x0b, 7	; 11
    1e88:	fe cf       	rjmp	.-4      	; 0x1e86 <__vector_13+0x538>
            UART_GetValue = UART_RX_Char(); // Receiving the command
    1e8a:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    1e8e:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>

			// Open first lamp
            if (UART_GetValue == '1') {
    1e92:	81 33       	cpi	r24, 0x31	; 49
    1e94:	69 f4       	brne	.+26     	; 0x1eb0 <__vector_13+0x562>
                LED0_ON(); 
    1e96:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1e9a:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1e9e:	81 11       	cpse	r24, r1
    1ea0:	61 c0       	rjmp	.+194    	; 0x1f64 <__vector_13+0x616>
                    LCD_Clear();
    1ea2:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(1) Opened");
    1ea6:	80 e1       	ldi	r24, 0x10	; 16
    1ea8:	93 e0       	ldi	r25, 0x03	; 3
    1eaa:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    1eae:	5a c0       	rjmp	.+180    	; 0x1f64 <__vector_13+0x616>
                }
            } 
			// Open second lamp
			else if (UART_GetValue == '2') {
    1eb0:	82 33       	cpi	r24, 0x32	; 50
    1eb2:	69 f4       	brne	.+26     	; 0x1ece <__vector_13+0x580>
                LED1_ON();
    1eb4:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <LED1_ON>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1eb8:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1ebc:	81 11       	cpse	r24, r1
    1ebe:	52 c0       	rjmp	.+164    	; 0x1f64 <__vector_13+0x616>
                    LCD_Clear();
    1ec0:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(2) Opened");
    1ec4:	8f e1       	ldi	r24, 0x1F	; 31
    1ec6:	93 e0       	ldi	r25, 0x03	; 3
    1ec8:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    1ecc:	4b c0       	rjmp	.+150    	; 0x1f64 <__vector_13+0x616>
                }
            }
			 // Open third lamp			
			 else if (UART_GetValue == '3') {
    1ece:	83 33       	cpi	r24, 0x33	; 51
    1ed0:	69 f4       	brne	.+26     	; 0x1eec <__vector_13+0x59e>
                LED2_ON();
    1ed2:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1ed6:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1eda:	81 11       	cpse	r24, r1
    1edc:	43 c0       	rjmp	.+134    	; 0x1f64 <__vector_13+0x616>
                    LCD_Clear();
    1ede:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(3) Opened");
    1ee2:	8e e2       	ldi	r24, 0x2E	; 46
    1ee4:	93 e0       	ldi	r25, 0x03	; 3
    1ee6:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    1eea:	3c c0       	rjmp	.+120    	; 0x1f64 <__vector_13+0x616>
                }
            } 
			// Open fourth lamp
			else if (UART_GetValue == '4') {
    1eec:	84 33       	cpi	r24, 0x34	; 52
    1eee:	69 f4       	brne	.+26     	; 0x1f0a <__vector_13+0x5bc>
                LED3_ON();
    1ef0:	0e 94 f5 09 	call	0x13ea	; 0x13ea <LED3_ON>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1ef4:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1ef8:	81 11       	cpse	r24, r1
    1efa:	34 c0       	rjmp	.+104    	; 0x1f64 <__vector_13+0x616>
                    LCD_Clear();
    1efc:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(4) Opened");
    1f00:	8d e3       	ldi	r24, 0x3D	; 61
    1f02:	93 e0       	ldi	r25, 0x03	; 3
    1f04:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    1f08:	2d c0       	rjmp	.+90     	; 0x1f64 <__vector_13+0x616>
                }
            } 
			// Open fifth lamp
			else if (UART_GetValue == '5') {
    1f0a:	85 33       	cpi	r24, 0x35	; 53
    1f0c:	69 f4       	brne	.+26     	; 0x1f28 <__vector_13+0x5da>
                LED4_ON();
    1f0e:	0e 94 06 0a 	call	0x140c	; 0x140c <LED4_ON>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1f12:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1f16:	81 11       	cpse	r24, r1
    1f18:	25 c0       	rjmp	.+74     	; 0x1f64 <__vector_13+0x616>
                    LCD_Clear();
    1f1a:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(5) Opened");
    1f1e:	8c e4       	ldi	r24, 0x4C	; 76
    1f20:	93 e0       	ldi	r25, 0x03	; 3
    1f22:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    1f26:	1e c0       	rjmp	.+60     	; 0x1f64 <__vector_13+0x616>
                }
            } 
			// Open all lamps
			else if (UART_GetValue == '6') {
    1f28:	86 33       	cpi	r24, 0x36	; 54
    1f2a:	e1 f4       	brne	.+56     	; 0x1f64 <__vector_13+0x616>
                LED0_ON();
    1f2c:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
                LED1_ON();
    1f30:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <LED1_ON>
                LED2_ON();
    1f34:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
                LED3_ON();
    1f38:	0e 94 f5 09 	call	0x13ea	; 0x13ea <LED3_ON>
                LED4_ON();
    1f3c:	0e 94 06 0a 	call	0x140c	; 0x140c <LED4_ON>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1f40:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1f44:	81 11       	cpse	r24, r1
    1f46:	0e c0       	rjmp	.+28     	; 0x1f64 <__vector_13+0x616>
                    LCD_Clear();
    1f48:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("All Lamps Are");
    1f4c:	8b e5       	ldi	r24, 0x5B	; 91
    1f4e:	93 e0       	ldi	r25, 0x03	; 3
    1f50:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                    LCD_Goto(1, 0);
    1f54:	60 e0       	ldi	r22, 0x00	; 0
    1f56:	81 e0       	ldi	r24, 0x01	; 1
    1f58:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
                    LCD_Write_String("Opened");
    1f5c:	88 e1       	ldi	r24, 0x18	; 24
    1f5e:	93 e0       	ldi	r25, 0x03	; 3
    1f60:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                }
            }
			// If there is no keypad user, using LCD to write & clear the operating device
			if (!eme_check)
    1f64:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1f68:	81 11       	cpse	r24, r1
    1f6a:	03 c5       	rjmp	.+2566   	; 0x2972 <__vector_13+0x1024>
				Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    1f6c:	60 ed       	ldi	r22, 0xD0	; 208
    1f6e:	77 e0       	ldi	r23, 0x07	; 7
    1f70:	80 e0       	ldi	r24, 0x00	; 0
    1f72:	90 e0       	ldi	r25, 0x00	; 0
    1f74:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
    1f78:	fc c4       	rjmp	.+2552   	; 0x2972 <__vector_13+0x1024>
        } else if (UART_GetValue == '4') {
    1f7a:	84 33       	cpi	r24, 0x34	; 52
    1f7c:	09 f0       	breq	.+2      	; 0x1f80 <__vector_13+0x632>
    1f7e:	8e c0       	rjmp	.+284    	; 0x209c <__vector_13+0x74e>
            // Close lamps
            UART_TX_Str("\r\n");
    1f80:	8d e0       	ldi	r24, 0x0D	; 13
    1f82:	92 e0       	ldi	r25, 0x02	; 2
    1f84:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    1f88:	8d e0       	ldi	r24, 0x0D	; 13
    1f8a:	92 e0       	ldi	r25, 0x02	; 2
    1f8c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Which lamp do you want to be Closed(From 1 to 5)\r\n");
    1f90:	89 e6       	ldi	r24, 0x69	; 105
    1f92:	93 e0       	ldi	r25, 0x03	; 3
    1f94:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("6.All Lamps\r\n");
    1f98:	82 e0       	ldi	r24, 0x02	; 2
    1f9a:	93 e0       	ldi	r25, 0x03	; 3
    1f9c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    1fa0:	8d e0       	ldi	r24, 0x0D	; 13
    1fa2:	92 e0       	ldi	r25, 0x02	; 2
    1fa4:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

            while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    1fa8:	5f 9b       	sbis	0x0b, 7	; 11
    1faa:	fe cf       	rjmp	.-4      	; 0x1fa8 <__vector_13+0x65a>
            UART_GetValue = UART_RX_Char(); // Receiving the command
    1fac:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    1fb0:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>

			// CLose first lamp
            if (UART_GetValue == '1') {
    1fb4:	81 33       	cpi	r24, 0x31	; 49
    1fb6:	69 f4       	brne	.+26     	; 0x1fd2 <__vector_13+0x684>
                LED0_OFF();
    1fb8:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1fbc:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1fc0:	81 11       	cpse	r24, r1
    1fc2:	61 c0       	rjmp	.+194    	; 0x2086 <__vector_13+0x738>
                    LCD_Clear();
    1fc4:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(1) Closed");
    1fc8:	8c e9       	ldi	r24, 0x9C	; 156
    1fca:	93 e0       	ldi	r25, 0x03	; 3
    1fcc:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    1fd0:	5a c0       	rjmp	.+180    	; 0x2086 <__vector_13+0x738>
                }
            } 
			// Close second lamp
			else if (UART_GetValue == '2') {
    1fd2:	82 33       	cpi	r24, 0x32	; 50
    1fd4:	69 f4       	brne	.+26     	; 0x1ff0 <__vector_13+0x6a2>
                LED1_OFF();
    1fd6:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <LED1_OFF>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1fda:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1fde:	81 11       	cpse	r24, r1
    1fe0:	52 c0       	rjmp	.+164    	; 0x2086 <__vector_13+0x738>
                    LCD_Clear();
    1fe2:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(2) Closed");
    1fe6:	8b ea       	ldi	r24, 0xAB	; 171
    1fe8:	93 e0       	ldi	r25, 0x03	; 3
    1fea:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    1fee:	4b c0       	rjmp	.+150    	; 0x2086 <__vector_13+0x738>
                }
            } 
			// Close third lamp
			else if (UART_GetValue == '3') {
    1ff0:	83 33       	cpi	r24, 0x33	; 51
    1ff2:	69 f4       	brne	.+26     	; 0x200e <__vector_13+0x6c0>
                LED2_OFF();
    1ff4:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    1ff8:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    1ffc:	81 11       	cpse	r24, r1
    1ffe:	43 c0       	rjmp	.+134    	; 0x2086 <__vector_13+0x738>
                    LCD_Clear();
    2000:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(3) Closed");
    2004:	8a eb       	ldi	r24, 0xBA	; 186
    2006:	93 e0       	ldi	r25, 0x03	; 3
    2008:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    200c:	3c c0       	rjmp	.+120    	; 0x2086 <__vector_13+0x738>
                }
            } 
			// Close fourth lamp
			else if (UART_GetValue == '4') {
    200e:	84 33       	cpi	r24, 0x34	; 52
    2010:	69 f4       	brne	.+26     	; 0x202c <__vector_13+0x6de>
                LED3_OFF();
    2012:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <LED3_OFF>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    2016:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    201a:	81 11       	cpse	r24, r1
    201c:	34 c0       	rjmp	.+104    	; 0x2086 <__vector_13+0x738>
                    LCD_Clear();
    201e:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(4) Closed");
    2022:	89 ec       	ldi	r24, 0xC9	; 201
    2024:	93 e0       	ldi	r25, 0x03	; 3
    2026:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    202a:	2d c0       	rjmp	.+90     	; 0x2086 <__vector_13+0x738>
                }
            } 
			// Close fifth lamp
			else if (UART_GetValue == '5') {
    202c:	85 33       	cpi	r24, 0x35	; 53
    202e:	69 f4       	brne	.+26     	; 0x204a <__vector_13+0x6fc>
                LED4_OFF();
    2030:	0e 94 0c 0a 	call	0x1418	; 0x1418 <LED4_OFF>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    2034:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2038:	81 11       	cpse	r24, r1
    203a:	25 c0       	rjmp	.+74     	; 0x2086 <__vector_13+0x738>
                    LCD_Clear();
    203c:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                    LCD_Write_String("Lamp(5) Closed");
    2040:	88 ed       	ldi	r24, 0xD8	; 216
    2042:	93 e0       	ldi	r25, 0x03	; 3
    2044:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2048:	1e c0       	rjmp	.+60     	; 0x2086 <__vector_13+0x738>
                }
            } 
			// Close all lamps
			else if (UART_GetValue == '6') {
    204a:	86 33       	cpi	r24, 0x36	; 54
    204c:	e1 f4       	brne	.+56     	; 0x2086 <__vector_13+0x738>
                LED0_OFF();
    204e:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
                LED1_OFF();
    2052:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <LED1_OFF>
                LED2_OFF();
    2056:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
                LED3_OFF();
    205a:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <LED3_OFF>
                LED4_OFF();
    205e:	0e 94 0c 0a 	call	0x1418	; 0x1418 <LED4_OFF>
                LCD_Clear();
    2062:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
				// If there is no keypad user, using LCD to write the operating device
                if (!eme_check) {
    2066:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    206a:	81 11       	cpse	r24, r1
    206c:	0c c0       	rjmp	.+24     	; 0x2086 <__vector_13+0x738>
                    LCD_Write_String("All Lamps Are");
    206e:	8b e5       	ldi	r24, 0x5B	; 91
    2070:	93 e0       	ldi	r25, 0x03	; 3
    2072:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                    LCD_Goto(1, 0);
    2076:	60 e0       	ldi	r22, 0x00	; 0
    2078:	81 e0       	ldi	r24, 0x01	; 1
    207a:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
                    LCD_Write_String("Closed");
    207e:	84 ea       	ldi	r24, 0xA4	; 164
    2080:	93 e0       	ldi	r25, 0x03	; 3
    2082:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                }
            }
			// If there is no keypad user, using LCD to write & clear the operating device
			if (!eme_check)
    2086:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    208a:	81 11       	cpse	r24, r1
    208c:	72 c4       	rjmp	.+2276   	; 0x2972 <__vector_13+0x1024>
				Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    208e:	60 ed       	ldi	r22, 0xD0	; 208
    2090:	77 e0       	ldi	r23, 0x07	; 7
    2092:	80 e0       	ldi	r24, 0x00	; 0
    2094:	90 e0       	ldi	r25, 0x00	; 0
    2096:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
    209a:	6b c4       	rjmp	.+2262   	; 0x2972 <__vector_13+0x1024>
        } else if (UART_GetValue == '5') {
    209c:	85 33       	cpi	r24, 0x35	; 53
    209e:	09 f0       	breq	.+2      	; 0x20a2 <__vector_13+0x754>
    20a0:	cf c0       	rjmp	.+414    	; 0x2240 <__vector_13+0x8f2>
            /*Dimmer circuit*/
            UART_TX_Str("\r\n");
    20a2:	8d e0       	ldi	r24, 0x0D	; 13
    20a4:	92 e0       	ldi	r25, 0x02	; 2
    20a6:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    20aa:	8d e0       	ldi	r24, 0x0D	; 13
    20ac:	92 e0       	ldi	r25, 0x02	; 2
    20ae:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Please enter the percentage of the lamp\r\n");
    20b2:	87 ee       	ldi	r24, 0xE7	; 231
    20b4:	93 e0       	ldi	r25, 0x03	; 3
    20b6:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    20ba:	8d e0       	ldi	r24, 0x0D	; 13
    20bc:	92 e0       	ldi	r25, 0x02	; 2
    20be:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

            Dimmer_Value = 0; // making sure that dimmer value equal 0
    20c2:	10 92 49 07 	sts	0x0749, r1	; 0x800749 <Dimmer_Value>
    20c6:	10 92 4a 07 	sts	0x074A, r1	; 0x80074a <Dimmer_Value+0x1>
    20ca:	10 92 4b 07 	sts	0x074B, r1	; 0x80074b <Dimmer_Value+0x2>
    20ce:	10 92 4c 07 	sts	0x074C, r1	; 0x80074c <Dimmer_Value+0x3>

			// Taking the dimmer value as characters 
            for (Uint8 i = 0; i < 3; i++) {
    20d2:	00 e0       	ldi	r16, 0x00	; 0
    20d4:	38 c0       	rjmp	.+112    	; 0x2146 <__vector_13+0x7f8>
                while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    20d6:	5f 9b       	sbis	0x0b, 7	; 11
    20d8:	fe cf       	rjmp	.-4      	; 0x20d6 <__vector_13+0x788>
                Dimmer_Array[i] = UART_RX_Char(); // Receiving dimmer character values
    20da:	e0 2e       	mov	r14, r16
    20dc:	f1 2c       	mov	r15, r1
    20de:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    20e2:	18 2f       	mov	r17, r24
    20e4:	f7 01       	movw	r30, r14
    20e6:	e3 5b       	subi	r30, 0xB3	; 179
    20e8:	f8 4f       	sbci	r31, 0xF8	; 248
    20ea:	80 83       	st	Z, r24

				// Converting Dimmer value from characters to integer to send it as duty cycle to timer(0) 
                if (Dimmer_Array[i] >= 48 && Dimmer_Array[i] <= 57) {
    20ec:	80 ed       	ldi	r24, 0xD0	; 208
    20ee:	81 0f       	add	r24, r17
    20f0:	8a 30       	cpi	r24, 0x0A	; 10
    20f2:	38 f5       	brcc	.+78     	; 0x2142 <__vector_13+0x7f4>
                    Dimmer_Value = Dimmer_Value * 10 + (Dimmer_Array[i] - 48);
    20f4:	20 e0       	ldi	r18, 0x00	; 0
    20f6:	30 e0       	ldi	r19, 0x00	; 0
    20f8:	40 e2       	ldi	r20, 0x20	; 32
    20fa:	51 e4       	ldi	r21, 0x41	; 65
    20fc:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <Dimmer_Value>
    2100:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <Dimmer_Value+0x1>
    2104:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <Dimmer_Value+0x2>
    2108:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <Dimmer_Value+0x3>
    210c:	0e 94 d7 19 	call	0x33ae	; 0x33ae <__mulsf3>
    2110:	6b 01       	movw	r12, r22
    2112:	7c 01       	movw	r14, r24
    2114:	61 2f       	mov	r22, r17
    2116:	70 e0       	ldi	r23, 0x00	; 0
    2118:	60 53       	subi	r22, 0x30	; 48
    211a:	71 09       	sbc	r23, r1
    211c:	07 2e       	mov	r0, r23
    211e:	00 0c       	add	r0, r0
    2120:	88 0b       	sbc	r24, r24
    2122:	99 0b       	sbc	r25, r25
    2124:	0e 94 22 19 	call	0x3244	; 0x3244 <__floatsisf>
    2128:	a7 01       	movw	r20, r14
    212a:	96 01       	movw	r18, r12
    212c:	0e 94 0e 18 	call	0x301c	; 0x301c <__addsf3>
    2130:	60 93 49 07 	sts	0x0749, r22	; 0x800749 <Dimmer_Value>
    2134:	70 93 4a 07 	sts	0x074A, r23	; 0x80074a <Dimmer_Value+0x1>
    2138:	80 93 4b 07 	sts	0x074B, r24	; 0x80074b <Dimmer_Value+0x2>
    213c:	90 93 4c 07 	sts	0x074C, r25	; 0x80074c <Dimmer_Value+0x3>
    2140:	01 c0       	rjmp	.+2      	; 0x2144 <__vector_13+0x7f6>
                } 
				// if the value of character not from 48 to 57 (which is the number characters in ASCII table) these means that user entered the desired value and want to  escape other values 
				else {
                    i = 5; // Exiting the for loop in which user enter the character values of dimmer circuit
    2142:	05 e0       	ldi	r16, 0x05	; 5
            UART_TX_Str("\r\n");

            Dimmer_Value = 0; // making sure that dimmer value equal 0

			// Taking the dimmer value as characters 
            for (Uint8 i = 0; i < 3; i++) {
    2144:	0f 5f       	subi	r16, 0xFF	; 255
    2146:	03 30       	cpi	r16, 0x03	; 3
    2148:	30 f2       	brcs	.-116    	; 0x20d6 <__vector_13+0x788>
                }

            }
			
			// If there is no keypad user, using LCD to write the operating device
            if (!eme_check) {
    214a:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    214e:	81 11       	cpse	r24, r1
    2150:	23 c0       	rjmp	.+70     	; 0x2198 <__vector_13+0x84a>
                LCD_Clear();
    2152:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
                LCD_Write_String("Lamp ON!");
    2156:	81 e1       	ldi	r24, 0x11	; 17
    2158:	94 e0       	ldi	r25, 0x04	; 4
    215a:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                LCD_Goto(1, 0);
    215e:	60 e0       	ldi	r22, 0x00	; 0
    2160:	81 e0       	ldi	r24, 0x01	; 1
    2162:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
                LCD_Write_String("Percentage:");
    2166:	8a e1       	ldi	r24, 0x1A	; 26
    2168:	94 e0       	ldi	r25, 0x04	; 4
    216a:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
                LCD_Write_Integer(Dimmer_Value);
    216e:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <Dimmer_Value>
    2172:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <Dimmer_Value+0x1>
    2176:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <Dimmer_Value+0x2>
    217a:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <Dimmer_Value+0x3>
    217e:	0e 94 f1 18 	call	0x31e2	; 0x31e2 <__fixunssfsi>
    2182:	0e 94 2d 09 	call	0x125a	; 0x125a <LCD_Write_Integer>
                LCD_Write_Char('%');
    2186:	85 e2       	ldi	r24, 0x25	; 37
    2188:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <LCD_Write_Char>
                Timer2_SetDelay(2000);
    218c:	60 ed       	ldi	r22, 0xD0	; 208
    218e:	77 e0       	ldi	r23, 0x07	; 7
    2190:	80 e0       	ldi	r24, 0x00	; 0
    2192:	90 e0       	ldi	r25, 0x00	; 0
    2194:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
            }

			// To avoid twitch of dimmer lamp
            if (Dimmer_Value >= 58 && Dimmer_Value <= 60) {
    2198:	c0 90 49 07 	lds	r12, 0x0749	; 0x800749 <Dimmer_Value>
    219c:	d0 90 4a 07 	lds	r13, 0x074A	; 0x80074a <Dimmer_Value+0x1>
    21a0:	e0 90 4b 07 	lds	r14, 0x074B	; 0x80074b <Dimmer_Value+0x2>
    21a4:	f0 90 4c 07 	lds	r15, 0x074C	; 0x80074c <Dimmer_Value+0x3>
    21a8:	20 e0       	ldi	r18, 0x00	; 0
    21aa:	30 e0       	ldi	r19, 0x00	; 0
    21ac:	48 e6       	ldi	r20, 0x68	; 104
    21ae:	52 e4       	ldi	r21, 0x42	; 66
    21b0:	c7 01       	movw	r24, r14
    21b2:	b6 01       	movw	r22, r12
    21b4:	0e 94 d2 19 	call	0x33a4	; 0x33a4 <__gesf2>
    21b8:	88 23       	and	r24, r24
    21ba:	bc f0       	brlt	.+46     	; 0x21ea <__vector_13+0x89c>
    21bc:	20 e0       	ldi	r18, 0x00	; 0
    21be:	30 e0       	ldi	r19, 0x00	; 0
    21c0:	40 e7       	ldi	r20, 0x70	; 112
    21c2:	52 e4       	ldi	r21, 0x42	; 66
    21c4:	c7 01       	movw	r24, r14
    21c6:	b6 01       	movw	r22, r12
    21c8:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__cmpsf2>
    21cc:	18 16       	cp	r1, r24
    21ce:	6c f0       	brlt	.+26     	; 0x21ea <__vector_13+0x89c>
                Dimmer_Value = 55;
    21d0:	80 e0       	ldi	r24, 0x00	; 0
    21d2:	90 e0       	ldi	r25, 0x00	; 0
    21d4:	ac e5       	ldi	r26, 0x5C	; 92
    21d6:	b2 e4       	ldi	r27, 0x42	; 66
    21d8:	80 93 49 07 	sts	0x0749, r24	; 0x800749 <Dimmer_Value>
    21dc:	90 93 4a 07 	sts	0x074A, r25	; 0x80074a <Dimmer_Value+0x1>
    21e0:	a0 93 4b 07 	sts	0x074B, r26	; 0x80074b <Dimmer_Value+0x2>
    21e4:	b0 93 4c 07 	sts	0x074C, r27	; 0x80074c <Dimmer_Value+0x3>
    21e8:	20 c0       	rjmp	.+64     	; 0x222a <__vector_13+0x8dc>
            } else if (Dimmer_Value > 60 && Dimmer_Value <= 62) {
    21ea:	20 e0       	ldi	r18, 0x00	; 0
    21ec:	30 e0       	ldi	r19, 0x00	; 0
    21ee:	40 e7       	ldi	r20, 0x70	; 112
    21f0:	52 e4       	ldi	r21, 0x42	; 66
    21f2:	c7 01       	movw	r24, r14
    21f4:	b6 01       	movw	r22, r12
    21f6:	0e 94 d2 19 	call	0x33a4	; 0x33a4 <__gesf2>
    21fa:	18 16       	cp	r1, r24
    21fc:	b4 f4       	brge	.+44     	; 0x222a <__vector_13+0x8dc>
    21fe:	20 e0       	ldi	r18, 0x00	; 0
    2200:	30 e0       	ldi	r19, 0x00	; 0
    2202:	48 e7       	ldi	r20, 0x78	; 120
    2204:	52 e4       	ldi	r21, 0x42	; 66
    2206:	c7 01       	movw	r24, r14
    2208:	b6 01       	movw	r22, r12
    220a:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__cmpsf2>
    220e:	18 16       	cp	r1, r24
    2210:	64 f0       	brlt	.+24     	; 0x222a <__vector_13+0x8dc>
                Dimmer_Value = 65;
    2212:	80 e0       	ldi	r24, 0x00	; 0
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	a2 e8       	ldi	r26, 0x82	; 130
    2218:	b2 e4       	ldi	r27, 0x42	; 66
    221a:	80 93 49 07 	sts	0x0749, r24	; 0x800749 <Dimmer_Value>
    221e:	90 93 4a 07 	sts	0x074A, r25	; 0x80074a <Dimmer_Value+0x1>
    2222:	a0 93 4b 07 	sts	0x074B, r26	; 0x80074b <Dimmer_Value+0x2>
    2226:	b0 93 4c 07 	sts	0x074C, r27	; 0x80074c <Dimmer_Value+0x3>
            }

            PWM0_Gen(Dimmer_Value); // Sending dimmer as duty cycle to timer(0)
    222a:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <Dimmer_Value>
    222e:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <Dimmer_Value+0x1>
    2232:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <Dimmer_Value+0x2>
    2236:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <Dimmer_Value+0x3>
    223a:	0e 94 df 0a 	call	0x15be	; 0x15be <PWM0_Gen>
    223e:	99 c3       	rjmp	.+1842   	; 0x2972 <__vector_13+0x1024>
        }else if (UART_GetValue == '6') {
    2240:	86 33       	cpi	r24, 0x36	; 54
    2242:	09 f0       	breq	.+2      	; 0x2246 <__vector_13+0x8f8>
    2244:	50 c0       	rjmp	.+160    	; 0x22e6 <__vector_13+0x998>
        /*--------------->Display temperature<----------------*/
        // Declaring temperature array which take the temperature value from temperature integer that take its value from the temperature
        Uint8 Temp_array[2] = {
    2246:	1a 86       	std	Y+10, r1	; 0x0a
    2248:	19 86       	std	Y+9, r1	; 0x09
	        0
        };
        Uint8 Temp_Divide = Temp; // Saving the value in other variable to do some operations
    224a:	90 91 31 07 	lds	r25, 0x0731	; 0x800731 <Temp>
        
        // Converting the integer value to characters and saved in the temperature array
        for (Uint8 i = 0; i < 2; i++) {
    224e:	20 e0       	ldi	r18, 0x00	; 0
    2250:	17 c0       	rjmp	.+46     	; 0x2280 <__vector_13+0x932>
	        Temp_array[i] = Temp_Divide % 10;
    2252:	e9 e0       	ldi	r30, 0x09	; 9
    2254:	f0 e0       	ldi	r31, 0x00	; 0
    2256:	ec 0f       	add	r30, r28
    2258:	fd 1f       	adc	r31, r29
    225a:	e2 0f       	add	r30, r18
    225c:	f1 1d       	adc	r31, r1
    225e:	8d ec       	ldi	r24, 0xCD	; 205
    2260:	98 9f       	mul	r25, r24
    2262:	81 2d       	mov	r24, r1
    2264:	11 24       	eor	r1, r1
    2266:	86 95       	lsr	r24
    2268:	86 95       	lsr	r24
    226a:	86 95       	lsr	r24
    226c:	48 2f       	mov	r20, r24
    226e:	44 0f       	add	r20, r20
    2270:	34 2f       	mov	r19, r20
    2272:	33 0f       	add	r19, r19
    2274:	33 0f       	add	r19, r19
    2276:	34 0f       	add	r19, r20
    2278:	93 1b       	sub	r25, r19
    227a:	90 83       	st	Z, r25
	        Temp_Divide /= 10;
    227c:	98 2f       	mov	r25, r24
	        0
        };
        Uint8 Temp_Divide = Temp; // Saving the value in other variable to do some operations
        
        // Converting the integer value to characters and saved in the temperature array
        for (Uint8 i = 0; i < 2; i++) {
    227e:	2f 5f       	subi	r18, 0xFF	; 255
    2280:	22 30       	cpi	r18, 0x02	; 2
    2282:	38 f3       	brcs	.-50     	; 0x2252 <__vector_13+0x904>
	        Temp_array[i] = Temp_Divide % 10;
	        Temp_Divide /= 10;
        }
        
        // Display the temperature
        UART_TX_Str("\r\n");
    2284:	8d e0       	ldi	r24, 0x0D	; 13
    2286:	92 e0       	ldi	r25, 0x02	; 2
    2288:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("\r\n");
    228c:	8d e0       	ldi	r24, 0x0D	; 13
    228e:	92 e0       	ldi	r25, 0x02	; 2
    2290:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("Temperature:\r\n");
    2294:	86 e2       	ldi	r24, 0x26	; 38
    2296:	94 e0       	ldi	r25, 0x04	; 4
    2298:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Char(Temp_array[1] + 48);
    229c:	8a 85       	ldd	r24, Y+10	; 0x0a
    229e:	80 5d       	subi	r24, 0xD0	; 208
    22a0:	0e 94 8c 0c 	call	0x1918	; 0x1918 <UART_TX_Char>
        UART_TX_Char(Temp_array[0] + 48);
    22a4:	89 85       	ldd	r24, Y+9	; 0x09
    22a6:	80 5d       	subi	r24, 0xD0	; 208
    22a8:	0e 94 8c 0c 	call	0x1918	; 0x1918 <UART_TX_Char>
        UART_TX_Str("\r\n");
    22ac:	8d e0       	ldi	r24, 0x0D	; 13
    22ae:	92 e0       	ldi	r25, 0x02	; 2
    22b0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

        // If there is no keypad user, using LCD to write the operating device
        if (!eme_check) {
    22b4:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    22b8:	81 11       	cpse	r24, r1
    22ba:	5b c3       	rjmp	.+1718   	; 0x2972 <__vector_13+0x1024>
	        LCD_Clear();
    22bc:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
	        LCD_Write_String("Temperature:");
    22c0:	85 e3       	ldi	r24, 0x35	; 53
    22c2:	94 e0       	ldi	r25, 0x04	; 4
    22c4:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
	        LCD_Write_Integer(Temp);
    22c8:	60 91 31 07 	lds	r22, 0x0731	; 0x800731 <Temp>
    22cc:	70 91 32 07 	lds	r23, 0x0732	; 0x800732 <Temp+0x1>
    22d0:	80 e0       	ldi	r24, 0x00	; 0
    22d2:	90 e0       	ldi	r25, 0x00	; 0
    22d4:	0e 94 2d 09 	call	0x125a	; 0x125a <LCD_Write_Integer>
	        Timer2_SetDelay(2000);
    22d8:	60 ed       	ldi	r22, 0xD0	; 208
    22da:	77 e0       	ldi	r23, 0x07	; 7
    22dc:	80 e0       	ldi	r24, 0x00	; 0
    22de:	90 e0       	ldi	r25, 0x00	; 0
    22e0:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
    22e4:	46 c3       	rjmp	.+1676   	; 0x2972 <__vector_13+0x1024>
        }
        } 
		else if (UART_GetValue == '7') {
    22e6:	87 33       	cpi	r24, 0x37	; 55
    22e8:	09 f0       	breq	.+2      	; 0x22ec <__vector_13+0x99e>
    22ea:	10 c1       	rjmp	.+544    	; 0x250c <__vector_13+0xbbe>
            // Add new user

            /*-------------->Determine The Type of User<---------------*/
            UART_TX_Str("\r\n");
    22ec:	8d e0       	ldi	r24, 0x0D	; 13
    22ee:	92 e0       	ldi	r25, 0x02	; 2
    22f0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    22f4:	8d e0       	ldi	r24, 0x0D	; 13
    22f6:	92 e0       	ldi	r25, 0x02	; 2
    22f8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("1.Keypad user\r\n");
    22fc:	82 e4       	ldi	r24, 0x42	; 66
    22fe:	94 e0       	ldi	r25, 0x04	; 4
    2300:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("2.PC user\r\n");
    2304:	82 e5       	ldi	r24, 0x52	; 82
    2306:	94 e0       	ldi	r25, 0x04	; 4
    2308:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("3.AD user\r\n");
    230c:	8e e5       	ldi	r24, 0x5E	; 94
    230e:	94 e0       	ldi	r25, 0x04	; 4
    2310:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

            while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2314:	5f 9b       	sbis	0x0b, 7	; 11
    2316:	fe cf       	rjmp	.-4      	; 0x2314 <__vector_13+0x9c6>
            UART_GetValue = UART_RX_Char(); // Receiving the command
    2318:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    231c:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>

            if (UART_GetValue == '1') {
    2320:	81 33       	cpi	r24, 0x31	; 49
    2322:	09 f0       	breq	.+2      	; 0x2326 <__vector_13+0x9d8>
    2324:	4b c0       	rjmp	.+150    	; 0x23bc <__vector_13+0xa6e>
                /*--------------->Adding Keypad User<-------------------*/
                Uint8 j = 0;

                /*----------------->Adding New Username<-----------------*/
                UART_TX_Str("\r\n");
    2326:	8d e0       	ldi	r24, 0x0D	; 13
    2328:	92 e0       	ldi	r25, 0x02	; 2
    232a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    232e:	8d e0       	ldi	r24, 0x0D	; 13
    2330:	92 e0       	ldi	r25, 0x02	; 2
    2332:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter 4 numbers as username\r\n");
    2336:	8a e6       	ldi	r24, 0x6A	; 106
    2338:	94 e0       	ldi	r25, 0x04	; 4
    233a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                for (Uint8 i = 0; i < 4; i++) {
    233e:	10 e0       	ldi	r17, 0x00	; 0
    2340:	0f c0       	rjmp	.+30     	; 0x2360 <__vector_13+0xa12>
                    j = i + 1;
    2342:	1f 5f       	subi	r17, 0xFF	; 255
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2344:	5f 9b       	sbis	0x0b, 7	; 11
    2346:	fe cf       	rjmp	.-4      	; 0x2344 <__vector_13+0x9f6>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
    2348:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
                    EEPROM_WriteByte(0, j += KP_Counter, User[i]); // Adding the username in EEPROM
    234c:	60 91 51 07 	lds	r22, 0x0751	; 0x800751 <KP_Counter>
    2350:	61 0f       	add	r22, r17
    2352:	48 2f       	mov	r20, r24
    2354:	50 e0       	ldi	r21, 0x00	; 0
    2356:	70 e0       	ldi	r23, 0x00	; 0
    2358:	80 e0       	ldi	r24, 0x00	; 0
    235a:	90 e0       	ldi	r25, 0x00	; 0
    235c:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>

                /*----------------->Adding New Username<-----------------*/
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter 4 numbers as username\r\n");
                for (Uint8 i = 0; i < 4; i++) {
    2360:	14 30       	cpi	r17, 0x04	; 4
    2362:	78 f3       	brcs	.-34     	; 0x2342 <__vector_13+0x9f4>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
                    EEPROM_WriteByte(0, j += KP_Counter, User[i]); // Adding the username in EEPROM
                }

                /*----------------->Adding New Password<-----------------*/
                UART_TX_Str("\r\n");
    2364:	8d e0       	ldi	r24, 0x0D	; 13
    2366:	92 e0       	ldi	r25, 0x02	; 2
    2368:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    236c:	8d e0       	ldi	r24, 0x0D	; 13
    236e:	92 e0       	ldi	r25, 0x02	; 2
    2370:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter 4 numbers as password\r\n");
    2374:	8f e8       	ldi	r24, 0x8F	; 143
    2376:	94 e0       	ldi	r25, 0x04	; 4
    2378:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                for (Uint8 i = 0; i < 4; i++) {
    237c:	10 e0       	ldi	r17, 0x00	; 0
    237e:	0f c0       	rjmp	.+30     	; 0x239e <__vector_13+0xa50>
                    j = i + 1;
    2380:	1f 5f       	subi	r17, 0xFF	; 255
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2382:	5f 9b       	sbis	0x0b, 7	; 11
    2384:	fe cf       	rjmp	.-4      	; 0x2382 <__vector_13+0xa34>
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
    2386:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
                    EEPROM_WriteByte(1, j += KP_Counter, Pass[i]); // Adding the password in EEPROM
    238a:	60 91 51 07 	lds	r22, 0x0751	; 0x800751 <KP_Counter>
    238e:	61 0f       	add	r22, r17
    2390:	48 2f       	mov	r20, r24
    2392:	50 e0       	ldi	r21, 0x00	; 0
    2394:	70 e0       	ldi	r23, 0x00	; 0
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>

                /*----------------->Adding New Password<-----------------*/
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter 4 numbers as password\r\n");
                for (Uint8 i = 0; i < 4; i++) {
    239e:	14 30       	cpi	r17, 0x04	; 4
    23a0:	78 f3       	brcs	.-34     	; 0x2380 <__vector_13+0xa32>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
                    EEPROM_WriteByte(1, j += KP_Counter, Pass[i]); // Adding the password in EEPROM
                }

                KP_Counter += 4; // Counter to determine the number of keypad users
    23a2:	40 91 51 07 	lds	r20, 0x0751	; 0x800751 <KP_Counter>
    23a6:	4c 5f       	subi	r20, 0xFC	; 252
    23a8:	40 93 51 07 	sts	0x0751, r20	; 0x800751 <KP_Counter>
                EEPROM_WriteByte(4, 0, KP_Counter); // Saving the counter in EEPROM
    23ac:	50 e0       	ldi	r21, 0x00	; 0
    23ae:	60 e0       	ldi	r22, 0x00	; 0
    23b0:	70 e0       	ldi	r23, 0x00	; 0
    23b2:	84 e0       	ldi	r24, 0x04	; 4
    23b4:	90 e0       	ldi	r25, 0x00	; 0
    23b6:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
    23ba:	9b c0       	rjmp	.+310    	; 0x24f2 <__vector_13+0xba4>
            } else if (UART_GetValue == '2') {
    23bc:	82 33       	cpi	r24, 0x32	; 50
    23be:	09 f0       	breq	.+2      	; 0x23c2 <__vector_13+0xa74>
    23c0:	4b c0       	rjmp	.+150    	; 0x2458 <__vector_13+0xb0a>
                /*--------------->Adding PC User<-------------------*/
                Uint8 j = 0;

                /*----------------->Adding New Username<-----------------*/
                UART_TX_Str("\r\n");
    23c2:	8d e0       	ldi	r24, 0x0D	; 13
    23c4:	92 e0       	ldi	r25, 0x02	; 2
    23c6:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    23ca:	8d e0       	ldi	r24, 0x0D	; 13
    23cc:	92 e0       	ldi	r25, 0x02	; 2
    23ce:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter 4 numbers as username\r\n");
    23d2:	8a e6       	ldi	r24, 0x6A	; 106
    23d4:	94 e0       	ldi	r25, 0x04	; 4
    23d6:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                for (Uint8 i = 0; i < 4; i++) {
    23da:	10 e0       	ldi	r17, 0x00	; 0
    23dc:	0f c0       	rjmp	.+30     	; 0x23fc <__vector_13+0xaae>
                    j = i + 1;
    23de:	1f 5f       	subi	r17, 0xFF	; 255
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    23e0:	5f 9b       	sbis	0x0b, 7	; 11
    23e2:	fe cf       	rjmp	.-4      	; 0x23e0 <__vector_13+0xa92>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
    23e4:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
                    EEPROM_WriteByte(2, j += PC_Counter, User[i]); // Adding the username in EEPROM
    23e8:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <PC_Counter>
    23ec:	61 0f       	add	r22, r17
    23ee:	48 2f       	mov	r20, r24
    23f0:	50 e0       	ldi	r21, 0x00	; 0
    23f2:	70 e0       	ldi	r23, 0x00	; 0
    23f4:	82 e0       	ldi	r24, 0x02	; 2
    23f6:	90 e0       	ldi	r25, 0x00	; 0
    23f8:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>

                /*----------------->Adding New Username<-----------------*/
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter 4 numbers as username\r\n");
                for (Uint8 i = 0; i < 4; i++) {
    23fc:	14 30       	cpi	r17, 0x04	; 4
    23fe:	78 f3       	brcs	.-34     	; 0x23de <__vector_13+0xa90>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
                    EEPROM_WriteByte(2, j += PC_Counter, User[i]); // Adding the username in EEPROM
                }

                /*----------------->Adding New Password<-----------------*/
                UART_TX_Str("\r\n");
    2400:	8d e0       	ldi	r24, 0x0D	; 13
    2402:	92 e0       	ldi	r25, 0x02	; 2
    2404:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    2408:	8d e0       	ldi	r24, 0x0D	; 13
    240a:	92 e0       	ldi	r25, 0x02	; 2
    240c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter 4 numbers as password\r\n");
    2410:	8f e8       	ldi	r24, 0x8F	; 143
    2412:	94 e0       	ldi	r25, 0x04	; 4
    2414:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                for (Uint8 i = 0; i < 4; i++) {
    2418:	10 e0       	ldi	r17, 0x00	; 0
    241a:	0f c0       	rjmp	.+30     	; 0x243a <__vector_13+0xaec>
                    j = i + 1;
    241c:	1f 5f       	subi	r17, 0xFF	; 255
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    241e:	5f 9b       	sbis	0x0b, 7	; 11
    2420:	fe cf       	rjmp	.-4      	; 0x241e <__vector_13+0xad0>
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
    2422:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
                    EEPROM_WriteByte(3, j += PC_Counter, Pass[i]); // Adding the password in EEPROM
    2426:	60 91 50 07 	lds	r22, 0x0750	; 0x800750 <PC_Counter>
    242a:	61 0f       	add	r22, r17
    242c:	48 2f       	mov	r20, r24
    242e:	50 e0       	ldi	r21, 0x00	; 0
    2430:	70 e0       	ldi	r23, 0x00	; 0
    2432:	83 e0       	ldi	r24, 0x03	; 3
    2434:	90 e0       	ldi	r25, 0x00	; 0
    2436:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>

                /*----------------->Adding New Password<-----------------*/
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter 4 numbers as password\r\n");
                for (Uint8 i = 0; i < 4; i++) {
    243a:	14 30       	cpi	r17, 0x04	; 4
    243c:	78 f3       	brcs	.-34     	; 0x241c <__vector_13+0xace>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
                    EEPROM_WriteByte(3, j += PC_Counter, Pass[i]); // Adding the password in EEPROM
                }

                PC_Counter += 4; // Counter to determine the number of PC users
    243e:	40 91 50 07 	lds	r20, 0x0750	; 0x800750 <PC_Counter>
    2442:	4c 5f       	subi	r20, 0xFC	; 252
    2444:	40 93 50 07 	sts	0x0750, r20	; 0x800750 <PC_Counter>
                EEPROM_WriteByte(4, 1, PC_Counter); // Saving the counter in EEPROM
    2448:	50 e0       	ldi	r21, 0x00	; 0
    244a:	61 e0       	ldi	r22, 0x01	; 1
    244c:	70 e0       	ldi	r23, 0x00	; 0
    244e:	84 e0       	ldi	r24, 0x04	; 4
    2450:	90 e0       	ldi	r25, 0x00	; 0
    2452:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
    2456:	4d c0       	rjmp	.+154    	; 0x24f2 <__vector_13+0xba4>
            } else if (UART_GetValue == '3') {
    2458:	83 33       	cpi	r24, 0x33	; 51
    245a:	09 f0       	breq	.+2      	; 0x245e <__vector_13+0xb10>
    245c:	4a c0       	rjmp	.+148    	; 0x24f2 <__vector_13+0xba4>
                /*--------------->Adding Admin User<-------------------*/
                Uint8 j = 0;

                /*----------------->Adding New Username<-----------------*/
                UART_TX_Str("\r\n");
    245e:	8d e0       	ldi	r24, 0x0D	; 13
    2460:	92 e0       	ldi	r25, 0x02	; 2
    2462:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    2466:	8d e0       	ldi	r24, 0x0D	; 13
    2468:	92 e0       	ldi	r25, 0x02	; 2
    246a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter 4 numbers as username\r\n");
    246e:	8a e6       	ldi	r24, 0x6A	; 106
    2470:	94 e0       	ldi	r25, 0x04	; 4
    2472:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                for (Uint8 i = 0; i < 4; i++) {
    2476:	10 e0       	ldi	r17, 0x00	; 0
    2478:	0f c0       	rjmp	.+30     	; 0x2498 <__vector_13+0xb4a>
                    j = i + 1;
    247a:	1f 5f       	subi	r17, 0xFF	; 255
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    247c:	5f 9b       	sbis	0x0b, 7	; 11
    247e:	fe cf       	rjmp	.-4      	; 0x247c <__vector_13+0xb2e>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
    2480:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
                    EEPROM_WriteByte(5, j += AD_Counter, User[i]); // Adding the username in EEPROM
    2484:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <AD_Counter>
    2488:	61 0f       	add	r22, r17
    248a:	48 2f       	mov	r20, r24
    248c:	50 e0       	ldi	r21, 0x00	; 0
    248e:	70 e0       	ldi	r23, 0x00	; 0
    2490:	85 e0       	ldi	r24, 0x05	; 5
    2492:	90 e0       	ldi	r25, 0x00	; 0
    2494:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>

                /*----------------->Adding New Username<-----------------*/
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter 4 numbers as username\r\n");
                for (Uint8 i = 0; i < 4; i++) {
    2498:	14 30       	cpi	r17, 0x04	; 4
    249a:	78 f3       	brcs	.-34     	; 0x247a <__vector_13+0xb2c>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
                    EEPROM_WriteByte(5, j += AD_Counter, User[i]); // Adding the username in EEPROM
                }

                /*----------------->Adding New Password<-----------------*/
                UART_TX_Str("\r\n");
    249c:	8d e0       	ldi	r24, 0x0D	; 13
    249e:	92 e0       	ldi	r25, 0x02	; 2
    24a0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    24a4:	8d e0       	ldi	r24, 0x0D	; 13
    24a6:	92 e0       	ldi	r25, 0x02	; 2
    24a8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter 4 numbers as password\r\n");
    24ac:	8f e8       	ldi	r24, 0x8F	; 143
    24ae:	94 e0       	ldi	r25, 0x04	; 4
    24b0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                for (Uint8 i = 0; i < 4; i++) {
    24b4:	10 e0       	ldi	r17, 0x00	; 0
    24b6:	0f c0       	rjmp	.+30     	; 0x24d6 <__vector_13+0xb88>
                    j = i + 1;
    24b8:	1f 5f       	subi	r17, 0xFF	; 255
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    24ba:	5f 9b       	sbis	0x0b, 7	; 11
    24bc:	fe cf       	rjmp	.-4      	; 0x24ba <__vector_13+0xb6c>
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
    24be:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
                    EEPROM_WriteByte(6, j += AD_Counter, Pass[i]); // Adding the password in EEPROM
    24c2:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <AD_Counter>
    24c6:	61 0f       	add	r22, r17
    24c8:	48 2f       	mov	r20, r24
    24ca:	50 e0       	ldi	r21, 0x00	; 0
    24cc:	70 e0       	ldi	r23, 0x00	; 0
    24ce:	86 e0       	ldi	r24, 0x06	; 6
    24d0:	90 e0       	ldi	r25, 0x00	; 0
    24d2:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>

                /*----------------->Adding New Password<-----------------*/
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter 4 numbers as password\r\n");
                for (Uint8 i = 0; i < 4; i++) {
    24d6:	14 30       	cpi	r17, 0x04	; 4
    24d8:	78 f3       	brcs	.-34     	; 0x24b8 <__vector_13+0xb6a>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                    Pass[i] = UART_RX_Char(); // Receiving the character in password array
                    EEPROM_WriteByte(6, j += AD_Counter, Pass[i]); // Adding the password in EEPROM
                }

                AD_Counter += 4; // Counter to determine the number of PC users
    24da:	40 91 70 00 	lds	r20, 0x0070	; 0x800070 <AD_Counter>
    24de:	4c 5f       	subi	r20, 0xFC	; 252
    24e0:	40 93 70 00 	sts	0x0070, r20	; 0x800070 <AD_Counter>
                EEPROM_WriteByte(4, 2, AD_Counter); // Saving the counter in EEPROM
    24e4:	50 e0       	ldi	r21, 0x00	; 0
    24e6:	62 e0       	ldi	r22, 0x02	; 2
    24e8:	70 e0       	ldi	r23, 0x00	; 0
    24ea:	84 e0       	ldi	r24, 0x04	; 4
    24ec:	90 e0       	ldi	r25, 0x00	; 0
    24ee:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
            }

            /*------------>Added Successfully<-------------------*/
            UART_TX_Str("\r\n");
    24f2:	8d e0       	ldi	r24, 0x0D	; 13
    24f4:	92 e0       	ldi	r25, 0x02	; 2
    24f6:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    24fa:	8d e0       	ldi	r24, 0x0D	; 13
    24fc:	92 e0       	ldi	r25, 0x02	; 2
    24fe:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("User added successfully\r\n");
    2502:	84 eb       	ldi	r24, 0xB4	; 180
    2504:	94 e0       	ldi	r25, 0x04	; 4
    2506:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    250a:	33 c2       	rjmp	.+1126   	; 0x2972 <__vector_13+0x1024>
        } else if (UART_GetValue == '8') {
    250c:	88 33       	cpi	r24, 0x38	; 56
    250e:	09 f0       	breq	.+2      	; 0x2512 <__vector_13+0xbc4>
    2510:	11 c2       	rjmp	.+1058   	; 0x2934 <__vector_13+0xfe6>
            // Delete an exist user
            Uint8 j = 0;
            UART_TX_Str("\r\n");
    2512:	8d e0       	ldi	r24, 0x0D	; 13
    2514:	92 e0       	ldi	r25, 0x02	; 2
    2516:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    251a:	8d e0       	ldi	r24, 0x0D	; 13
    251c:	92 e0       	ldi	r25, 0x02	; 2
    251e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Do you want to delete keypad user , PC user or Admin user\r\n");
    2522:	8e ec       	ldi	r24, 0xCE	; 206
    2524:	94 e0       	ldi	r25, 0x04	; 4
    2526:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("1.Keypad User\r\n");
    252a:	8a e0       	ldi	r24, 0x0A	; 10
    252c:	95 e0       	ldi	r25, 0x05	; 5
    252e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("2.PC User\r\n");
    2532:	8a e1       	ldi	r24, 0x1A	; 26
    2534:	95 e0       	ldi	r25, 0x05	; 5
    2536:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("3.AD User\r\n");
    253a:	86 e2       	ldi	r24, 0x26	; 38
    253c:	95 e0       	ldi	r25, 0x05	; 5
    253e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

            while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2542:	5f 9b       	sbis	0x0b, 7	; 11
    2544:	fe cf       	rjmp	.-4      	; 0x2542 <__vector_13+0xbf4>
            UART_GetValue = UART_RX_Char(); // Receiving the command
    2546:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    254a:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>
	
			/*--------------->Deleting Keypad User<-------------------*/
            if (UART_GetValue == '1') {
    254e:	81 33       	cpi	r24, 0x31	; 49
    2550:	09 f0       	breq	.+2      	; 0x2554 <__vector_13+0xc06>
    2552:	9b c0       	rjmp	.+310    	; 0x268a <__vector_13+0xd3c>
                UART_TX_Str("\r\n");
    2554:	8d e0       	ldi	r24, 0x0D	; 13
    2556:	92 e0       	ldi	r25, 0x02	; 2
    2558:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    255c:	8d e0       	ldi	r24, 0x0D	; 13
    255e:	92 e0       	ldi	r25, 0x02	; 2
    2560:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter the KP username\r\n");
    2564:	82 e3       	ldi	r24, 0x32	; 50
    2566:	95 e0       	ldi	r25, 0x05	; 5
    2568:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

                for (Uint8 i = 0; i < 4; i++) {
    256c:	10 e0       	ldi	r17, 0x00	; 0
    256e:	0e c0       	rjmp	.+28     	; 0x258c <__vector_13+0xc3e>
                    while (!Get_Bit(UCSRA, 7));	// Polling until the user enter a character
    2570:	5f 9b       	sbis	0x0b, 7	; 11
    2572:	fe cf       	rjmp	.-4      	; 0x2570 <__vector_13+0xc22>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
    2574:	e1 2e       	mov	r14, r17
    2576:	f1 2c       	mov	r15, r1
    2578:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    257c:	e1 e0       	ldi	r30, 0x01	; 1
    257e:	f0 e0       	ldi	r31, 0x00	; 0
    2580:	ec 0f       	add	r30, r28
    2582:	fd 1f       	adc	r31, r29
    2584:	ee 0d       	add	r30, r14
    2586:	ff 1d       	adc	r31, r15
    2588:	80 83       	st	Z, r24
            if (UART_GetValue == '1') {
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter the KP username\r\n");

                for (Uint8 i = 0; i < 4; i++) {
    258a:	1f 5f       	subi	r17, 0xFF	; 255
    258c:	14 30       	cpi	r17, 0x04	; 4
    258e:	80 f3       	brcs	.-32     	; 0x2570 <__vector_13+0xc22>
    2590:	10 e0       	ldi	r17, 0x00	; 0
    2592:	f1 2c       	mov	r15, r1
    2594:	74 c0       	rjmp	.+232    	; 0x267e <__vector_13+0xd30>
                }

				/*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
					/*----------------->Username Check<------------------*/
                    if (User[0] == EEPROM_ReadByte(0, Check_Counter + 1) && User[1] == EEPROM_ReadByte(0, Check_Counter + 2) && User[2] == EEPROM_ReadByte(0, Check_Counter + 3) && User[3] == EEPROM_ReadByte(0, Check_Counter + 4)) {
    2596:	a9 80       	ldd	r10, Y+1	; 0x01
    2598:	b1 2c       	mov	r11, r1
    259a:	c1 2e       	mov	r12, r17
    259c:	d1 2c       	mov	r13, r1
    259e:	b6 01       	movw	r22, r12
    25a0:	6f 5f       	subi	r22, 0xFF	; 255
    25a2:	7f 4f       	sbci	r23, 0xFF	; 255
    25a4:	80 e0       	ldi	r24, 0x00	; 0
    25a6:	90 e0       	ldi	r25, 0x00	; 0
    25a8:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    25ac:	a8 16       	cp	r10, r24
    25ae:	b9 06       	cpc	r11, r25
    25b0:	09 f0       	breq	.+2      	; 0x25b4 <__vector_13+0xc66>
    25b2:	64 c0       	rjmp	.+200    	; 0x267c <__vector_13+0xd2e>
    25b4:	aa 80       	ldd	r10, Y+2	; 0x02
    25b6:	b1 2c       	mov	r11, r1
    25b8:	b6 01       	movw	r22, r12
    25ba:	6e 5f       	subi	r22, 0xFE	; 254
    25bc:	7f 4f       	sbci	r23, 0xFF	; 255
    25be:	80 e0       	ldi	r24, 0x00	; 0
    25c0:	90 e0       	ldi	r25, 0x00	; 0
    25c2:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    25c6:	a8 16       	cp	r10, r24
    25c8:	b9 06       	cpc	r11, r25
    25ca:	09 f0       	breq	.+2      	; 0x25ce <__vector_13+0xc80>
    25cc:	57 c0       	rjmp	.+174    	; 0x267c <__vector_13+0xd2e>
    25ce:	ab 80       	ldd	r10, Y+3	; 0x03
    25d0:	b1 2c       	mov	r11, r1
    25d2:	b6 01       	movw	r22, r12
    25d4:	6d 5f       	subi	r22, 0xFD	; 253
    25d6:	7f 4f       	sbci	r23, 0xFF	; 255
    25d8:	80 e0       	ldi	r24, 0x00	; 0
    25da:	90 e0       	ldi	r25, 0x00	; 0
    25dc:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    25e0:	a8 16       	cp	r10, r24
    25e2:	b9 06       	cpc	r11, r25
    25e4:	09 f0       	breq	.+2      	; 0x25e8 <__vector_13+0xc9a>
    25e6:	4a c0       	rjmp	.+148    	; 0x267c <__vector_13+0xd2e>
    25e8:	ac 80       	ldd	r10, Y+4	; 0x04
    25ea:	b1 2c       	mov	r11, r1
    25ec:	b6 01       	movw	r22, r12
    25ee:	6c 5f       	subi	r22, 0xFC	; 252
    25f0:	7f 4f       	sbci	r23, 0xFF	; 255
    25f2:	80 e0       	ldi	r24, 0x00	; 0
    25f4:	90 e0       	ldi	r25, 0x00	; 0
    25f6:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    25fa:	a8 16       	cp	r10, r24
    25fc:	b9 06       	cpc	r11, r25
    25fe:	f1 f5       	brne	.+124    	; 0x267c <__vector_13+0xd2e>
							/*----------------->Exist  Username<-----------------*/
							// Shifting username/password characters and overwrite on the desired user to be deleted
							for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= KP_Counter; Check_Counter_2++) {
    2600:	1f 5f       	subi	r17, 0xFF	; 255
    2602:	1d c0       	rjmp	.+58     	; 0x263e <__vector_13+0xcf0>
								EEPROM_WriteByte(0, Check_Counter_2, EEPROM_ReadByte(0, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward 
    2604:	e1 2e       	mov	r14, r17
    2606:	f1 2c       	mov	r15, r1
    2608:	67 01       	movw	r12, r14
    260a:	84 e0       	ldi	r24, 0x04	; 4
    260c:	c8 0e       	add	r12, r24
    260e:	d1 1c       	adc	r13, r1
    2610:	b6 01       	movw	r22, r12
    2612:	80 e0       	ldi	r24, 0x00	; 0
    2614:	90 e0       	ldi	r25, 0x00	; 0
    2616:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    261a:	ac 01       	movw	r20, r24
    261c:	b7 01       	movw	r22, r14
    261e:	80 e0       	ldi	r24, 0x00	; 0
    2620:	90 e0       	ldi	r25, 0x00	; 0
    2622:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
								EEPROM_WriteByte(1, Check_Counter_2, EEPROM_ReadByte(1, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
    2626:	b6 01       	movw	r22, r12
    2628:	81 e0       	ldi	r24, 0x01	; 1
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    2630:	ac 01       	movw	r20, r24
    2632:	b7 01       	movw	r22, r14
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
                for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
					/*----------------->Username Check<------------------*/
                    if (User[0] == EEPROM_ReadByte(0, Check_Counter + 1) && User[1] == EEPROM_ReadByte(0, Check_Counter + 2) && User[2] == EEPROM_ReadByte(0, Check_Counter + 3) && User[3] == EEPROM_ReadByte(0, Check_Counter + 4)) {
							/*----------------->Exist  Username<-----------------*/
							// Shifting username/password characters and overwrite on the desired user to be deleted
							for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= KP_Counter; Check_Counter_2++) {
    263c:	1f 5f       	subi	r17, 0xFF	; 255
    263e:	40 91 51 07 	lds	r20, 0x0751	; 0x800751 <KP_Counter>
    2642:	41 17       	cp	r20, r17
    2644:	f8 f6       	brcc	.-66     	; 0x2604 <__vector_13+0xcb6>
								EEPROM_WriteByte(0, Check_Counter_2, EEPROM_ReadByte(0, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward 
								EEPROM_WriteByte(1, Check_Counter_2, EEPROM_ReadByte(1, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
							}
						
                        KP_Counter -= 4; // Reduce the number of users in counter
    2646:	44 50       	subi	r20, 0x04	; 4
    2648:	40 93 51 07 	sts	0x0751, r20	; 0x800751 <KP_Counter>
                        EEPROM_WriteByte(4, 0, KP_Counter); // Saving the counter
    264c:	50 e0       	ldi	r21, 0x00	; 0
    264e:	60 e0       	ldi	r22, 0x00	; 0
    2650:	70 e0       	ldi	r23, 0x00	; 0
    2652:	84 e0       	ldi	r24, 0x04	; 4
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
                        Check_Counter = KP_Counter + 1; // Exiting the check for loop
    265a:	10 91 51 07 	lds	r17, 0x0751	; 0x800751 <KP_Counter>
    265e:	1f 5f       	subi	r17, 0xFF	; 255
                        UART_TX_Str("\r\n");
    2660:	8d e0       	ldi	r24, 0x0D	; 13
    2662:	92 e0       	ldi	r25, 0x02	; 2
    2664:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    2668:	8d e0       	ldi	r24, 0x0D	; 13
    266a:	92 e0       	ldi	r25, 0x02	; 2
    266c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        UART_TX_Str("User deleted successfully\r\n");
    2670:	81 e5       	ldi	r24, 0x51	; 81
    2672:	95 e0       	ldi	r25, 0x05	; 5
    2674:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        j = 1; // To determine whether we find the user or not
    2678:	ff 24       	eor	r15, r15
    267a:	f3 94       	inc	r15
                    while (!Get_Bit(UCSRA, 7));	// Polling until the user enter a character
                    User[i] = UART_RX_Char(); // Receiving the character in username array
                }

				/*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
    267c:	1c 5f       	subi	r17, 0xFC	; 252
    267e:	80 91 51 07 	lds	r24, 0x0751	; 0x800751 <KP_Counter>
    2682:	81 17       	cp	r24, r17
    2684:	08 f0       	brcs	.+2      	; 0x2688 <__vector_13+0xd3a>
    2686:	87 cf       	rjmp	.-242    	; 0x2596 <__vector_13+0xc48>
    2688:	46 c1       	rjmp	.+652    	; 0x2916 <__vector_13+0xfc8>
                        j = 1; // To determine whether we find the user or not
                    }
                }
            }
			/*--------------->Deleting PC User<-------------------*/ 
			else if (UART_GetValue == '2') {
    268a:	82 33       	cpi	r24, 0x32	; 50
    268c:	09 f0       	breq	.+2      	; 0x2690 <__vector_13+0xd42>
    268e:	9b c0       	rjmp	.+310    	; 0x27c6 <__vector_13+0xe78>
                UART_TX_Str("\r\n");
    2690:	8d e0       	ldi	r24, 0x0D	; 13
    2692:	92 e0       	ldi	r25, 0x02	; 2
    2694:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    2698:	8d e0       	ldi	r24, 0x0D	; 13
    269a:	92 e0       	ldi	r25, 0x02	; 2
    269c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter the PC username\r\n");
    26a0:	8d e6       	ldi	r24, 0x6D	; 109
    26a2:	95 e0       	ldi	r25, 0x05	; 5
    26a4:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
				
                for (Uint8 i = 0; i < 4; i++) {
    26a8:	10 e0       	ldi	r17, 0x00	; 0
    26aa:	0e c0       	rjmp	.+28     	; 0x26c8 <__vector_13+0xd7a>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    26ac:	5f 9b       	sbis	0x0b, 7	; 11
    26ae:	fe cf       	rjmp	.-4      	; 0x26ac <__vector_13+0xd5e>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
    26b0:	e1 2e       	mov	r14, r17
    26b2:	f1 2c       	mov	r15, r1
    26b4:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    26b8:	e1 e0       	ldi	r30, 0x01	; 1
    26ba:	f0 e0       	ldi	r31, 0x00	; 0
    26bc:	ec 0f       	add	r30, r28
    26be:	fd 1f       	adc	r31, r29
    26c0:	ee 0d       	add	r30, r14
    26c2:	ff 1d       	adc	r31, r15
    26c4:	80 83       	st	Z, r24
			else if (UART_GetValue == '2') {
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter the PC username\r\n");
				
                for (Uint8 i = 0; i < 4; i++) {
    26c6:	1f 5f       	subi	r17, 0xFF	; 255
    26c8:	14 30       	cpi	r17, 0x04	; 4
    26ca:	80 f3       	brcs	.-32     	; 0x26ac <__vector_13+0xd5e>
    26cc:	10 e0       	ldi	r17, 0x00	; 0
    26ce:	f1 2c       	mov	r15, r1
    26d0:	74 c0       	rjmp	.+232    	; 0x27ba <__vector_13+0xe6c>
                }

				/*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
					/*----------------->Username Check<------------------*/
					if (User[0] == EEPROM_ReadByte(2, Check_Counter + 1) && User[1] == EEPROM_ReadByte(2, Check_Counter + 2) && User[2] == EEPROM_ReadByte(2, Check_Counter + 3) && User[3] == EEPROM_ReadByte(2, Check_Counter + 4)) {
    26d2:	a9 80       	ldd	r10, Y+1	; 0x01
    26d4:	b1 2c       	mov	r11, r1
    26d6:	c1 2e       	mov	r12, r17
    26d8:	d1 2c       	mov	r13, r1
    26da:	b6 01       	movw	r22, r12
    26dc:	6f 5f       	subi	r22, 0xFF	; 255
    26de:	7f 4f       	sbci	r23, 0xFF	; 255
    26e0:	82 e0       	ldi	r24, 0x02	; 2
    26e2:	90 e0       	ldi	r25, 0x00	; 0
    26e4:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    26e8:	a8 16       	cp	r10, r24
    26ea:	b9 06       	cpc	r11, r25
    26ec:	09 f0       	breq	.+2      	; 0x26f0 <__vector_13+0xda2>
    26ee:	64 c0       	rjmp	.+200    	; 0x27b8 <__vector_13+0xe6a>
    26f0:	aa 80       	ldd	r10, Y+2	; 0x02
    26f2:	b1 2c       	mov	r11, r1
    26f4:	b6 01       	movw	r22, r12
    26f6:	6e 5f       	subi	r22, 0xFE	; 254
    26f8:	7f 4f       	sbci	r23, 0xFF	; 255
    26fa:	82 e0       	ldi	r24, 0x02	; 2
    26fc:	90 e0       	ldi	r25, 0x00	; 0
    26fe:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    2702:	a8 16       	cp	r10, r24
    2704:	b9 06       	cpc	r11, r25
    2706:	09 f0       	breq	.+2      	; 0x270a <__vector_13+0xdbc>
    2708:	57 c0       	rjmp	.+174    	; 0x27b8 <__vector_13+0xe6a>
    270a:	ab 80       	ldd	r10, Y+3	; 0x03
    270c:	b1 2c       	mov	r11, r1
    270e:	b6 01       	movw	r22, r12
    2710:	6d 5f       	subi	r22, 0xFD	; 253
    2712:	7f 4f       	sbci	r23, 0xFF	; 255
    2714:	82 e0       	ldi	r24, 0x02	; 2
    2716:	90 e0       	ldi	r25, 0x00	; 0
    2718:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    271c:	a8 16       	cp	r10, r24
    271e:	b9 06       	cpc	r11, r25
    2720:	09 f0       	breq	.+2      	; 0x2724 <__vector_13+0xdd6>
    2722:	4a c0       	rjmp	.+148    	; 0x27b8 <__vector_13+0xe6a>
    2724:	ac 80       	ldd	r10, Y+4	; 0x04
    2726:	b1 2c       	mov	r11, r1
    2728:	b6 01       	movw	r22, r12
    272a:	6c 5f       	subi	r22, 0xFC	; 252
    272c:	7f 4f       	sbci	r23, 0xFF	; 255
    272e:	82 e0       	ldi	r24, 0x02	; 2
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    2736:	a8 16       	cp	r10, r24
    2738:	b9 06       	cpc	r11, r25
    273a:	f1 f5       	brne	.+124    	; 0x27b8 <__vector_13+0xe6a>
                        /*----------------->Exist  Username<-----------------*/
                        // Shifting username/password characters and overwrite on the desired user to be deleted
                        for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= PC_Counter; Check_Counter_2++) {
    273c:	1f 5f       	subi	r17, 0xFF	; 255
    273e:	1d c0       	rjmp	.+58     	; 0x277a <__vector_13+0xe2c>
                            EEPROM_WriteByte(2, Check_Counter_2, EEPROM_ReadByte(2, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward 
    2740:	e1 2e       	mov	r14, r17
    2742:	f1 2c       	mov	r15, r1
    2744:	67 01       	movw	r12, r14
    2746:	84 e0       	ldi	r24, 0x04	; 4
    2748:	c8 0e       	add	r12, r24
    274a:	d1 1c       	adc	r13, r1
    274c:	b6 01       	movw	r22, r12
    274e:	82 e0       	ldi	r24, 0x02	; 2
    2750:	90 e0       	ldi	r25, 0x00	; 0
    2752:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    2756:	ac 01       	movw	r20, r24
    2758:	b7 01       	movw	r22, r14
    275a:	82 e0       	ldi	r24, 0x02	; 2
    275c:	90 e0       	ldi	r25, 0x00	; 0
    275e:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
                            EEPROM_WriteByte(3, Check_Counter_2, EEPROM_ReadByte(3, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
    2762:	b6 01       	movw	r22, r12
    2764:	83 e0       	ldi	r24, 0x03	; 3
    2766:	90 e0       	ldi	r25, 0x00	; 0
    2768:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    276c:	ac 01       	movw	r20, r24
    276e:	b7 01       	movw	r22, r14
    2770:	83 e0       	ldi	r24, 0x03	; 3
    2772:	90 e0       	ldi	r25, 0x00	; 0
    2774:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
					/*----------------->Username Check<------------------*/
					if (User[0] == EEPROM_ReadByte(2, Check_Counter + 1) && User[1] == EEPROM_ReadByte(2, Check_Counter + 2) && User[2] == EEPROM_ReadByte(2, Check_Counter + 3) && User[3] == EEPROM_ReadByte(2, Check_Counter + 4)) {
                        /*----------------->Exist  Username<-----------------*/
                        // Shifting username/password characters and overwrite on the desired user to be deleted
                        for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= PC_Counter; Check_Counter_2++) {
    2778:	1f 5f       	subi	r17, 0xFF	; 255
    277a:	40 91 50 07 	lds	r20, 0x0750	; 0x800750 <PC_Counter>
    277e:	41 17       	cp	r20, r17
    2780:	f8 f6       	brcc	.-66     	; 0x2740 <__vector_13+0xdf2>
                            EEPROM_WriteByte(2, Check_Counter_2, EEPROM_ReadByte(2, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward 
                            EEPROM_WriteByte(3, Check_Counter_2, EEPROM_ReadByte(3, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
                        }

                        PC_Counter -= 4; // Reduce the number of users in counter
    2782:	44 50       	subi	r20, 0x04	; 4
    2784:	40 93 50 07 	sts	0x0750, r20	; 0x800750 <PC_Counter>
                        EEPROM_WriteByte(4, 1, PC_Counter); // Saving the counter
    2788:	50 e0       	ldi	r21, 0x00	; 0
    278a:	61 e0       	ldi	r22, 0x01	; 1
    278c:	70 e0       	ldi	r23, 0x00	; 0
    278e:	84 e0       	ldi	r24, 0x04	; 4
    2790:	90 e0       	ldi	r25, 0x00	; 0
    2792:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
                        Check_Counter = PC_Counter + 1; // Exiting the check for loop
    2796:	10 91 50 07 	lds	r17, 0x0750	; 0x800750 <PC_Counter>
    279a:	1f 5f       	subi	r17, 0xFF	; 255
                        UART_TX_Str("\r\n");
    279c:	8d e0       	ldi	r24, 0x0D	; 13
    279e:	92 e0       	ldi	r25, 0x02	; 2
    27a0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    27a4:	8d e0       	ldi	r24, 0x0D	; 13
    27a6:	92 e0       	ldi	r25, 0x02	; 2
    27a8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        UART_TX_Str("User deleted successfully\r\n");
    27ac:	81 e5       	ldi	r24, 0x51	; 81
    27ae:	95 e0       	ldi	r25, 0x05	; 5
    27b0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        j = 1; // To determine whether we find the user or not
    27b4:	ff 24       	eor	r15, r15
    27b6:	f3 94       	inc	r15
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                    User[i] = UART_RX_Char(); // Receiving the character in username array
                }

				/*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
    27b8:	1c 5f       	subi	r17, 0xFC	; 252
    27ba:	80 91 50 07 	lds	r24, 0x0750	; 0x800750 <PC_Counter>
    27be:	81 17       	cp	r24, r17
    27c0:	08 f0       	brcs	.+2      	; 0x27c4 <__vector_13+0xe76>
    27c2:	87 cf       	rjmp	.-242    	; 0x26d2 <__vector_13+0xd84>
    27c4:	a8 c0       	rjmp	.+336    	; 0x2916 <__vector_13+0xfc8>
                        j = 1; // To determine whether we find the user or not
                    }
                }
            }
			/*--------------->Deleting Admin User<-------------------*/ 
			else if (UART_GetValue == '3') {
    27c6:	83 33       	cpi	r24, 0x33	; 51
    27c8:	09 f0       	breq	.+2      	; 0x27cc <__vector_13+0xe7e>
    27ca:	a4 c0       	rjmp	.+328    	; 0x2914 <__vector_13+0xfc6>
                UART_TX_Str("\r\n");
    27cc:	8d e0       	ldi	r24, 0x0D	; 13
    27ce:	92 e0       	ldi	r25, 0x02	; 2
    27d0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("\r\n");
    27d4:	8d e0       	ldi	r24, 0x0D	; 13
    27d6:	92 e0       	ldi	r25, 0x02	; 2
    27d8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                UART_TX_Str("Please enter the AD username\r\n");
    27dc:	8c e8       	ldi	r24, 0x8C	; 140
    27de:	95 e0       	ldi	r25, 0x05	; 5
    27e0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

                for (Uint8 i = 0; i < 4; i++) {
    27e4:	10 e0       	ldi	r17, 0x00	; 0
    27e6:	0e c0       	rjmp	.+28     	; 0x2804 <__vector_13+0xeb6>
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    27e8:	5f 9b       	sbis	0x0b, 7	; 11
    27ea:	fe cf       	rjmp	.-4      	; 0x27e8 <__vector_13+0xe9a>
                    User[i] = UART_RX_Char(); // Receiving the character in username array
    27ec:	e1 2e       	mov	r14, r17
    27ee:	f1 2c       	mov	r15, r1
    27f0:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    27f4:	e1 e0       	ldi	r30, 0x01	; 1
    27f6:	f0 e0       	ldi	r31, 0x00	; 0
    27f8:	ec 0f       	add	r30, r28
    27fa:	fd 1f       	adc	r31, r29
    27fc:	ee 0d       	add	r30, r14
    27fe:	ff 1d       	adc	r31, r15
    2800:	80 83       	st	Z, r24
			else if (UART_GetValue == '3') {
                UART_TX_Str("\r\n");
                UART_TX_Str("\r\n");
                UART_TX_Str("Please enter the AD username\r\n");

                for (Uint8 i = 0; i < 4; i++) {
    2802:	1f 5f       	subi	r17, 0xFF	; 255
    2804:	14 30       	cpi	r17, 0x04	; 4
    2806:	80 f3       	brcs	.-32     	; 0x27e8 <__vector_13+0xe9a>
    2808:	04 e0       	ldi	r16, 0x04	; 4
    280a:	f1 2c       	mov	r15, r1
    280c:	7d c0       	rjmp	.+250    	; 0x2908 <__vector_13+0xfba>
                }
				
				/*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                for (Uint8 Check_Counter = 4; Check_Counter <= AD_Counter; Check_Counter += 4) {
					/*----------------->Username Check<------------------*/
                    if (User[0] == EEPROM_ReadByte(5, Check_Counter + 1) && User[1] == EEPROM_ReadByte(5, Check_Counter + 2) && User[2] == EEPROM_ReadByte(5, Check_Counter + 3) && User[3] == EEPROM_ReadByte(5, Check_Counter + 4)) {
    280e:	a9 80       	ldd	r10, Y+1	; 0x01
    2810:	b1 2c       	mov	r11, r1
    2812:	c0 2e       	mov	r12, r16
    2814:	d1 2c       	mov	r13, r1
    2816:	b6 01       	movw	r22, r12
    2818:	6f 5f       	subi	r22, 0xFF	; 255
    281a:	7f 4f       	sbci	r23, 0xFF	; 255
    281c:	85 e0       	ldi	r24, 0x05	; 5
    281e:	90 e0       	ldi	r25, 0x00	; 0
    2820:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    2824:	a8 16       	cp	r10, r24
    2826:	b9 06       	cpc	r11, r25
    2828:	09 f0       	breq	.+2      	; 0x282c <__vector_13+0xede>
    282a:	6d c0       	rjmp	.+218    	; 0x2906 <__vector_13+0xfb8>
    282c:	aa 80       	ldd	r10, Y+2	; 0x02
    282e:	b1 2c       	mov	r11, r1
    2830:	b6 01       	movw	r22, r12
    2832:	6e 5f       	subi	r22, 0xFE	; 254
    2834:	7f 4f       	sbci	r23, 0xFF	; 255
    2836:	85 e0       	ldi	r24, 0x05	; 5
    2838:	90 e0       	ldi	r25, 0x00	; 0
    283a:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    283e:	a8 16       	cp	r10, r24
    2840:	b9 06       	cpc	r11, r25
    2842:	09 f0       	breq	.+2      	; 0x2846 <__vector_13+0xef8>
    2844:	60 c0       	rjmp	.+192    	; 0x2906 <__vector_13+0xfb8>
    2846:	ab 80       	ldd	r10, Y+3	; 0x03
    2848:	b1 2c       	mov	r11, r1
    284a:	b6 01       	movw	r22, r12
    284c:	6d 5f       	subi	r22, 0xFD	; 253
    284e:	7f 4f       	sbci	r23, 0xFF	; 255
    2850:	85 e0       	ldi	r24, 0x05	; 5
    2852:	90 e0       	ldi	r25, 0x00	; 0
    2854:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    2858:	a8 16       	cp	r10, r24
    285a:	b9 06       	cpc	r11, r25
    285c:	09 f0       	breq	.+2      	; 0x2860 <__vector_13+0xf12>
    285e:	53 c0       	rjmp	.+166    	; 0x2906 <__vector_13+0xfb8>
    2860:	ac 80       	ldd	r10, Y+4	; 0x04
    2862:	b1 2c       	mov	r11, r1
    2864:	b6 01       	movw	r22, r12
    2866:	6c 5f       	subi	r22, 0xFC	; 252
    2868:	7f 4f       	sbci	r23, 0xFF	; 255
    286a:	85 e0       	ldi	r24, 0x05	; 5
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    2872:	a8 16       	cp	r10, r24
    2874:	b9 06       	cpc	r11, r25
    2876:	09 f0       	breq	.+2      	; 0x287a <__vector_13+0xf2c>
    2878:	46 c0       	rjmp	.+140    	; 0x2906 <__vector_13+0xfb8>
                        /*----------------->Exist  Username<-----------------*/
                        for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= AD_Counter; Check_Counter_2++) {
    287a:	11 e0       	ldi	r17, 0x01	; 1
    287c:	10 0f       	add	r17, r16
    287e:	1d c0       	rjmp	.+58     	; 0x28ba <__vector_13+0xf6c>
                            EEPROM_WriteByte(5, Check_Counter_2, EEPROM_ReadByte(5, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward
    2880:	e1 2e       	mov	r14, r17
    2882:	f1 2c       	mov	r15, r1
    2884:	67 01       	movw	r12, r14
    2886:	84 e0       	ldi	r24, 0x04	; 4
    2888:	c8 0e       	add	r12, r24
    288a:	d1 1c       	adc	r13, r1
    288c:	b6 01       	movw	r22, r12
    288e:	85 e0       	ldi	r24, 0x05	; 5
    2890:	90 e0       	ldi	r25, 0x00	; 0
    2892:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    2896:	ac 01       	movw	r20, r24
    2898:	b7 01       	movw	r22, r14
    289a:	85 e0       	ldi	r24, 0x05	; 5
    289c:	90 e0       	ldi	r25, 0x00	; 0
    289e:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
                            EEPROM_WriteByte(6, Check_Counter_2, EEPROM_ReadByte(6, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
    28a2:	b6 01       	movw	r22, r12
    28a4:	86 e0       	ldi	r24, 0x06	; 6
    28a6:	90 e0       	ldi	r25, 0x00	; 0
    28a8:	0e 94 3a 02 	call	0x474	; 0x474 <EEPROM_ReadByte>
    28ac:	ac 01       	movw	r20, r24
    28ae:	b7 01       	movw	r22, r14
    28b0:	86 e0       	ldi	r24, 0x06	; 6
    28b2:	90 e0       	ldi	r25, 0x00	; 0
    28b4:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
				/*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                for (Uint8 Check_Counter = 4; Check_Counter <= AD_Counter; Check_Counter += 4) {
					/*----------------->Username Check<------------------*/
                    if (User[0] == EEPROM_ReadByte(5, Check_Counter + 1) && User[1] == EEPROM_ReadByte(5, Check_Counter + 2) && User[2] == EEPROM_ReadByte(5, Check_Counter + 3) && User[3] == EEPROM_ReadByte(5, Check_Counter + 4)) {
                        /*----------------->Exist  Username<-----------------*/
                        for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= AD_Counter; Check_Counter_2++) {
    28b8:	1f 5f       	subi	r17, 0xFF	; 255
    28ba:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <AD_Counter>
    28be:	81 17       	cp	r24, r17
    28c0:	f8 f6       	brcc	.-66     	; 0x2880 <__vector_13+0xf32>
                            EEPROM_WriteByte(5, Check_Counter_2, EEPROM_ReadByte(5, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward
                            EEPROM_WriteByte(6, Check_Counter_2, EEPROM_ReadByte(6, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
                        }

                        AD_Counter -= 4; // Reduce the number of users in counter
    28c2:	9c ef       	ldi	r25, 0xFC	; 252
    28c4:	98 0f       	add	r25, r24
    28c6:	90 93 70 00 	sts	0x0070, r25	; 0x800070 <AD_Counter>
                        // To make sure that the main admin does not deleted
						if (Check_Counter == 0) {
    28ca:	01 11       	cpse	r16, r1
    28cc:	02 c0       	rjmp	.+4      	; 0x28d2 <__vector_13+0xf84>
                            AD_Counter += 4;
    28ce:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <AD_Counter>
                        }
                        EEPROM_WriteByte(4, 2, AD_Counter); // Saving the counter
    28d2:	40 91 70 00 	lds	r20, 0x0070	; 0x800070 <AD_Counter>
    28d6:	50 e0       	ldi	r21, 0x00	; 0
    28d8:	62 e0       	ldi	r22, 0x02	; 2
    28da:	70 e0       	ldi	r23, 0x00	; 0
    28dc:	84 e0       	ldi	r24, 0x04	; 4
    28de:	90 e0       	ldi	r25, 0x00	; 0
    28e0:	0e 94 19 02 	call	0x432	; 0x432 <EEPROM_WriteByte>
                        Check_Counter = AD_Counter + 1; // Exiting the check for loop
    28e4:	00 91 70 00 	lds	r16, 0x0070	; 0x800070 <AD_Counter>
    28e8:	0f 5f       	subi	r16, 0xFF	; 255
                        UART_TX_Str("\r\n");
    28ea:	8d e0       	ldi	r24, 0x0D	; 13
    28ec:	92 e0       	ldi	r25, 0x02	; 2
    28ee:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    28f2:	8d e0       	ldi	r24, 0x0D	; 13
    28f4:	92 e0       	ldi	r25, 0x02	; 2
    28f6:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        UART_TX_Str("User deleted successfully\r\n");
    28fa:	81 e5       	ldi	r24, 0x51	; 81
    28fc:	95 e0       	ldi	r25, 0x05	; 5
    28fe:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
                        j = 1; // To determine whether we find the user or not
    2902:	ff 24       	eor	r15, r15
    2904:	f3 94       	inc	r15
                    while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                    User[i] = UART_RX_Char(); // Receiving the character in username array
                }
				
				/*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                for (Uint8 Check_Counter = 4; Check_Counter <= AD_Counter; Check_Counter += 4) {
    2906:	0c 5f       	subi	r16, 0xFC	; 252
    2908:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <AD_Counter>
    290c:	80 17       	cp	r24, r16
    290e:	08 f0       	brcs	.+2      	; 0x2912 <__vector_13+0xfc4>
    2910:	7e cf       	rjmp	.-260    	; 0x280e <__vector_13+0xec0>
    2912:	01 c0       	rjmp	.+2      	; 0x2916 <__vector_13+0xfc8>
            UART_TX_Str("\r\n");
            UART_TX_Str("\r\n");
            UART_TX_Str("User added successfully\r\n");
        } else if (UART_GetValue == '8') {
            // Delete an exist user
            Uint8 j = 0;
    2914:	f1 2c       	mov	r15, r1
                        j = 1; // To determine whether we find the user or not
                    }
                }
            }
			// If we not find the user
			if (!j) {
    2916:	f1 10       	cpse	r15, r1
    2918:	2c c0       	rjmp	.+88     	; 0x2972 <__vector_13+0x1024>
				UART_TX_Str("\r\n");
    291a:	8d e0       	ldi	r24, 0x0D	; 13
    291c:	92 e0       	ldi	r25, 0x02	; 2
    291e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
				UART_TX_Str("\r\n");
    2922:	8d e0       	ldi	r24, 0x0D	; 13
    2924:	92 e0       	ldi	r25, 0x02	; 2
    2926:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
				UART_TX_Str("User is not exist\r\n");
    292a:	8b ea       	ldi	r24, 0xAB	; 171
    292c:	95 e0       	ldi	r25, 0x05	; 5
    292e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    2932:	1f c0       	rjmp	.+62     	; 0x2972 <__vector_13+0x1024>
			}
		}
		else if (UART_GetValue == '0'){
    2934:	80 33       	cpi	r24, 0x30	; 48
    2936:	79 f4       	brne	.+30     	; 0x2956 <__vector_13+0x1008>
			/*------------->Loging-Out From The System<--------------*/
			SYS_Check = 0; // 0 is the value that take the system to the login operation
    2938:	10 92 54 07 	sts	0x0754, r1	; 0x800754 <SYS_Check>
			UART_TX_Str("\r\n");
    293c:	8d e0       	ldi	r24, 0x0D	; 13
    293e:	92 e0       	ldi	r25, 0x02	; 2
    2940:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("\r\n");
    2944:	8d e0       	ldi	r24, 0x0D	; 13
    2946:	92 e0       	ldi	r25, 0x02	; 2
    2948:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("Bye-Bye user\r\n");
    294c:	8f eb       	ldi	r24, 0xBF	; 191
    294e:	95 e0       	ldi	r25, 0x05	; 5
    2950:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    2954:	0e c0       	rjmp	.+28     	; 0x2972 <__vector_13+0x1024>
		}
		
		// *Not Important to Know* where the CMD_Check take the system to do nothing and avoid any complicated link between login operation and admin logged-in oparation
		else if (UART_GetValue == 8) {
    2956:	88 30       	cpi	r24, 0x08	; 8
    2958:	61 f0       	breq	.+24     	; 0x2972 <__vector_13+0x1024>

        } 
		// If user entered wrong command
		else {
            UART_TX_Str("\r\n");
    295a:	8d e0       	ldi	r24, 0x0D	; 13
    295c:	92 e0       	ldi	r25, 0x02	; 2
    295e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    2962:	8d e0       	ldi	r24, 0x0D	; 13
    2964:	92 e0       	ldi	r25, 0x02	; 2
    2966:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Please enter command number\r\n");
    296a:	88 e7       	ldi	r24, 0x78	; 120
    296c:	92 e0       	ldi	r25, 0x02	; 2
    296e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        }
		
		// If there is a keypad user
		if(eme_check){
    2972:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2976:	88 23       	and	r24, r24
    2978:	81 f0       	breq	.+32     	; 0x299a <__vector_13+0x104c>
			if (UART_GetValue == '9'){
    297a:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART_GetValue>
    297e:	89 33       	cpi	r24, 0x39	; 57
    2980:	61 f4       	brne	.+24     	; 0x299a <__vector_13+0x104c>
				/*---------------->Firing Keypad User From The System<---------------*/
				eme_check = 0; // 0 is the value that take the system to the login operation for keypad also
    2982:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <eme_check>
				LCD_Clear();
    2986:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
				UART_TX_Str("\r\n");
    298a:	8d e0       	ldi	r24, 0x0D	; 13
    298c:	92 e0       	ldi	r25, 0x02	; 2
    298e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
				UART_TX_Str("Keypad user kicked out\r\n");
    2992:	8e ec       	ldi	r24, 0xCE	; 206
    2994:	95 e0       	ldi	r25, 0x05	; 5
    2996:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			}
		}
		
		/*--------------->Commands List<-----------------*/
		// If there is user
		if(SYS_Check){
    299a:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <SYS_Check>
    299e:	88 23       	and	r24, r24
    29a0:	09 f4       	brne	.+2      	; 0x29a4 <__vector_13+0x1056>
    29a2:	41 c0       	rjmp	.+130    	; 0x2a26 <__vector_13+0x10d8>
        UART_TX_Str("\r\n");
    29a4:	8d e0       	ldi	r24, 0x0D	; 13
    29a6:	92 e0       	ldi	r25, 0x02	; 2
    29a8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("Waiting for your command\r\n");
    29ac:	87 ee       	ldi	r24, 0xE7	; 231
    29ae:	95 e0       	ldi	r25, 0x05	; 5
    29b0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("\r\n");
    29b4:	8d e0       	ldi	r24, 0x0D	; 13
    29b6:	92 e0       	ldi	r25, 0x02	; 2
    29b8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("1.Open the door\r\n");
    29bc:	82 e0       	ldi	r24, 0x02	; 2
    29be:	96 e0       	ldi	r25, 0x06	; 6
    29c0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("2.Close the door\r\n");
    29c4:	84 e1       	ldi	r24, 0x14	; 20
    29c6:	96 e0       	ldi	r25, 0x06	; 6
    29c8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("3.Open lamps\r\n");
    29cc:	87 e2       	ldi	r24, 0x27	; 39
    29ce:	96 e0       	ldi	r25, 0x06	; 6
    29d0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("4.Close lamps\r\n");
    29d4:	86 e3       	ldi	r24, 0x36	; 54
    29d6:	96 e0       	ldi	r25, 0x06	; 6
    29d8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("5.Variant lamp\r\n");
    29dc:	86 e4       	ldi	r24, 0x46	; 70
    29de:	96 e0       	ldi	r25, 0x06	; 6
    29e0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
		UART_TX_Str("6.Display the temperature\r\n");
    29e4:	87 e5       	ldi	r24, 0x57	; 87
    29e6:	96 e0       	ldi	r25, 0x06	; 6
    29e8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("7.Add new user\r\n");
    29ec:	83 e7       	ldi	r24, 0x73	; 115
    29ee:	96 e0       	ldi	r25, 0x06	; 6
    29f0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("8.Delete exist user\r\n");
    29f4:	84 e8       	ldi	r24, 0x84	; 132
    29f6:	96 e0       	ldi	r25, 0x06	; 6
    29f8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
		if(eme_check)
    29fc:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2a00:	88 23       	and	r24, r24
    2a02:	21 f0       	breq	.+8      	; 0x2a0c <__vector_13+0x10be>
		UART_TX_Str("9.Fire Keypad user\r\n");
    2a04:	8a e9       	ldi	r24, 0x9A	; 154
    2a06:	96 e0       	ldi	r25, 0x06	; 6
    2a08:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
		UART_TX_Str("0.Logout\r\n");
    2a0c:	8f ea       	ldi	r24, 0xAF	; 175
    2a0e:	96 e0       	ldi	r25, 0x06	; 6
    2a10:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("Reply with the number of the command\r\n");
    2a14:	8a eb       	ldi	r24, 0xBA	; 186
    2a16:	96 e0       	ldi	r25, 0x06	; 6
    2a18:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("\r\n");
    2a1c:	8d e0       	ldi	r24, 0x0D	; 13
    2a1e:	92 e0       	ldi	r25, 0x02	; 2
    2a20:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    2a24:	c9 c2       	rjmp	.+1426   	; 0x2fb8 <__vector_13+0x166a>
		}
		// if there is not user
		else{
			UART_TX_Str("\r\n");
    2a26:	8d e0       	ldi	r24, 0x0D	; 13
    2a28:	92 e0       	ldi	r25, 0x02	; 2
    2a2a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("\r\n");
    2a2e:	8d e0       	ldi	r24, 0x0D	; 13
    2a30:	92 e0       	ldi	r25, 0x02	; 2
    2a32:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("1.Enter Admin\r\n");
    2a36:	86 e9       	ldi	r24, 0x96	; 150
    2a38:	92 e0       	ldi	r25, 0x02	; 2
    2a3a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("2.Enter User\r\n");
    2a3e:	86 ea       	ldi	r24, 0xA6	; 166
    2a40:	92 e0       	ldi	r25, 0x02	; 2
    2a42:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("\r\n");	
    2a46:	8d e0       	ldi	r24, 0x0D	; 13
    2a48:	92 e0       	ldi	r25, 0x02	; 2
    2a4a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    2a4e:	b4 c2       	rjmp	.+1384   	; 0x2fb8 <__vector_13+0x166a>
		}
		
    }
	/*----------> User Loged-in <----------*/
	else if (SYS_Check == 2) {
    2a50:	82 30       	cpi	r24, 0x02	; 2
    2a52:	09 f0       	breq	.+2      	; 0x2a56 <__vector_13+0x1108>
    2a54:	b1 c2       	rjmp	.+1378   	; 0x2fb8 <__vector_13+0x166a>
        UART_GetValue = UDR; // Receiving the command
    2a56:	8c b1       	in	r24, 0x0c	; 12
    2a58:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>
		
		// *Not Important to Know* it used to not take UART_Get value variable after login the system as 0 value (do nothing after entering the system)
        if (CMD_Check) {
    2a5c:	80 91 52 07 	lds	r24, 0x0752	; 0x800752 <CMD_Check>
    2a60:	88 23       	and	r24, r24
    2a62:	29 f0       	breq	.+10     	; 0x2a6e <__vector_13+0x1120>
            UART_GetValue = 8;
    2a64:	88 e0       	ldi	r24, 0x08	; 8
    2a66:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>
            CMD_Check = 0;
    2a6a:	10 92 52 07 	sts	0x0752, r1	; 0x800752 <CMD_Check>
        }

        if (UART_GetValue == '1') {
    2a6e:	80 91 55 07 	lds	r24, 0x0755	; 0x800755 <UART_GetValue>
    2a72:	81 33       	cpi	r24, 0x31	; 49
    2a74:	09 f0       	breq	.+2      	; 0x2a78 <__vector_13+0x112a>
    2a76:	8e c0       	rjmp	.+284    	; 0x2b94 <__vector_13+0x1246>
            // Open lamps
            UART_TX_Str("\r\n");
    2a78:	8d e0       	ldi	r24, 0x0D	; 13
    2a7a:	92 e0       	ldi	r25, 0x02	; 2
    2a7c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    2a80:	8d e0       	ldi	r24, 0x0D	; 13
    2a82:	92 e0       	ldi	r25, 0x02	; 2
    2a84:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Which lamp do you want to be opened(From 1 to 5)\r\n");
    2a88:	8f ec       	ldi	r24, 0xCF	; 207
    2a8a:	92 e0       	ldi	r25, 0x02	; 2
    2a8c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("6.All Lamps\r\n");
    2a90:	82 e0       	ldi	r24, 0x02	; 2
    2a92:	93 e0       	ldi	r25, 0x03	; 3
    2a94:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    2a98:	8d e0       	ldi	r24, 0x0D	; 13
    2a9a:	92 e0       	ldi	r25, 0x02	; 2
    2a9c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

            while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2aa0:	5f 9b       	sbis	0x0b, 7	; 11
    2aa2:	fe cf       	rjmp	.-4      	; 0x2aa0 <__vector_13+0x1152>
            UART_GetValue = UART_RX_Char(); // Receiving the command
    2aa4:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    2aa8:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>

            // Open first lamp
            if (UART_GetValue == '1') {
    2aac:	81 33       	cpi	r24, 0x31	; 49
    2aae:	69 f4       	brne	.+26     	; 0x2aca <__vector_13+0x117c>
	            LED0_ON();
    2ab0:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2ab4:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2ab8:	81 11       	cpse	r24, r1
    2aba:	61 c0       	rjmp	.+194    	; 0x2b7e <__vector_13+0x1230>
		            LCD_Clear();
    2abc:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(1) Opened");
    2ac0:	80 e1       	ldi	r24, 0x10	; 16
    2ac2:	93 e0       	ldi	r25, 0x03	; 3
    2ac4:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2ac8:	5a c0       	rjmp	.+180    	; 0x2b7e <__vector_13+0x1230>
	            }
            }
            // Open second lamp
            else if (UART_GetValue == '2') {
    2aca:	82 33       	cpi	r24, 0x32	; 50
    2acc:	69 f4       	brne	.+26     	; 0x2ae8 <__vector_13+0x119a>
	            LED1_ON();
    2ace:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <LED1_ON>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2ad2:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2ad6:	81 11       	cpse	r24, r1
    2ad8:	52 c0       	rjmp	.+164    	; 0x2b7e <__vector_13+0x1230>
		            LCD_Clear();
    2ada:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(2) Opened");
    2ade:	8f e1       	ldi	r24, 0x1F	; 31
    2ae0:	93 e0       	ldi	r25, 0x03	; 3
    2ae2:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2ae6:	4b c0       	rjmp	.+150    	; 0x2b7e <__vector_13+0x1230>
	            }
            }
            // Open third lamp
            else if (UART_GetValue == '3') {
    2ae8:	83 33       	cpi	r24, 0x33	; 51
    2aea:	69 f4       	brne	.+26     	; 0x2b06 <__vector_13+0x11b8>
	            LED2_ON();
    2aec:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2af0:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2af4:	81 11       	cpse	r24, r1
    2af6:	43 c0       	rjmp	.+134    	; 0x2b7e <__vector_13+0x1230>
		            LCD_Clear();
    2af8:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(3) Opened");
    2afc:	8e e2       	ldi	r24, 0x2E	; 46
    2afe:	93 e0       	ldi	r25, 0x03	; 3
    2b00:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2b04:	3c c0       	rjmp	.+120    	; 0x2b7e <__vector_13+0x1230>
	            }
            }
            // Open fourth lamp
            else if (UART_GetValue == '4') {
    2b06:	84 33       	cpi	r24, 0x34	; 52
    2b08:	69 f4       	brne	.+26     	; 0x2b24 <__vector_13+0x11d6>
	            LED3_ON();
    2b0a:	0e 94 f5 09 	call	0x13ea	; 0x13ea <LED3_ON>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2b0e:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2b12:	81 11       	cpse	r24, r1
    2b14:	34 c0       	rjmp	.+104    	; 0x2b7e <__vector_13+0x1230>
		            LCD_Clear();
    2b16:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(4) Opened");
    2b1a:	8d e3       	ldi	r24, 0x3D	; 61
    2b1c:	93 e0       	ldi	r25, 0x03	; 3
    2b1e:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2b22:	2d c0       	rjmp	.+90     	; 0x2b7e <__vector_13+0x1230>
	            }
            }
            // Open fifth lamp
            else if (UART_GetValue == '5') {
    2b24:	85 33       	cpi	r24, 0x35	; 53
    2b26:	69 f4       	brne	.+26     	; 0x2b42 <__vector_13+0x11f4>
	            LED4_ON();
    2b28:	0e 94 06 0a 	call	0x140c	; 0x140c <LED4_ON>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2b2c:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2b30:	81 11       	cpse	r24, r1
    2b32:	25 c0       	rjmp	.+74     	; 0x2b7e <__vector_13+0x1230>
		            LCD_Clear();
    2b34:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(5) Opened");
    2b38:	8c e4       	ldi	r24, 0x4C	; 76
    2b3a:	93 e0       	ldi	r25, 0x03	; 3
    2b3c:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2b40:	1e c0       	rjmp	.+60     	; 0x2b7e <__vector_13+0x1230>
	            }
            }
            // Open all lamps
            else if (UART_GetValue == '6') {
    2b42:	86 33       	cpi	r24, 0x36	; 54
    2b44:	e1 f4       	brne	.+56     	; 0x2b7e <__vector_13+0x1230>
	            LED0_ON();
    2b46:	0e 94 c2 09 	call	0x1384	; 0x1384 <LED0_ON>
	            LED1_ON();
    2b4a:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <LED1_ON>
	            LED2_ON();
    2b4e:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <LED2_ON>
	            LED3_ON();
    2b52:	0e 94 f5 09 	call	0x13ea	; 0x13ea <LED3_ON>
	            LED4_ON();
    2b56:	0e 94 06 0a 	call	0x140c	; 0x140c <LED4_ON>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2b5a:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2b5e:	81 11       	cpse	r24, r1
    2b60:	0e c0       	rjmp	.+28     	; 0x2b7e <__vector_13+0x1230>
		            LCD_Clear();
    2b62:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("All Lamps Are");
    2b66:	8b e5       	ldi	r24, 0x5B	; 91
    2b68:	93 e0       	ldi	r25, 0x03	; 3
    2b6a:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
		            LCD_Goto(1, 0);
    2b6e:	60 e0       	ldi	r22, 0x00	; 0
    2b70:	81 e0       	ldi	r24, 0x01	; 1
    2b72:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
		            LCD_Write_String("Opened");
    2b76:	88 e1       	ldi	r24, 0x18	; 24
    2b78:	93 e0       	ldi	r25, 0x03	; 3
    2b7a:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
	            }
            }
            // If there is no keypad user, using LCD to write & clear the operating device
            if (!eme_check)
    2b7e:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2b82:	81 11       	cpse	r24, r1
    2b84:	dc c1       	rjmp	.+952    	; 0x2f3e <__vector_13+0x15f0>
            Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    2b86:	60 ed       	ldi	r22, 0xD0	; 208
    2b88:	77 e0       	ldi	r23, 0x07	; 7
    2b8a:	80 e0       	ldi	r24, 0x00	; 0
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
    2b92:	d5 c1       	rjmp	.+938    	; 0x2f3e <__vector_13+0x15f0>
        } else if (UART_GetValue == '2') {
    2b94:	82 33       	cpi	r24, 0x32	; 50
    2b96:	09 f0       	breq	.+2      	; 0x2b9a <__vector_13+0x124c>
    2b98:	8e c0       	rjmp	.+284    	; 0x2cb6 <__vector_13+0x1368>
            // Close lamps
            UART_TX_Str("\r\n");
    2b9a:	8d e0       	ldi	r24, 0x0D	; 13
    2b9c:	92 e0       	ldi	r25, 0x02	; 2
    2b9e:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    2ba2:	8d e0       	ldi	r24, 0x0D	; 13
    2ba4:	92 e0       	ldi	r25, 0x02	; 2
    2ba6:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Which lamp do you want to be Closed(From 1 to 5)\r\n");
    2baa:	89 e6       	ldi	r24, 0x69	; 105
    2bac:	93 e0       	ldi	r25, 0x03	; 3
    2bae:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("6.All Lamps\r\n");
    2bb2:	82 e0       	ldi	r24, 0x02	; 2
    2bb4:	93 e0       	ldi	r25, 0x03	; 3
    2bb6:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    2bba:	8d e0       	ldi	r24, 0x0D	; 13
    2bbc:	92 e0       	ldi	r25, 0x02	; 2
    2bbe:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

            while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2bc2:	5f 9b       	sbis	0x0b, 7	; 11
    2bc4:	fe cf       	rjmp	.-4      	; 0x2bc2 <__vector_13+0x1274>
            UART_GetValue = UART_RX_Char(); // Receiving the command
    2bc6:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    2bca:	80 93 55 07 	sts	0x0755, r24	; 0x800755 <UART_GetValue>

            // CLose first lamp
            if (UART_GetValue == '1') {
    2bce:	81 33       	cpi	r24, 0x31	; 49
    2bd0:	69 f4       	brne	.+26     	; 0x2bec <__vector_13+0x129e>
	            LED0_OFF();
    2bd2:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2bd6:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2bda:	81 11       	cpse	r24, r1
    2bdc:	61 c0       	rjmp	.+194    	; 0x2ca0 <__vector_13+0x1352>
		            LCD_Clear();
    2bde:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(1) Closed");
    2be2:	8c e9       	ldi	r24, 0x9C	; 156
    2be4:	93 e0       	ldi	r25, 0x03	; 3
    2be6:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2bea:	5a c0       	rjmp	.+180    	; 0x2ca0 <__vector_13+0x1352>
	            }
            }
            // Close second lamp
            else if (UART_GetValue == '2') {
    2bec:	82 33       	cpi	r24, 0x32	; 50
    2bee:	69 f4       	brne	.+26     	; 0x2c0a <__vector_13+0x12bc>
	            LED1_OFF();
    2bf0:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <LED1_OFF>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2bf4:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2bf8:	81 11       	cpse	r24, r1
    2bfa:	52 c0       	rjmp	.+164    	; 0x2ca0 <__vector_13+0x1352>
		            LCD_Clear();
    2bfc:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(2) Closed");
    2c00:	8b ea       	ldi	r24, 0xAB	; 171
    2c02:	93 e0       	ldi	r25, 0x03	; 3
    2c04:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2c08:	4b c0       	rjmp	.+150    	; 0x2ca0 <__vector_13+0x1352>
	            }
            }
            // Close third lamp
            else if (UART_GetValue == '3') {
    2c0a:	83 33       	cpi	r24, 0x33	; 51
    2c0c:	69 f4       	brne	.+26     	; 0x2c28 <__vector_13+0x12da>
	            LED2_OFF();
    2c0e:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2c12:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2c16:	81 11       	cpse	r24, r1
    2c18:	43 c0       	rjmp	.+134    	; 0x2ca0 <__vector_13+0x1352>
		            LCD_Clear();
    2c1a:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(3) Closed");
    2c1e:	8a eb       	ldi	r24, 0xBA	; 186
    2c20:	93 e0       	ldi	r25, 0x03	; 3
    2c22:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2c26:	3c c0       	rjmp	.+120    	; 0x2ca0 <__vector_13+0x1352>
	            }
            }
            // Close fourth lamp
            else if (UART_GetValue == '4') {
    2c28:	84 33       	cpi	r24, 0x34	; 52
    2c2a:	69 f4       	brne	.+26     	; 0x2c46 <__vector_13+0x12f8>
	            LED3_OFF();
    2c2c:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <LED3_OFF>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2c30:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2c34:	81 11       	cpse	r24, r1
    2c36:	34 c0       	rjmp	.+104    	; 0x2ca0 <__vector_13+0x1352>
		            LCD_Clear();
    2c38:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(4) Closed");
    2c3c:	89 ec       	ldi	r24, 0xC9	; 201
    2c3e:	93 e0       	ldi	r25, 0x03	; 3
    2c40:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2c44:	2d c0       	rjmp	.+90     	; 0x2ca0 <__vector_13+0x1352>
	            }
            }
            // Close fifth lamp
            else if (UART_GetValue == '5') {
    2c46:	85 33       	cpi	r24, 0x35	; 53
    2c48:	69 f4       	brne	.+26     	; 0x2c64 <__vector_13+0x1316>
	            LED4_OFF();
    2c4a:	0e 94 0c 0a 	call	0x1418	; 0x1418 <LED4_OFF>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2c4e:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2c52:	81 11       	cpse	r24, r1
    2c54:	25 c0       	rjmp	.+74     	; 0x2ca0 <__vector_13+0x1352>
		            LCD_Clear();
    2c56:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
		            LCD_Write_String("Lamp(5) Closed");
    2c5a:	88 ed       	ldi	r24, 0xD8	; 216
    2c5c:	93 e0       	ldi	r25, 0x03	; 3
    2c5e:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
    2c62:	1e c0       	rjmp	.+60     	; 0x2ca0 <__vector_13+0x1352>
	            }
            }
            // Close all lamps
            else if (UART_GetValue == '6') {
    2c64:	86 33       	cpi	r24, 0x36	; 54
    2c66:	e1 f4       	brne	.+56     	; 0x2ca0 <__vector_13+0x1352>
	            LED0_OFF();
    2c68:	0e 94 c8 09 	call	0x1390	; 0x1390 <LED0_OFF>
	            LED1_OFF();
    2c6c:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <LED1_OFF>
	            LED2_OFF();
    2c70:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <LED2_OFF>
	            LED3_OFF();
    2c74:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <LED3_OFF>
	            LED4_OFF();
    2c78:	0e 94 0c 0a 	call	0x1418	; 0x1418 <LED4_OFF>
	            LCD_Clear();
    2c7c:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
	            // If there is no keypad user, using LCD to write the operating device
	            if (!eme_check) {
    2c80:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2c84:	81 11       	cpse	r24, r1
    2c86:	0c c0       	rjmp	.+24     	; 0x2ca0 <__vector_13+0x1352>
		            LCD_Write_String("All Lamps Are");
    2c88:	8b e5       	ldi	r24, 0x5B	; 91
    2c8a:	93 e0       	ldi	r25, 0x03	; 3
    2c8c:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
		            LCD_Goto(1, 0);
    2c90:	60 e0       	ldi	r22, 0x00	; 0
    2c92:	81 e0       	ldi	r24, 0x01	; 1
    2c94:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
		            LCD_Write_String("Closed");
    2c98:	84 ea       	ldi	r24, 0xA4	; 164
    2c9a:	93 e0       	ldi	r25, 0x03	; 3
    2c9c:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
	            }
            }
            // If there is no keypad user, using LCD to write & clear the operating device
            if (!eme_check)
    2ca0:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2ca4:	81 11       	cpse	r24, r1
    2ca6:	4b c1       	rjmp	.+662    	; 0x2f3e <__vector_13+0x15f0>
            Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    2ca8:	60 ed       	ldi	r22, 0xD0	; 208
    2caa:	77 e0       	ldi	r23, 0x07	; 7
    2cac:	80 e0       	ldi	r24, 0x00	; 0
    2cae:	90 e0       	ldi	r25, 0x00	; 0
    2cb0:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
    2cb4:	44 c1       	rjmp	.+648    	; 0x2f3e <__vector_13+0x15f0>
        } else if (UART_GetValue == '3') {
    2cb6:	83 33       	cpi	r24, 0x33	; 51
    2cb8:	09 f0       	breq	.+2      	; 0x2cbc <__vector_13+0x136e>
    2cba:	cf c0       	rjmp	.+414    	; 0x2e5a <__vector_13+0x150c>
            /*Dimmer circuit*/
            UART_TX_Str("\r\n");
    2cbc:	8d e0       	ldi	r24, 0x0D	; 13
    2cbe:	92 e0       	ldi	r25, 0x02	; 2
    2cc0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    2cc4:	8d e0       	ldi	r24, 0x0D	; 13
    2cc6:	92 e0       	ldi	r25, 0x02	; 2
    2cc8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Please enter the percentage of the lamp\r\n");
    2ccc:	87 ee       	ldi	r24, 0xE7	; 231
    2cce:	93 e0       	ldi	r25, 0x03	; 3
    2cd0:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    2cd4:	8d e0       	ldi	r24, 0x0D	; 13
    2cd6:	92 e0       	ldi	r25, 0x02	; 2
    2cd8:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

            Dimmer_Value = 0; // making sure that dimmer value equal 0
    2cdc:	10 92 49 07 	sts	0x0749, r1	; 0x800749 <Dimmer_Value>
    2ce0:	10 92 4a 07 	sts	0x074A, r1	; 0x80074a <Dimmer_Value+0x1>
    2ce4:	10 92 4b 07 	sts	0x074B, r1	; 0x80074b <Dimmer_Value+0x2>
    2ce8:	10 92 4c 07 	sts	0x074C, r1	; 0x80074c <Dimmer_Value+0x3>

            // Taking the dimmer value as characters
            for (Uint8 i = 0; i < 3; i++) {
    2cec:	00 e0       	ldi	r16, 0x00	; 0
    2cee:	38 c0       	rjmp	.+112    	; 0x2d60 <__vector_13+0x1412>
	            while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2cf0:	5f 9b       	sbis	0x0b, 7	; 11
    2cf2:	fe cf       	rjmp	.-4      	; 0x2cf0 <__vector_13+0x13a2>
	            Dimmer_Array[i] = UART_RX_Char(); // Receiving dimmer character values
    2cf4:	e0 2e       	mov	r14, r16
    2cf6:	f1 2c       	mov	r15, r1
    2cf8:	0e 94 a3 0c 	call	0x1946	; 0x1946 <UART_RX_Char>
    2cfc:	18 2f       	mov	r17, r24
    2cfe:	f7 01       	movw	r30, r14
    2d00:	e3 5b       	subi	r30, 0xB3	; 179
    2d02:	f8 4f       	sbci	r31, 0xF8	; 248
    2d04:	80 83       	st	Z, r24

	            // Converting Dimmer value from characters to integer to send it as duty cycle to timer(0)
	            if (Dimmer_Array[i] >= 48 && Dimmer_Array[i] <= 57) {
    2d06:	80 ed       	ldi	r24, 0xD0	; 208
    2d08:	81 0f       	add	r24, r17
    2d0a:	8a 30       	cpi	r24, 0x0A	; 10
    2d0c:	38 f5       	brcc	.+78     	; 0x2d5c <__vector_13+0x140e>
		            Dimmer_Value = Dimmer_Value * 10 + (Dimmer_Array[i] - 48);
    2d0e:	20 e0       	ldi	r18, 0x00	; 0
    2d10:	30 e0       	ldi	r19, 0x00	; 0
    2d12:	40 e2       	ldi	r20, 0x20	; 32
    2d14:	51 e4       	ldi	r21, 0x41	; 65
    2d16:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <Dimmer_Value>
    2d1a:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <Dimmer_Value+0x1>
    2d1e:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <Dimmer_Value+0x2>
    2d22:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <Dimmer_Value+0x3>
    2d26:	0e 94 d7 19 	call	0x33ae	; 0x33ae <__mulsf3>
    2d2a:	6b 01       	movw	r12, r22
    2d2c:	7c 01       	movw	r14, r24
    2d2e:	61 2f       	mov	r22, r17
    2d30:	70 e0       	ldi	r23, 0x00	; 0
    2d32:	60 53       	subi	r22, 0x30	; 48
    2d34:	71 09       	sbc	r23, r1
    2d36:	07 2e       	mov	r0, r23
    2d38:	00 0c       	add	r0, r0
    2d3a:	88 0b       	sbc	r24, r24
    2d3c:	99 0b       	sbc	r25, r25
    2d3e:	0e 94 22 19 	call	0x3244	; 0x3244 <__floatsisf>
    2d42:	a7 01       	movw	r20, r14
    2d44:	96 01       	movw	r18, r12
    2d46:	0e 94 0e 18 	call	0x301c	; 0x301c <__addsf3>
    2d4a:	60 93 49 07 	sts	0x0749, r22	; 0x800749 <Dimmer_Value>
    2d4e:	70 93 4a 07 	sts	0x074A, r23	; 0x80074a <Dimmer_Value+0x1>
    2d52:	80 93 4b 07 	sts	0x074B, r24	; 0x80074b <Dimmer_Value+0x2>
    2d56:	90 93 4c 07 	sts	0x074C, r25	; 0x80074c <Dimmer_Value+0x3>
    2d5a:	01 c0       	rjmp	.+2      	; 0x2d5e <__vector_13+0x1410>
	            }
	            // if the value of character not from 48 to 57 (which is the number characters in ASCII table) these means that user entered the desired value and want to  escape other values
	            else {
		            i = 5; // Exiting the for loop in which user enter the character values of dimmer circuit
    2d5c:	05 e0       	ldi	r16, 0x05	; 5
            UART_TX_Str("\r\n");

            Dimmer_Value = 0; // making sure that dimmer value equal 0

            // Taking the dimmer value as characters
            for (Uint8 i = 0; i < 3; i++) {
    2d5e:	0f 5f       	subi	r16, 0xFF	; 255
    2d60:	03 30       	cpi	r16, 0x03	; 3
    2d62:	30 f2       	brcs	.-116    	; 0x2cf0 <__vector_13+0x13a2>
	            }

            }
            
            // If there is no keypad user, using LCD to write the operating device
            if (!eme_check) {
    2d64:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2d68:	81 11       	cpse	r24, r1
    2d6a:	23 c0       	rjmp	.+70     	; 0x2db2 <__vector_13+0x1464>
	            LCD_Clear();
    2d6c:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
	            LCD_Write_String("Lamp ON!");
    2d70:	81 e1       	ldi	r24, 0x11	; 17
    2d72:	94 e0       	ldi	r25, 0x04	; 4
    2d74:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
	            LCD_Goto(1, 0);
    2d78:	60 e0       	ldi	r22, 0x00	; 0
    2d7a:	81 e0       	ldi	r24, 0x01	; 1
    2d7c:	0e 94 a4 09 	call	0x1348	; 0x1348 <LCD_Goto>
	            LCD_Write_String("Percentage:");
    2d80:	8a e1       	ldi	r24, 0x1A	; 26
    2d82:	94 e0       	ldi	r25, 0x04	; 4
    2d84:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
	            LCD_Write_Integer(Dimmer_Value);
    2d88:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <Dimmer_Value>
    2d8c:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <Dimmer_Value+0x1>
    2d90:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <Dimmer_Value+0x2>
    2d94:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <Dimmer_Value+0x3>
    2d98:	0e 94 f1 18 	call	0x31e2	; 0x31e2 <__fixunssfsi>
    2d9c:	0e 94 2d 09 	call	0x125a	; 0x125a <LCD_Write_Integer>
	            LCD_Write_Char('%');
    2da0:	85 e2       	ldi	r24, 0x25	; 37
    2da2:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <LCD_Write_Char>
	            Timer2_SetDelay(2000);
    2da6:	60 ed       	ldi	r22, 0xD0	; 208
    2da8:	77 e0       	ldi	r23, 0x07	; 7
    2daa:	80 e0       	ldi	r24, 0x00	; 0
    2dac:	90 e0       	ldi	r25, 0x00	; 0
    2dae:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
            }

            // To avoid twitch of dimmer lamp
            if (Dimmer_Value >= 58 && Dimmer_Value <= 60) {
    2db2:	c0 90 49 07 	lds	r12, 0x0749	; 0x800749 <Dimmer_Value>
    2db6:	d0 90 4a 07 	lds	r13, 0x074A	; 0x80074a <Dimmer_Value+0x1>
    2dba:	e0 90 4b 07 	lds	r14, 0x074B	; 0x80074b <Dimmer_Value+0x2>
    2dbe:	f0 90 4c 07 	lds	r15, 0x074C	; 0x80074c <Dimmer_Value+0x3>
    2dc2:	20 e0       	ldi	r18, 0x00	; 0
    2dc4:	30 e0       	ldi	r19, 0x00	; 0
    2dc6:	48 e6       	ldi	r20, 0x68	; 104
    2dc8:	52 e4       	ldi	r21, 0x42	; 66
    2dca:	c7 01       	movw	r24, r14
    2dcc:	b6 01       	movw	r22, r12
    2dce:	0e 94 d2 19 	call	0x33a4	; 0x33a4 <__gesf2>
    2dd2:	88 23       	and	r24, r24
    2dd4:	bc f0       	brlt	.+46     	; 0x2e04 <__vector_13+0x14b6>
    2dd6:	20 e0       	ldi	r18, 0x00	; 0
    2dd8:	30 e0       	ldi	r19, 0x00	; 0
    2dda:	40 e7       	ldi	r20, 0x70	; 112
    2ddc:	52 e4       	ldi	r21, 0x42	; 66
    2dde:	c7 01       	movw	r24, r14
    2de0:	b6 01       	movw	r22, r12
    2de2:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__cmpsf2>
    2de6:	18 16       	cp	r1, r24
    2de8:	6c f0       	brlt	.+26     	; 0x2e04 <__vector_13+0x14b6>
	            Dimmer_Value = 55;
    2dea:	80 e0       	ldi	r24, 0x00	; 0
    2dec:	90 e0       	ldi	r25, 0x00	; 0
    2dee:	ac e5       	ldi	r26, 0x5C	; 92
    2df0:	b2 e4       	ldi	r27, 0x42	; 66
    2df2:	80 93 49 07 	sts	0x0749, r24	; 0x800749 <Dimmer_Value>
    2df6:	90 93 4a 07 	sts	0x074A, r25	; 0x80074a <Dimmer_Value+0x1>
    2dfa:	a0 93 4b 07 	sts	0x074B, r26	; 0x80074b <Dimmer_Value+0x2>
    2dfe:	b0 93 4c 07 	sts	0x074C, r27	; 0x80074c <Dimmer_Value+0x3>
    2e02:	20 c0       	rjmp	.+64     	; 0x2e44 <__vector_13+0x14f6>
	            } else if (Dimmer_Value > 60 && Dimmer_Value <= 62) {
    2e04:	20 e0       	ldi	r18, 0x00	; 0
    2e06:	30 e0       	ldi	r19, 0x00	; 0
    2e08:	40 e7       	ldi	r20, 0x70	; 112
    2e0a:	52 e4       	ldi	r21, 0x42	; 66
    2e0c:	c7 01       	movw	r24, r14
    2e0e:	b6 01       	movw	r22, r12
    2e10:	0e 94 d2 19 	call	0x33a4	; 0x33a4 <__gesf2>
    2e14:	18 16       	cp	r1, r24
    2e16:	b4 f4       	brge	.+44     	; 0x2e44 <__vector_13+0x14f6>
    2e18:	20 e0       	ldi	r18, 0x00	; 0
    2e1a:	30 e0       	ldi	r19, 0x00	; 0
    2e1c:	48 e7       	ldi	r20, 0x78	; 120
    2e1e:	52 e4       	ldi	r21, 0x42	; 66
    2e20:	c7 01       	movw	r24, r14
    2e22:	b6 01       	movw	r22, r12
    2e24:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <__cmpsf2>
    2e28:	18 16       	cp	r1, r24
    2e2a:	64 f0       	brlt	.+24     	; 0x2e44 <__vector_13+0x14f6>
	            Dimmer_Value = 65;
    2e2c:	80 e0       	ldi	r24, 0x00	; 0
    2e2e:	90 e0       	ldi	r25, 0x00	; 0
    2e30:	a2 e8       	ldi	r26, 0x82	; 130
    2e32:	b2 e4       	ldi	r27, 0x42	; 66
    2e34:	80 93 49 07 	sts	0x0749, r24	; 0x800749 <Dimmer_Value>
    2e38:	90 93 4a 07 	sts	0x074A, r25	; 0x80074a <Dimmer_Value+0x1>
    2e3c:	a0 93 4b 07 	sts	0x074B, r26	; 0x80074b <Dimmer_Value+0x2>
    2e40:	b0 93 4c 07 	sts	0x074C, r27	; 0x80074c <Dimmer_Value+0x3>
            }

            PWM0_Gen(Dimmer_Value); // Sending dimmer as duty cycle to timer(0)
    2e44:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <Dimmer_Value>
    2e48:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <Dimmer_Value+0x1>
    2e4c:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <Dimmer_Value+0x2>
    2e50:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <Dimmer_Value+0x3>
    2e54:	0e 94 df 0a 	call	0x15be	; 0x15be <PWM0_Gen>
    2e58:	72 c0       	rjmp	.+228    	; 0x2f3e <__vector_13+0x15f0>
        }
		else if (UART_GetValue == '4') {
    2e5a:	84 33       	cpi	r24, 0x34	; 52
    2e5c:	09 f0       	breq	.+2      	; 0x2e60 <__vector_13+0x1512>
    2e5e:	50 c0       	rjmp	.+160    	; 0x2f00 <__vector_13+0x15b2>
			/*--------------->Display temperature<----------------*/
			// Declaring temperature array which take the temperature value from temperature integer that take its value from the temperature
			Uint8 Temp_array[2] = {
    2e60:	1a 86       	std	Y+10, r1	; 0x0a
    2e62:	19 86       	std	Y+9, r1	; 0x09
				0
			};
			Uint8 Temp_Divide = Temp; // Saving the value in other variable to do some operations
    2e64:	90 91 31 07 	lds	r25, 0x0731	; 0x800731 <Temp>
			
			// Converting the integer value to characters and saved in the temperature array
			for (Uint8 i = 0; i < 2; i++) {
    2e68:	20 e0       	ldi	r18, 0x00	; 0
    2e6a:	17 c0       	rjmp	.+46     	; 0x2e9a <__vector_13+0x154c>
				Temp_array[i] = Temp_Divide % 10;
    2e6c:	e9 e0       	ldi	r30, 0x09	; 9
    2e6e:	f0 e0       	ldi	r31, 0x00	; 0
    2e70:	ec 0f       	add	r30, r28
    2e72:	fd 1f       	adc	r31, r29
    2e74:	e2 0f       	add	r30, r18
    2e76:	f1 1d       	adc	r31, r1
    2e78:	8d ec       	ldi	r24, 0xCD	; 205
    2e7a:	98 9f       	mul	r25, r24
    2e7c:	81 2d       	mov	r24, r1
    2e7e:	11 24       	eor	r1, r1
    2e80:	86 95       	lsr	r24
    2e82:	86 95       	lsr	r24
    2e84:	86 95       	lsr	r24
    2e86:	48 2f       	mov	r20, r24
    2e88:	44 0f       	add	r20, r20
    2e8a:	34 2f       	mov	r19, r20
    2e8c:	33 0f       	add	r19, r19
    2e8e:	33 0f       	add	r19, r19
    2e90:	34 0f       	add	r19, r20
    2e92:	93 1b       	sub	r25, r19
    2e94:	90 83       	st	Z, r25
				Temp_Divide /= 10;
    2e96:	98 2f       	mov	r25, r24
				0
			};
			Uint8 Temp_Divide = Temp; // Saving the value in other variable to do some operations
			
			// Converting the integer value to characters and saved in the temperature array
			for (Uint8 i = 0; i < 2; i++) {
    2e98:	2f 5f       	subi	r18, 0xFF	; 255
    2e9a:	22 30       	cpi	r18, 0x02	; 2
    2e9c:	38 f3       	brcs	.-50     	; 0x2e6c <__vector_13+0x151e>
				Temp_array[i] = Temp_Divide % 10;
				Temp_Divide /= 10;
			}
			
			// Display the temperature
			UART_TX_Str("\r\n");
    2e9e:	8d e0       	ldi	r24, 0x0D	; 13
    2ea0:	92 e0       	ldi	r25, 0x02	; 2
    2ea2:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("\r\n");
    2ea6:	8d e0       	ldi	r24, 0x0D	; 13
    2ea8:	92 e0       	ldi	r25, 0x02	; 2
    2eaa:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("Temperature:\r\n");
    2eae:	86 e2       	ldi	r24, 0x26	; 38
    2eb0:	94 e0       	ldi	r25, 0x04	; 4
    2eb2:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Char(Temp_array[1] + 48);
    2eb6:	8a 85       	ldd	r24, Y+10	; 0x0a
    2eb8:	80 5d       	subi	r24, 0xD0	; 208
    2eba:	0e 94 8c 0c 	call	0x1918	; 0x1918 <UART_TX_Char>
			UART_TX_Char(Temp_array[0] + 48);
    2ebe:	89 85       	ldd	r24, Y+9	; 0x09
    2ec0:	80 5d       	subi	r24, 0xD0	; 208
    2ec2:	0e 94 8c 0c 	call	0x1918	; 0x1918 <UART_TX_Char>
			UART_TX_Str("\r\n");
    2ec6:	8d e0       	ldi	r24, 0x0D	; 13
    2ec8:	92 e0       	ldi	r25, 0x02	; 2
    2eca:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>

			// If there is no keypad user, using LCD to write the operating device
			if (!eme_check) {
    2ece:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <eme_check>
    2ed2:	81 11       	cpse	r24, r1
    2ed4:	34 c0       	rjmp	.+104    	; 0x2f3e <__vector_13+0x15f0>
				LCD_Clear();
    2ed6:	0e 94 a0 09 	call	0x1340	; 0x1340 <LCD_Clear>
				LCD_Write_String("Temperature:");
    2eda:	85 e3       	ldi	r24, 0x35	; 53
    2edc:	94 e0       	ldi	r25, 0x04	; 4
    2ede:	0e 94 1a 09 	call	0x1234	; 0x1234 <LCD_Write_String>
				LCD_Write_Integer(Temp);
    2ee2:	60 91 31 07 	lds	r22, 0x0731	; 0x800731 <Temp>
    2ee6:	70 91 32 07 	lds	r23, 0x0732	; 0x800732 <Temp+0x1>
    2eea:	80 e0       	ldi	r24, 0x00	; 0
    2eec:	90 e0       	ldi	r25, 0x00	; 0
    2eee:	0e 94 2d 09 	call	0x125a	; 0x125a <LCD_Write_Integer>
				Timer2_SetDelay(2000);
    2ef2:	60 ed       	ldi	r22, 0xD0	; 208
    2ef4:	77 e0       	ldi	r23, 0x07	; 7
    2ef6:	80 e0       	ldi	r24, 0x00	; 0
    2ef8:	90 e0       	ldi	r25, 0x00	; 0
    2efa:	0e 94 c8 0b 	call	0x1790	; 0x1790 <Timer2_SetDelay>
    2efe:	1f c0       	rjmp	.+62     	; 0x2f3e <__vector_13+0x15f0>
			}
		}
		else if (UART_GetValue == '0'){
    2f00:	80 33       	cpi	r24, 0x30	; 48
    2f02:	79 f4       	brne	.+30     	; 0x2f22 <__vector_13+0x15d4>
			/*------------->Loging-Out From The System<--------------*/
			SYS_Check = 0; // 0 is the value that take the system to the login operation
    2f04:	10 92 54 07 	sts	0x0754, r1	; 0x800754 <SYS_Check>
			UART_TX_Str("\r\n");
    2f08:	8d e0       	ldi	r24, 0x0D	; 13
    2f0a:	92 e0       	ldi	r25, 0x02	; 2
    2f0c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("\r\n");
    2f10:	8d e0       	ldi	r24, 0x0D	; 13
    2f12:	92 e0       	ldi	r25, 0x02	; 2
    2f14:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("Bye-Bye user\r\n");
    2f18:	8f eb       	ldi	r24, 0xBF	; 191
    2f1a:	95 e0       	ldi	r25, 0x05	; 5
    2f1c:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    2f20:	0e c0       	rjmp	.+28     	; 0x2f3e <__vector_13+0x15f0>
        } 
				// *Not Important to Know* where the CMD_Check take the system to do nothing and avoid any complicated link between login operation and admin logged-in oparation
		else if (UART_GetValue == 8) {
    2f22:	88 30       	cpi	r24, 0x08	; 8
    2f24:	61 f0       	breq	.+24     	; 0x2f3e <__vector_13+0x15f0>

        } 
		// Entering wrong command
		else {
            UART_TX_Str("\r\n");
    2f26:	8d e0       	ldi	r24, 0x0D	; 13
    2f28:	92 e0       	ldi	r25, 0x02	; 2
    2f2a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("\r\n");
    2f2e:	8d e0       	ldi	r24, 0x0D	; 13
    2f30:	92 e0       	ldi	r25, 0x02	; 2
    2f32:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
            UART_TX_Str("Please enter command number\r\n");
    2f36:	88 e7       	ldi	r24, 0x78	; 120
    2f38:	92 e0       	ldi	r25, 0x02	; 2
    2f3a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        }
		/*----------->Command List<--------------*/
		// If there is a user
		if (SYS_Check)
    2f3e:	80 91 54 07 	lds	r24, 0x0754	; 0x800754 <SYS_Check>
    2f42:	88 23       	and	r24, r24
    2f44:	69 f1       	breq	.+90     	; 0x2fa0 <__vector_13+0x1652>
		{
        UART_TX_Str("\r\n");
    2f46:	8d e0       	ldi	r24, 0x0D	; 13
    2f48:	92 e0       	ldi	r25, 0x02	; 2
    2f4a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("\r\n");
    2f4e:	8d e0       	ldi	r24, 0x0D	; 13
    2f50:	92 e0       	ldi	r25, 0x02	; 2
    2f52:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("Waiting for your command\r\n");
    2f56:	87 ee       	ldi	r24, 0xE7	; 231
    2f58:	95 e0       	ldi	r25, 0x05	; 5
    2f5a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("\r\n");
    2f5e:	8d e0       	ldi	r24, 0x0D	; 13
    2f60:	92 e0       	ldi	r25, 0x02	; 2
    2f62:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("1.Open lamps\r\n");
    2f66:	81 ee       	ldi	r24, 0xE1	; 225
    2f68:	96 e0       	ldi	r25, 0x06	; 6
    2f6a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("2.Close lamps\r\n");
    2f6e:	80 ef       	ldi	r24, 0xF0	; 240
    2f70:	96 e0       	ldi	r25, 0x06	; 6
    2f72:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("3.Variant lamp\r\n");
    2f76:	80 e0       	ldi	r24, 0x00	; 0
    2f78:	97 e0       	ldi	r25, 0x07	; 7
    2f7a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
	    UART_TX_Str("4.Display the temperature\r\n");
    2f7e:	81 e1       	ldi	r24, 0x11	; 17
    2f80:	97 e0       	ldi	r25, 0x07	; 7
    2f82:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
		UART_TX_Str("0.Logout\r\n");
    2f86:	8f ea       	ldi	r24, 0xAF	; 175
    2f88:	96 e0       	ldi	r25, 0x06	; 6
    2f8a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("Reply with the number of the command\r\n");
    2f8e:	8a eb       	ldi	r24, 0xBA	; 186
    2f90:	96 e0       	ldi	r25, 0x06	; 6
    2f92:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
        UART_TX_Str("\r\n");
    2f96:	8d e0       	ldi	r24, 0x0D	; 13
    2f98:	92 e0       	ldi	r25, 0x02	; 2
    2f9a:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
    2f9e:	0c c0       	rjmp	.+24     	; 0x2fb8 <__vector_13+0x166a>
		}
		// if there is not user
		else
		{
			UART_TX_Str("1.Enter Admin\r\n");
    2fa0:	86 e9       	ldi	r24, 0x96	; 150
    2fa2:	92 e0       	ldi	r25, 0x02	; 2
    2fa4:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("2.Enter User\r\n");
    2fa8:	86 ea       	ldi	r24, 0xA6	; 166
    2faa:	92 e0       	ldi	r25, 0x02	; 2
    2fac:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
			UART_TX_Str("\r\n");	
    2fb0:	8d e0       	ldi	r24, 0x0D	; 13
    2fb2:	92 e0       	ldi	r25, 0x02	; 2
    2fb4:	0e 94 90 0c 	call	0x1920	; 0x1920 <UART_TX_Str>
		}
    }
}
    2fb8:	2a 96       	adiw	r28, 0x0a	; 10
    2fba:	0f b6       	in	r0, 0x3f	; 63
    2fbc:	f8 94       	cli
    2fbe:	de bf       	out	0x3e, r29	; 62
    2fc0:	0f be       	out	0x3f, r0	; 63
    2fc2:	cd bf       	out	0x3d, r28	; 61
    2fc4:	df 91       	pop	r29
    2fc6:	cf 91       	pop	r28
    2fc8:	ff 91       	pop	r31
    2fca:	ef 91       	pop	r30
    2fcc:	bf 91       	pop	r27
    2fce:	af 91       	pop	r26
    2fd0:	9f 91       	pop	r25
    2fd2:	8f 91       	pop	r24
    2fd4:	7f 91       	pop	r23
    2fd6:	6f 91       	pop	r22
    2fd8:	5f 91       	pop	r21
    2fda:	4f 91       	pop	r20
    2fdc:	3f 91       	pop	r19
    2fde:	2f 91       	pop	r18
    2fe0:	1f 91       	pop	r17
    2fe2:	0f 91       	pop	r16
    2fe4:	ff 90       	pop	r15
    2fe6:	ef 90       	pop	r14
    2fe8:	df 90       	pop	r13
    2fea:	cf 90       	pop	r12
    2fec:	bf 90       	pop	r11
    2fee:	af 90       	pop	r10
    2ff0:	9f 90       	pop	r9
    2ff2:	8f 90       	pop	r8
    2ff4:	7f 90       	pop	r7
    2ff6:	6f 90       	pop	r6
    2ff8:	5f 90       	pop	r5
    2ffa:	4f 90       	pop	r4
    2ffc:	0f 90       	pop	r0
    2ffe:	0f be       	out	0x3f, r0	; 63
    3000:	0f 90       	pop	r0
    3002:	1f 90       	pop	r1
    3004:	18 95       	reti

00003006 <__vector_15>:

ISR(USART_TXC_vect) {
    3006:	1f 92       	push	r1
    3008:	0f 92       	push	r0
    300a:	0f b6       	in	r0, 0x3f	; 63
    300c:	0f 92       	push	r0
    300e:	11 24       	eor	r1, r1
    // Write UART transmit handler here

    3010:	0f 90       	pop	r0
    3012:	0f be       	out	0x3f, r0	; 63
    3014:	0f 90       	pop	r0
    3016:	1f 90       	pop	r1
    3018:	18 95       	reti

0000301a <__subsf3>:
    301a:	50 58       	subi	r21, 0x80	; 128

0000301c <__addsf3>:
    301c:	bb 27       	eor	r27, r27
    301e:	aa 27       	eor	r26, r26
    3020:	0e 94 25 18 	call	0x304a	; 0x304a <__addsf3x>
    3024:	0c 94 98 19 	jmp	0x3330	; 0x3330 <__fp_round>
    3028:	0e 94 8a 19 	call	0x3314	; 0x3314 <__fp_pscA>
    302c:	38 f0       	brcs	.+14     	; 0x303c <__addsf3+0x20>
    302e:	0e 94 91 19 	call	0x3322	; 0x3322 <__fp_pscB>
    3032:	20 f0       	brcs	.+8      	; 0x303c <__addsf3+0x20>
    3034:	39 f4       	brne	.+14     	; 0x3044 <__addsf3+0x28>
    3036:	9f 3f       	cpi	r25, 0xFF	; 255
    3038:	19 f4       	brne	.+6      	; 0x3040 <__addsf3+0x24>
    303a:	26 f4       	brtc	.+8      	; 0x3044 <__addsf3+0x28>
    303c:	0c 94 87 19 	jmp	0x330e	; 0x330e <__fp_nan>
    3040:	0e f4       	brtc	.+2      	; 0x3044 <__addsf3+0x28>
    3042:	e0 95       	com	r30
    3044:	e7 fb       	bst	r30, 7
    3046:	0c 94 81 19 	jmp	0x3302	; 0x3302 <__fp_inf>

0000304a <__addsf3x>:
    304a:	e9 2f       	mov	r30, r25
    304c:	0e 94 a9 19 	call	0x3352	; 0x3352 <__fp_split3>
    3050:	58 f3       	brcs	.-42     	; 0x3028 <__addsf3+0xc>
    3052:	ba 17       	cp	r27, r26
    3054:	62 07       	cpc	r22, r18
    3056:	73 07       	cpc	r23, r19
    3058:	84 07       	cpc	r24, r20
    305a:	95 07       	cpc	r25, r21
    305c:	20 f0       	brcs	.+8      	; 0x3066 <__addsf3x+0x1c>
    305e:	79 f4       	brne	.+30     	; 0x307e <__addsf3x+0x34>
    3060:	a6 f5       	brtc	.+104    	; 0x30ca <__addsf3x+0x80>
    3062:	0c 94 cb 19 	jmp	0x3396	; 0x3396 <__fp_zero>
    3066:	0e f4       	brtc	.+2      	; 0x306a <__addsf3x+0x20>
    3068:	e0 95       	com	r30
    306a:	0b 2e       	mov	r0, r27
    306c:	ba 2f       	mov	r27, r26
    306e:	a0 2d       	mov	r26, r0
    3070:	0b 01       	movw	r0, r22
    3072:	b9 01       	movw	r22, r18
    3074:	90 01       	movw	r18, r0
    3076:	0c 01       	movw	r0, r24
    3078:	ca 01       	movw	r24, r20
    307a:	a0 01       	movw	r20, r0
    307c:	11 24       	eor	r1, r1
    307e:	ff 27       	eor	r31, r31
    3080:	59 1b       	sub	r21, r25
    3082:	99 f0       	breq	.+38     	; 0x30aa <__addsf3x+0x60>
    3084:	59 3f       	cpi	r21, 0xF9	; 249
    3086:	50 f4       	brcc	.+20     	; 0x309c <__addsf3x+0x52>
    3088:	50 3e       	cpi	r21, 0xE0	; 224
    308a:	68 f1       	brcs	.+90     	; 0x30e6 <__addsf3x+0x9c>
    308c:	1a 16       	cp	r1, r26
    308e:	f0 40       	sbci	r31, 0x00	; 0
    3090:	a2 2f       	mov	r26, r18
    3092:	23 2f       	mov	r18, r19
    3094:	34 2f       	mov	r19, r20
    3096:	44 27       	eor	r20, r20
    3098:	58 5f       	subi	r21, 0xF8	; 248
    309a:	f3 cf       	rjmp	.-26     	; 0x3082 <__addsf3x+0x38>
    309c:	46 95       	lsr	r20
    309e:	37 95       	ror	r19
    30a0:	27 95       	ror	r18
    30a2:	a7 95       	ror	r26
    30a4:	f0 40       	sbci	r31, 0x00	; 0
    30a6:	53 95       	inc	r21
    30a8:	c9 f7       	brne	.-14     	; 0x309c <__addsf3x+0x52>
    30aa:	7e f4       	brtc	.+30     	; 0x30ca <__addsf3x+0x80>
    30ac:	1f 16       	cp	r1, r31
    30ae:	ba 0b       	sbc	r27, r26
    30b0:	62 0b       	sbc	r22, r18
    30b2:	73 0b       	sbc	r23, r19
    30b4:	84 0b       	sbc	r24, r20
    30b6:	ba f0       	brmi	.+46     	; 0x30e6 <__addsf3x+0x9c>
    30b8:	91 50       	subi	r25, 0x01	; 1
    30ba:	a1 f0       	breq	.+40     	; 0x30e4 <__addsf3x+0x9a>
    30bc:	ff 0f       	add	r31, r31
    30be:	bb 1f       	adc	r27, r27
    30c0:	66 1f       	adc	r22, r22
    30c2:	77 1f       	adc	r23, r23
    30c4:	88 1f       	adc	r24, r24
    30c6:	c2 f7       	brpl	.-16     	; 0x30b8 <__addsf3x+0x6e>
    30c8:	0e c0       	rjmp	.+28     	; 0x30e6 <__addsf3x+0x9c>
    30ca:	ba 0f       	add	r27, r26
    30cc:	62 1f       	adc	r22, r18
    30ce:	73 1f       	adc	r23, r19
    30d0:	84 1f       	adc	r24, r20
    30d2:	48 f4       	brcc	.+18     	; 0x30e6 <__addsf3x+0x9c>
    30d4:	87 95       	ror	r24
    30d6:	77 95       	ror	r23
    30d8:	67 95       	ror	r22
    30da:	b7 95       	ror	r27
    30dc:	f7 95       	ror	r31
    30de:	9e 3f       	cpi	r25, 0xFE	; 254
    30e0:	08 f0       	brcs	.+2      	; 0x30e4 <__addsf3x+0x9a>
    30e2:	b0 cf       	rjmp	.-160    	; 0x3044 <__addsf3+0x28>
    30e4:	93 95       	inc	r25
    30e6:	88 0f       	add	r24, r24
    30e8:	08 f0       	brcs	.+2      	; 0x30ec <__addsf3x+0xa2>
    30ea:	99 27       	eor	r25, r25
    30ec:	ee 0f       	add	r30, r30
    30ee:	97 95       	ror	r25
    30f0:	87 95       	ror	r24
    30f2:	08 95       	ret

000030f4 <__cmpsf2>:
    30f4:	0e 94 5d 19 	call	0x32ba	; 0x32ba <__fp_cmp>
    30f8:	08 f4       	brcc	.+2      	; 0x30fc <__cmpsf2+0x8>
    30fa:	81 e0       	ldi	r24, 0x01	; 1
    30fc:	08 95       	ret

000030fe <__divsf3>:
    30fe:	0e 94 93 18 	call	0x3126	; 0x3126 <__divsf3x>
    3102:	0c 94 98 19 	jmp	0x3330	; 0x3330 <__fp_round>
    3106:	0e 94 91 19 	call	0x3322	; 0x3322 <__fp_pscB>
    310a:	58 f0       	brcs	.+22     	; 0x3122 <__divsf3+0x24>
    310c:	0e 94 8a 19 	call	0x3314	; 0x3314 <__fp_pscA>
    3110:	40 f0       	brcs	.+16     	; 0x3122 <__divsf3+0x24>
    3112:	29 f4       	brne	.+10     	; 0x311e <__divsf3+0x20>
    3114:	5f 3f       	cpi	r21, 0xFF	; 255
    3116:	29 f0       	breq	.+10     	; 0x3122 <__divsf3+0x24>
    3118:	0c 94 81 19 	jmp	0x3302	; 0x3302 <__fp_inf>
    311c:	51 11       	cpse	r21, r1
    311e:	0c 94 cc 19 	jmp	0x3398	; 0x3398 <__fp_szero>
    3122:	0c 94 87 19 	jmp	0x330e	; 0x330e <__fp_nan>

00003126 <__divsf3x>:
    3126:	0e 94 a9 19 	call	0x3352	; 0x3352 <__fp_split3>
    312a:	68 f3       	brcs	.-38     	; 0x3106 <__divsf3+0x8>

0000312c <__divsf3_pse>:
    312c:	99 23       	and	r25, r25
    312e:	b1 f3       	breq	.-20     	; 0x311c <__divsf3+0x1e>
    3130:	55 23       	and	r21, r21
    3132:	91 f3       	breq	.-28     	; 0x3118 <__divsf3+0x1a>
    3134:	95 1b       	sub	r25, r21
    3136:	55 0b       	sbc	r21, r21
    3138:	bb 27       	eor	r27, r27
    313a:	aa 27       	eor	r26, r26
    313c:	62 17       	cp	r22, r18
    313e:	73 07       	cpc	r23, r19
    3140:	84 07       	cpc	r24, r20
    3142:	38 f0       	brcs	.+14     	; 0x3152 <__divsf3_pse+0x26>
    3144:	9f 5f       	subi	r25, 0xFF	; 255
    3146:	5f 4f       	sbci	r21, 0xFF	; 255
    3148:	22 0f       	add	r18, r18
    314a:	33 1f       	adc	r19, r19
    314c:	44 1f       	adc	r20, r20
    314e:	aa 1f       	adc	r26, r26
    3150:	a9 f3       	breq	.-22     	; 0x313c <__divsf3_pse+0x10>
    3152:	35 d0       	rcall	.+106    	; 0x31be <__divsf3_pse+0x92>
    3154:	0e 2e       	mov	r0, r30
    3156:	3a f0       	brmi	.+14     	; 0x3166 <__divsf3_pse+0x3a>
    3158:	e0 e8       	ldi	r30, 0x80	; 128
    315a:	32 d0       	rcall	.+100    	; 0x31c0 <__divsf3_pse+0x94>
    315c:	91 50       	subi	r25, 0x01	; 1
    315e:	50 40       	sbci	r21, 0x00	; 0
    3160:	e6 95       	lsr	r30
    3162:	00 1c       	adc	r0, r0
    3164:	ca f7       	brpl	.-14     	; 0x3158 <__divsf3_pse+0x2c>
    3166:	2b d0       	rcall	.+86     	; 0x31be <__divsf3_pse+0x92>
    3168:	fe 2f       	mov	r31, r30
    316a:	29 d0       	rcall	.+82     	; 0x31be <__divsf3_pse+0x92>
    316c:	66 0f       	add	r22, r22
    316e:	77 1f       	adc	r23, r23
    3170:	88 1f       	adc	r24, r24
    3172:	bb 1f       	adc	r27, r27
    3174:	26 17       	cp	r18, r22
    3176:	37 07       	cpc	r19, r23
    3178:	48 07       	cpc	r20, r24
    317a:	ab 07       	cpc	r26, r27
    317c:	b0 e8       	ldi	r27, 0x80	; 128
    317e:	09 f0       	breq	.+2      	; 0x3182 <__divsf3_pse+0x56>
    3180:	bb 0b       	sbc	r27, r27
    3182:	80 2d       	mov	r24, r0
    3184:	bf 01       	movw	r22, r30
    3186:	ff 27       	eor	r31, r31
    3188:	93 58       	subi	r25, 0x83	; 131
    318a:	5f 4f       	sbci	r21, 0xFF	; 255
    318c:	3a f0       	brmi	.+14     	; 0x319c <__divsf3_pse+0x70>
    318e:	9e 3f       	cpi	r25, 0xFE	; 254
    3190:	51 05       	cpc	r21, r1
    3192:	78 f0       	brcs	.+30     	; 0x31b2 <__divsf3_pse+0x86>
    3194:	0c 94 81 19 	jmp	0x3302	; 0x3302 <__fp_inf>
    3198:	0c 94 cc 19 	jmp	0x3398	; 0x3398 <__fp_szero>
    319c:	5f 3f       	cpi	r21, 0xFF	; 255
    319e:	e4 f3       	brlt	.-8      	; 0x3198 <__divsf3_pse+0x6c>
    31a0:	98 3e       	cpi	r25, 0xE8	; 232
    31a2:	d4 f3       	brlt	.-12     	; 0x3198 <__divsf3_pse+0x6c>
    31a4:	86 95       	lsr	r24
    31a6:	77 95       	ror	r23
    31a8:	67 95       	ror	r22
    31aa:	b7 95       	ror	r27
    31ac:	f7 95       	ror	r31
    31ae:	9f 5f       	subi	r25, 0xFF	; 255
    31b0:	c9 f7       	brne	.-14     	; 0x31a4 <__divsf3_pse+0x78>
    31b2:	88 0f       	add	r24, r24
    31b4:	91 1d       	adc	r25, r1
    31b6:	96 95       	lsr	r25
    31b8:	87 95       	ror	r24
    31ba:	97 f9       	bld	r25, 7
    31bc:	08 95       	ret
    31be:	e1 e0       	ldi	r30, 0x01	; 1
    31c0:	66 0f       	add	r22, r22
    31c2:	77 1f       	adc	r23, r23
    31c4:	88 1f       	adc	r24, r24
    31c6:	bb 1f       	adc	r27, r27
    31c8:	62 17       	cp	r22, r18
    31ca:	73 07       	cpc	r23, r19
    31cc:	84 07       	cpc	r24, r20
    31ce:	ba 07       	cpc	r27, r26
    31d0:	20 f0       	brcs	.+8      	; 0x31da <__divsf3_pse+0xae>
    31d2:	62 1b       	sub	r22, r18
    31d4:	73 0b       	sbc	r23, r19
    31d6:	84 0b       	sbc	r24, r20
    31d8:	ba 0b       	sbc	r27, r26
    31da:	ee 1f       	adc	r30, r30
    31dc:	88 f7       	brcc	.-30     	; 0x31c0 <__divsf3_pse+0x94>
    31de:	e0 95       	com	r30
    31e0:	08 95       	ret

000031e2 <__fixunssfsi>:
    31e2:	0e 94 b1 19 	call	0x3362	; 0x3362 <__fp_splitA>
    31e6:	88 f0       	brcs	.+34     	; 0x320a <__fixunssfsi+0x28>
    31e8:	9f 57       	subi	r25, 0x7F	; 127
    31ea:	98 f0       	brcs	.+38     	; 0x3212 <__fixunssfsi+0x30>
    31ec:	b9 2f       	mov	r27, r25
    31ee:	99 27       	eor	r25, r25
    31f0:	b7 51       	subi	r27, 0x17	; 23
    31f2:	b0 f0       	brcs	.+44     	; 0x3220 <__fixunssfsi+0x3e>
    31f4:	e1 f0       	breq	.+56     	; 0x322e <__fixunssfsi+0x4c>
    31f6:	66 0f       	add	r22, r22
    31f8:	77 1f       	adc	r23, r23
    31fa:	88 1f       	adc	r24, r24
    31fc:	99 1f       	adc	r25, r25
    31fe:	1a f0       	brmi	.+6      	; 0x3206 <__fixunssfsi+0x24>
    3200:	ba 95       	dec	r27
    3202:	c9 f7       	brne	.-14     	; 0x31f6 <__fixunssfsi+0x14>
    3204:	14 c0       	rjmp	.+40     	; 0x322e <__fixunssfsi+0x4c>
    3206:	b1 30       	cpi	r27, 0x01	; 1
    3208:	91 f0       	breq	.+36     	; 0x322e <__fixunssfsi+0x4c>
    320a:	0e 94 cb 19 	call	0x3396	; 0x3396 <__fp_zero>
    320e:	b1 e0       	ldi	r27, 0x01	; 1
    3210:	08 95       	ret
    3212:	0c 94 cb 19 	jmp	0x3396	; 0x3396 <__fp_zero>
    3216:	67 2f       	mov	r22, r23
    3218:	78 2f       	mov	r23, r24
    321a:	88 27       	eor	r24, r24
    321c:	b8 5f       	subi	r27, 0xF8	; 248
    321e:	39 f0       	breq	.+14     	; 0x322e <__fixunssfsi+0x4c>
    3220:	b9 3f       	cpi	r27, 0xF9	; 249
    3222:	cc f3       	brlt	.-14     	; 0x3216 <__fixunssfsi+0x34>
    3224:	86 95       	lsr	r24
    3226:	77 95       	ror	r23
    3228:	67 95       	ror	r22
    322a:	b3 95       	inc	r27
    322c:	d9 f7       	brne	.-10     	; 0x3224 <__fixunssfsi+0x42>
    322e:	3e f4       	brtc	.+14     	; 0x323e <__fixunssfsi+0x5c>
    3230:	90 95       	com	r25
    3232:	80 95       	com	r24
    3234:	70 95       	com	r23
    3236:	61 95       	neg	r22
    3238:	7f 4f       	sbci	r23, 0xFF	; 255
    323a:	8f 4f       	sbci	r24, 0xFF	; 255
    323c:	9f 4f       	sbci	r25, 0xFF	; 255
    323e:	08 95       	ret

00003240 <__floatunsisf>:
    3240:	e8 94       	clt
    3242:	09 c0       	rjmp	.+18     	; 0x3256 <__floatsisf+0x12>

00003244 <__floatsisf>:
    3244:	97 fb       	bst	r25, 7
    3246:	3e f4       	brtc	.+14     	; 0x3256 <__floatsisf+0x12>
    3248:	90 95       	com	r25
    324a:	80 95       	com	r24
    324c:	70 95       	com	r23
    324e:	61 95       	neg	r22
    3250:	7f 4f       	sbci	r23, 0xFF	; 255
    3252:	8f 4f       	sbci	r24, 0xFF	; 255
    3254:	9f 4f       	sbci	r25, 0xFF	; 255
    3256:	99 23       	and	r25, r25
    3258:	a9 f0       	breq	.+42     	; 0x3284 <__floatsisf+0x40>
    325a:	f9 2f       	mov	r31, r25
    325c:	96 e9       	ldi	r25, 0x96	; 150
    325e:	bb 27       	eor	r27, r27
    3260:	93 95       	inc	r25
    3262:	f6 95       	lsr	r31
    3264:	87 95       	ror	r24
    3266:	77 95       	ror	r23
    3268:	67 95       	ror	r22
    326a:	b7 95       	ror	r27
    326c:	f1 11       	cpse	r31, r1
    326e:	f8 cf       	rjmp	.-16     	; 0x3260 <__floatsisf+0x1c>
    3270:	fa f4       	brpl	.+62     	; 0x32b0 <__floatsisf+0x6c>
    3272:	bb 0f       	add	r27, r27
    3274:	11 f4       	brne	.+4      	; 0x327a <__floatsisf+0x36>
    3276:	60 ff       	sbrs	r22, 0
    3278:	1b c0       	rjmp	.+54     	; 0x32b0 <__floatsisf+0x6c>
    327a:	6f 5f       	subi	r22, 0xFF	; 255
    327c:	7f 4f       	sbci	r23, 0xFF	; 255
    327e:	8f 4f       	sbci	r24, 0xFF	; 255
    3280:	9f 4f       	sbci	r25, 0xFF	; 255
    3282:	16 c0       	rjmp	.+44     	; 0x32b0 <__floatsisf+0x6c>
    3284:	88 23       	and	r24, r24
    3286:	11 f0       	breq	.+4      	; 0x328c <__floatsisf+0x48>
    3288:	96 e9       	ldi	r25, 0x96	; 150
    328a:	11 c0       	rjmp	.+34     	; 0x32ae <__floatsisf+0x6a>
    328c:	77 23       	and	r23, r23
    328e:	21 f0       	breq	.+8      	; 0x3298 <__floatsisf+0x54>
    3290:	9e e8       	ldi	r25, 0x8E	; 142
    3292:	87 2f       	mov	r24, r23
    3294:	76 2f       	mov	r23, r22
    3296:	05 c0       	rjmp	.+10     	; 0x32a2 <__floatsisf+0x5e>
    3298:	66 23       	and	r22, r22
    329a:	71 f0       	breq	.+28     	; 0x32b8 <__floatsisf+0x74>
    329c:	96 e8       	ldi	r25, 0x86	; 134
    329e:	86 2f       	mov	r24, r22
    32a0:	70 e0       	ldi	r23, 0x00	; 0
    32a2:	60 e0       	ldi	r22, 0x00	; 0
    32a4:	2a f0       	brmi	.+10     	; 0x32b0 <__floatsisf+0x6c>
    32a6:	9a 95       	dec	r25
    32a8:	66 0f       	add	r22, r22
    32aa:	77 1f       	adc	r23, r23
    32ac:	88 1f       	adc	r24, r24
    32ae:	da f7       	brpl	.-10     	; 0x32a6 <__floatsisf+0x62>
    32b0:	88 0f       	add	r24, r24
    32b2:	96 95       	lsr	r25
    32b4:	87 95       	ror	r24
    32b6:	97 f9       	bld	r25, 7
    32b8:	08 95       	ret

000032ba <__fp_cmp>:
    32ba:	99 0f       	add	r25, r25
    32bc:	00 08       	sbc	r0, r0
    32be:	55 0f       	add	r21, r21
    32c0:	aa 0b       	sbc	r26, r26
    32c2:	e0 e8       	ldi	r30, 0x80	; 128
    32c4:	fe ef       	ldi	r31, 0xFE	; 254
    32c6:	16 16       	cp	r1, r22
    32c8:	17 06       	cpc	r1, r23
    32ca:	e8 07       	cpc	r30, r24
    32cc:	f9 07       	cpc	r31, r25
    32ce:	c0 f0       	brcs	.+48     	; 0x3300 <__fp_cmp+0x46>
    32d0:	12 16       	cp	r1, r18
    32d2:	13 06       	cpc	r1, r19
    32d4:	e4 07       	cpc	r30, r20
    32d6:	f5 07       	cpc	r31, r21
    32d8:	98 f0       	brcs	.+38     	; 0x3300 <__fp_cmp+0x46>
    32da:	62 1b       	sub	r22, r18
    32dc:	73 0b       	sbc	r23, r19
    32de:	84 0b       	sbc	r24, r20
    32e0:	95 0b       	sbc	r25, r21
    32e2:	39 f4       	brne	.+14     	; 0x32f2 <__fp_cmp+0x38>
    32e4:	0a 26       	eor	r0, r26
    32e6:	61 f0       	breq	.+24     	; 0x3300 <__fp_cmp+0x46>
    32e8:	23 2b       	or	r18, r19
    32ea:	24 2b       	or	r18, r20
    32ec:	25 2b       	or	r18, r21
    32ee:	21 f4       	brne	.+8      	; 0x32f8 <__fp_cmp+0x3e>
    32f0:	08 95       	ret
    32f2:	0a 26       	eor	r0, r26
    32f4:	09 f4       	brne	.+2      	; 0x32f8 <__fp_cmp+0x3e>
    32f6:	a1 40       	sbci	r26, 0x01	; 1
    32f8:	a6 95       	lsr	r26
    32fa:	8f ef       	ldi	r24, 0xFF	; 255
    32fc:	81 1d       	adc	r24, r1
    32fe:	81 1d       	adc	r24, r1
    3300:	08 95       	ret

00003302 <__fp_inf>:
    3302:	97 f9       	bld	r25, 7
    3304:	9f 67       	ori	r25, 0x7F	; 127
    3306:	80 e8       	ldi	r24, 0x80	; 128
    3308:	70 e0       	ldi	r23, 0x00	; 0
    330a:	60 e0       	ldi	r22, 0x00	; 0
    330c:	08 95       	ret

0000330e <__fp_nan>:
    330e:	9f ef       	ldi	r25, 0xFF	; 255
    3310:	80 ec       	ldi	r24, 0xC0	; 192
    3312:	08 95       	ret

00003314 <__fp_pscA>:
    3314:	00 24       	eor	r0, r0
    3316:	0a 94       	dec	r0
    3318:	16 16       	cp	r1, r22
    331a:	17 06       	cpc	r1, r23
    331c:	18 06       	cpc	r1, r24
    331e:	09 06       	cpc	r0, r25
    3320:	08 95       	ret

00003322 <__fp_pscB>:
    3322:	00 24       	eor	r0, r0
    3324:	0a 94       	dec	r0
    3326:	12 16       	cp	r1, r18
    3328:	13 06       	cpc	r1, r19
    332a:	14 06       	cpc	r1, r20
    332c:	05 06       	cpc	r0, r21
    332e:	08 95       	ret

00003330 <__fp_round>:
    3330:	09 2e       	mov	r0, r25
    3332:	03 94       	inc	r0
    3334:	00 0c       	add	r0, r0
    3336:	11 f4       	brne	.+4      	; 0x333c <__fp_round+0xc>
    3338:	88 23       	and	r24, r24
    333a:	52 f0       	brmi	.+20     	; 0x3350 <__fp_round+0x20>
    333c:	bb 0f       	add	r27, r27
    333e:	40 f4       	brcc	.+16     	; 0x3350 <__fp_round+0x20>
    3340:	bf 2b       	or	r27, r31
    3342:	11 f4       	brne	.+4      	; 0x3348 <__fp_round+0x18>
    3344:	60 ff       	sbrs	r22, 0
    3346:	04 c0       	rjmp	.+8      	; 0x3350 <__fp_round+0x20>
    3348:	6f 5f       	subi	r22, 0xFF	; 255
    334a:	7f 4f       	sbci	r23, 0xFF	; 255
    334c:	8f 4f       	sbci	r24, 0xFF	; 255
    334e:	9f 4f       	sbci	r25, 0xFF	; 255
    3350:	08 95       	ret

00003352 <__fp_split3>:
    3352:	57 fd       	sbrc	r21, 7
    3354:	90 58       	subi	r25, 0x80	; 128
    3356:	44 0f       	add	r20, r20
    3358:	55 1f       	adc	r21, r21
    335a:	59 f0       	breq	.+22     	; 0x3372 <__fp_splitA+0x10>
    335c:	5f 3f       	cpi	r21, 0xFF	; 255
    335e:	71 f0       	breq	.+28     	; 0x337c <__fp_splitA+0x1a>
    3360:	47 95       	ror	r20

00003362 <__fp_splitA>:
    3362:	88 0f       	add	r24, r24
    3364:	97 fb       	bst	r25, 7
    3366:	99 1f       	adc	r25, r25
    3368:	61 f0       	breq	.+24     	; 0x3382 <__fp_splitA+0x20>
    336a:	9f 3f       	cpi	r25, 0xFF	; 255
    336c:	79 f0       	breq	.+30     	; 0x338c <__fp_splitA+0x2a>
    336e:	87 95       	ror	r24
    3370:	08 95       	ret
    3372:	12 16       	cp	r1, r18
    3374:	13 06       	cpc	r1, r19
    3376:	14 06       	cpc	r1, r20
    3378:	55 1f       	adc	r21, r21
    337a:	f2 cf       	rjmp	.-28     	; 0x3360 <__fp_split3+0xe>
    337c:	46 95       	lsr	r20
    337e:	f1 df       	rcall	.-30     	; 0x3362 <__fp_splitA>
    3380:	08 c0       	rjmp	.+16     	; 0x3392 <__fp_splitA+0x30>
    3382:	16 16       	cp	r1, r22
    3384:	17 06       	cpc	r1, r23
    3386:	18 06       	cpc	r1, r24
    3388:	99 1f       	adc	r25, r25
    338a:	f1 cf       	rjmp	.-30     	; 0x336e <__fp_splitA+0xc>
    338c:	86 95       	lsr	r24
    338e:	71 05       	cpc	r23, r1
    3390:	61 05       	cpc	r22, r1
    3392:	08 94       	sec
    3394:	08 95       	ret

00003396 <__fp_zero>:
    3396:	e8 94       	clt

00003398 <__fp_szero>:
    3398:	bb 27       	eor	r27, r27
    339a:	66 27       	eor	r22, r22
    339c:	77 27       	eor	r23, r23
    339e:	cb 01       	movw	r24, r22
    33a0:	97 f9       	bld	r25, 7
    33a2:	08 95       	ret

000033a4 <__gesf2>:
    33a4:	0e 94 5d 19 	call	0x32ba	; 0x32ba <__fp_cmp>
    33a8:	08 f4       	brcc	.+2      	; 0x33ac <__gesf2+0x8>
    33aa:	8f ef       	ldi	r24, 0xFF	; 255
    33ac:	08 95       	ret

000033ae <__mulsf3>:
    33ae:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <__mulsf3x>
    33b2:	0c 94 98 19 	jmp	0x3330	; 0x3330 <__fp_round>
    33b6:	0e 94 8a 19 	call	0x3314	; 0x3314 <__fp_pscA>
    33ba:	38 f0       	brcs	.+14     	; 0x33ca <__mulsf3+0x1c>
    33bc:	0e 94 91 19 	call	0x3322	; 0x3322 <__fp_pscB>
    33c0:	20 f0       	brcs	.+8      	; 0x33ca <__mulsf3+0x1c>
    33c2:	95 23       	and	r25, r21
    33c4:	11 f0       	breq	.+4      	; 0x33ca <__mulsf3+0x1c>
    33c6:	0c 94 81 19 	jmp	0x3302	; 0x3302 <__fp_inf>
    33ca:	0c 94 87 19 	jmp	0x330e	; 0x330e <__fp_nan>
    33ce:	11 24       	eor	r1, r1
    33d0:	0c 94 cc 19 	jmp	0x3398	; 0x3398 <__fp_szero>

000033d4 <__mulsf3x>:
    33d4:	0e 94 a9 19 	call	0x3352	; 0x3352 <__fp_split3>
    33d8:	70 f3       	brcs	.-36     	; 0x33b6 <__mulsf3+0x8>

000033da <__mulsf3_pse>:
    33da:	95 9f       	mul	r25, r21
    33dc:	c1 f3       	breq	.-16     	; 0x33ce <__mulsf3+0x20>
    33de:	95 0f       	add	r25, r21
    33e0:	50 e0       	ldi	r21, 0x00	; 0
    33e2:	55 1f       	adc	r21, r21
    33e4:	62 9f       	mul	r22, r18
    33e6:	f0 01       	movw	r30, r0
    33e8:	72 9f       	mul	r23, r18
    33ea:	bb 27       	eor	r27, r27
    33ec:	f0 0d       	add	r31, r0
    33ee:	b1 1d       	adc	r27, r1
    33f0:	63 9f       	mul	r22, r19
    33f2:	aa 27       	eor	r26, r26
    33f4:	f0 0d       	add	r31, r0
    33f6:	b1 1d       	adc	r27, r1
    33f8:	aa 1f       	adc	r26, r26
    33fa:	64 9f       	mul	r22, r20
    33fc:	66 27       	eor	r22, r22
    33fe:	b0 0d       	add	r27, r0
    3400:	a1 1d       	adc	r26, r1
    3402:	66 1f       	adc	r22, r22
    3404:	82 9f       	mul	r24, r18
    3406:	22 27       	eor	r18, r18
    3408:	b0 0d       	add	r27, r0
    340a:	a1 1d       	adc	r26, r1
    340c:	62 1f       	adc	r22, r18
    340e:	73 9f       	mul	r23, r19
    3410:	b0 0d       	add	r27, r0
    3412:	a1 1d       	adc	r26, r1
    3414:	62 1f       	adc	r22, r18
    3416:	83 9f       	mul	r24, r19
    3418:	a0 0d       	add	r26, r0
    341a:	61 1d       	adc	r22, r1
    341c:	22 1f       	adc	r18, r18
    341e:	74 9f       	mul	r23, r20
    3420:	33 27       	eor	r19, r19
    3422:	a0 0d       	add	r26, r0
    3424:	61 1d       	adc	r22, r1
    3426:	23 1f       	adc	r18, r19
    3428:	84 9f       	mul	r24, r20
    342a:	60 0d       	add	r22, r0
    342c:	21 1d       	adc	r18, r1
    342e:	82 2f       	mov	r24, r18
    3430:	76 2f       	mov	r23, r22
    3432:	6a 2f       	mov	r22, r26
    3434:	11 24       	eor	r1, r1
    3436:	9f 57       	subi	r25, 0x7F	; 127
    3438:	50 40       	sbci	r21, 0x00	; 0
    343a:	9a f0       	brmi	.+38     	; 0x3462 <__mulsf3_pse+0x88>
    343c:	f1 f0       	breq	.+60     	; 0x347a <__mulsf3_pse+0xa0>
    343e:	88 23       	and	r24, r24
    3440:	4a f0       	brmi	.+18     	; 0x3454 <__mulsf3_pse+0x7a>
    3442:	ee 0f       	add	r30, r30
    3444:	ff 1f       	adc	r31, r31
    3446:	bb 1f       	adc	r27, r27
    3448:	66 1f       	adc	r22, r22
    344a:	77 1f       	adc	r23, r23
    344c:	88 1f       	adc	r24, r24
    344e:	91 50       	subi	r25, 0x01	; 1
    3450:	50 40       	sbci	r21, 0x00	; 0
    3452:	a9 f7       	brne	.-22     	; 0x343e <__mulsf3_pse+0x64>
    3454:	9e 3f       	cpi	r25, 0xFE	; 254
    3456:	51 05       	cpc	r21, r1
    3458:	80 f0       	brcs	.+32     	; 0x347a <__mulsf3_pse+0xa0>
    345a:	0c 94 81 19 	jmp	0x3302	; 0x3302 <__fp_inf>
    345e:	0c 94 cc 19 	jmp	0x3398	; 0x3398 <__fp_szero>
    3462:	5f 3f       	cpi	r21, 0xFF	; 255
    3464:	e4 f3       	brlt	.-8      	; 0x345e <__mulsf3_pse+0x84>
    3466:	98 3e       	cpi	r25, 0xE8	; 232
    3468:	d4 f3       	brlt	.-12     	; 0x345e <__mulsf3_pse+0x84>
    346a:	86 95       	lsr	r24
    346c:	77 95       	ror	r23
    346e:	67 95       	ror	r22
    3470:	b7 95       	ror	r27
    3472:	f7 95       	ror	r31
    3474:	e7 95       	ror	r30
    3476:	9f 5f       	subi	r25, 0xFF	; 255
    3478:	c1 f7       	brne	.-16     	; 0x346a <__mulsf3_pse+0x90>
    347a:	fe 2b       	or	r31, r30
    347c:	88 0f       	add	r24, r24
    347e:	91 1d       	adc	r25, r1
    3480:	96 95       	lsr	r25
    3482:	87 95       	ror	r24
    3484:	97 f9       	bld	r25, 7
    3486:	08 95       	ret

00003488 <__divmodhi4>:
    3488:	97 fb       	bst	r25, 7
    348a:	07 2e       	mov	r0, r23
    348c:	16 f4       	brtc	.+4      	; 0x3492 <__divmodhi4+0xa>
    348e:	00 94       	com	r0
    3490:	07 d0       	rcall	.+14     	; 0x34a0 <__divmodhi4_neg1>
    3492:	77 fd       	sbrc	r23, 7
    3494:	09 d0       	rcall	.+18     	; 0x34a8 <__divmodhi4_neg2>
    3496:	0e 94 7a 1a 	call	0x34f4	; 0x34f4 <__udivmodhi4>
    349a:	07 fc       	sbrc	r0, 7
    349c:	05 d0       	rcall	.+10     	; 0x34a8 <__divmodhi4_neg2>
    349e:	3e f4       	brtc	.+14     	; 0x34ae <__divmodhi4_exit>

000034a0 <__divmodhi4_neg1>:
    34a0:	90 95       	com	r25
    34a2:	81 95       	neg	r24
    34a4:	9f 4f       	sbci	r25, 0xFF	; 255
    34a6:	08 95       	ret

000034a8 <__divmodhi4_neg2>:
    34a8:	70 95       	com	r23
    34aa:	61 95       	neg	r22
    34ac:	7f 4f       	sbci	r23, 0xFF	; 255

000034ae <__divmodhi4_exit>:
    34ae:	08 95       	ret

000034b0 <__udivmodsi4>:
    34b0:	a1 e2       	ldi	r26, 0x21	; 33
    34b2:	1a 2e       	mov	r1, r26
    34b4:	aa 1b       	sub	r26, r26
    34b6:	bb 1b       	sub	r27, r27
    34b8:	fd 01       	movw	r30, r26
    34ba:	0d c0       	rjmp	.+26     	; 0x34d6 <__udivmodsi4_ep>

000034bc <__udivmodsi4_loop>:
    34bc:	aa 1f       	adc	r26, r26
    34be:	bb 1f       	adc	r27, r27
    34c0:	ee 1f       	adc	r30, r30
    34c2:	ff 1f       	adc	r31, r31
    34c4:	a2 17       	cp	r26, r18
    34c6:	b3 07       	cpc	r27, r19
    34c8:	e4 07       	cpc	r30, r20
    34ca:	f5 07       	cpc	r31, r21
    34cc:	20 f0       	brcs	.+8      	; 0x34d6 <__udivmodsi4_ep>
    34ce:	a2 1b       	sub	r26, r18
    34d0:	b3 0b       	sbc	r27, r19
    34d2:	e4 0b       	sbc	r30, r20
    34d4:	f5 0b       	sbc	r31, r21

000034d6 <__udivmodsi4_ep>:
    34d6:	66 1f       	adc	r22, r22
    34d8:	77 1f       	adc	r23, r23
    34da:	88 1f       	adc	r24, r24
    34dc:	99 1f       	adc	r25, r25
    34de:	1a 94       	dec	r1
    34e0:	69 f7       	brne	.-38     	; 0x34bc <__udivmodsi4_loop>
    34e2:	60 95       	com	r22
    34e4:	70 95       	com	r23
    34e6:	80 95       	com	r24
    34e8:	90 95       	com	r25
    34ea:	9b 01       	movw	r18, r22
    34ec:	ac 01       	movw	r20, r24
    34ee:	bd 01       	movw	r22, r26
    34f0:	cf 01       	movw	r24, r30
    34f2:	08 95       	ret

000034f4 <__udivmodhi4>:
    34f4:	aa 1b       	sub	r26, r26
    34f6:	bb 1b       	sub	r27, r27
    34f8:	51 e1       	ldi	r21, 0x11	; 17
    34fa:	07 c0       	rjmp	.+14     	; 0x350a <__udivmodhi4_ep>

000034fc <__udivmodhi4_loop>:
    34fc:	aa 1f       	adc	r26, r26
    34fe:	bb 1f       	adc	r27, r27
    3500:	a6 17       	cp	r26, r22
    3502:	b7 07       	cpc	r27, r23
    3504:	10 f0       	brcs	.+4      	; 0x350a <__udivmodhi4_ep>
    3506:	a6 1b       	sub	r26, r22
    3508:	b7 0b       	sbc	r27, r23

0000350a <__udivmodhi4_ep>:
    350a:	88 1f       	adc	r24, r24
    350c:	99 1f       	adc	r25, r25
    350e:	5a 95       	dec	r21
    3510:	a9 f7       	brne	.-22     	; 0x34fc <__udivmodhi4_loop>
    3512:	80 95       	com	r24
    3514:	90 95       	com	r25
    3516:	bc 01       	movw	r22, r24
    3518:	cd 01       	movw	r24, r26
    351a:	08 95       	ret

0000351c <_exit>:
    351c:	f8 94       	cli

0000351e <__stop_program>:
    351e:	ff cf       	rjmp	.-2      	; 0x351e <__stop_program>
